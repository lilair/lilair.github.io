<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
<meta property="og:type" content="website">
<meta property="og:title" content="学海无涯，惟勤是岸。">
<meta property="og:url" content="http://yoursite.com/page/26/index.html">
<meta property="og:site_name" content="学海无涯，惟勤是岸。">
<meta property="og:description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学海无涯，惟勤是岸。">
<meta name="twitter:description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
  <link rel="canonical" href="http://yoursite.com/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>学海无涯，惟勤是岸。</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">学海无涯，惟勤是岸。</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">认真生活，快乐工作。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">539</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/WrapDynaClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/WrapDynaClass/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:13:59" itemprop="dateModified" datetime="2010-03-24T17:13:59+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>    <a name="line.17"></a>
<font color="green">018</font>    package org.apache.commons.beanutils;<a name="line.18"></a>
<font color="green">019</font>    <a name="line.19"></a>
<font color="green">020</font>    <a name="line.20"></a>
<font color="green">021</font>    import java.beans.PropertyDescriptor;<a name="line.21"></a>
<font color="green">022</font>    import java.lang.ref.Reference;<a name="line.22"></a>
<font color="green">023</font>    import java.lang.ref.SoftReference;<a name="line.23"></a>
<font color="green">024</font>    import java.util.Collection;<a name="line.24"></a>
<font color="green">025</font>    import java.util.HashMap;<a name="line.25"></a>
<font color="green">026</font>    import java.util.Iterator;<a name="line.26"></a>
<font color="green">027</font>    import java.util.Map;<a name="line.27"></a>
<font color="green">028</font>    import java.util.Set;<a name="line.28"></a>
<font color="green">029</font>    import java.util.WeakHashMap;<a name="line.29"></a>
<font color="green">030</font>    <a name="line.30"></a>
<font color="green">031</font>    <a name="line.31"></a>
<font color="green">032</font>    /**<a name="line.32"></a>
<font color="green">033</font>     * &lt;p&gt;Implementation of &lt;code&gt;DynaClass&lt;/code&gt; for DynaBeans that wrap<a name="line.33"></a>
<font color="green">034</font>     * standard JavaBean instances.&lt;/p&gt;<a name="line.34"></a>
<font color="green">035</font>     *<a name="line.35"></a>
<font color="green">036</font>     * &lt;p&gt;<a name="line.36"></a>
<font color="green">037</font>     * It is suggested that this class should not usually need to be used directly<a name="line.37"></a>
<font color="green">038</font>     * to create new &lt;code&gt;WrapDynaBean&lt;/code&gt; instances. <a name="line.38"></a>
<font color="green">039</font>     * It's usually better to call the &lt;code&gt;WrapDynaBean&lt;/code&gt; constructor directly.<a name="line.39"></a>
<font color="green">040</font>     * For example:&lt;/p&gt;<a name="line.40"></a>
<font color="green">041</font>     * &lt;code&gt;&lt;pre&gt;<a name="line.41"></a>
<font color="green">042</font>     *   Object javaBean = ...;<a name="line.42"></a>
<font color="green">043</font>     *   DynaBean wrapper = new WrapDynaBean(javaBean);<a name="line.43"></a>
<font color="green">044</font>     * &lt;/pre&gt;&lt;/code&gt;<a name="line.44"></a>
<font color="green">045</font>     * &lt;p&gt;<a name="line.45"></a>
<font color="green">046</font>     *<a name="line.46"></a>
<font color="green">047</font>     * @author Craig McClanahan<a name="line.47"></a>
<font color="green">048</font>     * @version $Revision: 690380 $ $Date: 2008-08-29 21:04:38 +0100 (Fri, 29 Aug 2008) $<a name="line.48"></a>
<font color="green">049</font>     */<a name="line.49"></a>
<font color="green">050</font>    <a name="line.50"></a>
<font color="green">051</font>    public class WrapDynaClass implements DynaClass {<a name="line.51"></a>
<font color="green">052</font>    <a name="line.52"></a>
<font color="green">053</font>    <a name="line.53"></a>
<font color="green">054</font>        // ----------------------------------------------------------- Constructors<a name="line.54"></a>
<font color="green">055</font>    <a name="line.55"></a>
<font color="green">056</font>    <a name="line.56"></a>
<font color="green">057</font>        /**<a name="line.57"></a>
<font color="green">058</font>         * Construct a new WrapDynaClass for the specified JavaBean class.  This<a name="line.58"></a>
<font color="green">059</font>         * constructor is private; WrapDynaClass instances will be created as<a name="line.59"></a>
<font color="green">060</font>         * needed via calls to the &lt;code&gt;createDynaClass(Class)&lt;/code&gt; method.<a name="line.60"></a>
<font color="green">061</font>         *<a name="line.61"></a>
<font color="green">062</font>         * @param beanClass JavaBean class to be introspected around<a name="line.62"></a>
<font color="green">063</font>         */<a name="line.63"></a>
<font color="green">064</font>        private WrapDynaClass(Class beanClass) {<a name="line.64"></a>
<font color="green">065</font>    <a name="line.65"></a>
<font color="green">066</font>            this.beanClassRef = new SoftReference(beanClass);<a name="line.66"></a>
<font color="green">067</font>            this.beanClassName = beanClass.getName();<a name="line.67"></a>
<font color="green">068</font>            introspect();<a name="line.68"></a>
<font color="green">069</font>    <a name="line.69"></a>
<font color="green">070</font>        }<a name="line.70"></a>
<font color="green">071</font>    <a name="line.71"></a>
<font color="green">072</font>    <a name="line.72"></a>
<font color="green">073</font>        // ----------------------------------------------------- Instance Variables<a name="line.73"></a>
<font color="green">074</font>    <a name="line.74"></a>
<font color="green">075</font>        /**<a name="line.75"></a>
<font color="green">076</font>         * Name of the JavaBean class represented by this WrapDynaClass.<a name="line.76"></a>
<font color="green">077</font>         */<a name="line.77"></a>
<font color="green">078</font>        private String beanClassName = null;<a name="line.78"></a>
<font color="green">079</font>    <a name="line.79"></a>
<font color="green">080</font>        /**<a name="line.80"></a>
<font color="green">081</font>         * Reference to the JavaBean class represented by this WrapDynaClass.<a name="line.81"></a>
<font color="green">082</font>         */<a name="line.82"></a>
<font color="green">083</font>        private Reference beanClassRef = null;<a name="line.83"></a>
<font color="green">084</font>    <a name="line.84"></a>
<font color="green">085</font>        /**<a name="line.85"></a>
<font color="green">086</font>         * The JavaBean &lt;code&gt;Class&lt;/code&gt; which is represented by this<a name="line.86"></a>
<font color="green">087</font>         * &lt;code&gt;WrapDynaClass&lt;/code&gt;.<a name="line.87"></a>
<font color="green">088</font>         *<a name="line.88"></a>
<font color="green">089</font>         * @deprecated No longer initialized, use getBeanClass() method instead<a name="line.89"></a>
<font color="green">090</font>         */<a name="line.90"></a>
<font color="green">091</font>        protected Class beanClass = null;<a name="line.91"></a>
<font color="green">092</font>    <a name="line.92"></a>
<font color="green">093</font>    <a name="line.93"></a>
<font color="green">094</font>        /**<a name="line.94"></a>
<font color="green">095</font>         * The set of PropertyDescriptors for this bean class.<a name="line.95"></a>
<font color="green">096</font>         */<a name="line.96"></a>
<font color="green">097</font>        protected PropertyDescriptor[] descriptors = null;<a name="line.97"></a>
<font color="green">098</font>    <a name="line.98"></a>
<font color="green">099</font>    <a name="line.99"></a>
<font color="green">100</font>        /**<a name="line.100"></a>
<font color="green">101</font>         * The set of PropertyDescriptors for this bean class, keyed by the<a name="line.101"></a>
<font color="green">102</font>         * property name.  Individual descriptor instances will be the same<a name="line.102"></a>
<font color="green">103</font>         * instances as those in the &lt;code&gt;descriptors&lt;/code&gt; list.<a name="line.103"></a>
<font color="green">104</font>         */<a name="line.104"></a>
<font color="green">105</font>        protected HashMap descriptorsMap = new HashMap();<a name="line.105"></a>
<font color="green">106</font>    <a name="line.106"></a>
<font color="green">107</font>    <a name="line.107"></a>
<font color="green">108</font>        /**<a name="line.108"></a>
<font color="green">109</font>         * The set of dynamic properties that are part of this DynaClass.<a name="line.109"></a>
<font color="green">110</font>         */<a name="line.110"></a>
<font color="green">111</font>        protected DynaProperty[] properties = null;<a name="line.111"></a>
<font color="green">112</font>    <a name="line.112"></a>
<font color="green">113</font>    <a name="line.113"></a>
<font color="green">114</font>        /**<a name="line.114"></a>
<font color="green">115</font>         * The set of dynamic properties that are part of this DynaClass,<a name="line.115"></a>
<font color="green">116</font>         * keyed by the property name.  Individual descriptor instances will<a name="line.116"></a>
<font color="green">117</font>         * be the same instances as those in the &lt;code&gt;properties&lt;/code&gt; list.<a name="line.117"></a>
<font color="green">118</font>         */<a name="line.118"></a>
<font color="green">119</font>        protected HashMap propertiesMap = new HashMap();<a name="line.119"></a>
<font color="green">120</font>    <a name="line.120"></a>
<font color="green">121</font>    <a name="line.121"></a>
<font color="green">122</font>        // ------------------------------------------------------- Static Variables<a name="line.122"></a>
<font color="green">123</font>    <a name="line.123"></a>
<font color="green">124</font>    <a name="line.124"></a>
<font color="green">125</font>        private static final ContextClassLoaderLocal CLASSLOADER_CACHE = <a name="line.125"></a>
<font color="green">126</font>            new ContextClassLoaderLocal() {<a name="line.126"></a>
<font color="green">127</font>                protected Object initialValue() {<a name="line.127"></a>
<font color="green">128</font>                    return new WeakHashMap();<a name="line.128"></a>
<font color="green">129</font>            }<a name="line.129"></a>
<font color="green">130</font>        };<a name="line.130"></a>
<font color="green">131</font>    <a name="line.131"></a>
<font color="green">132</font>        /**<a name="line.132"></a>
<font color="green">133</font>         * Get the wrap dyna classes cache<a name="line.133"></a>
<font color="green">134</font>         */<a name="line.134"></a>
<font color="green">135</font>        private static Map getDynaClassesMap() {<a name="line.135"></a>
<font color="green">136</font>            return (Map)CLASSLOADER_CACHE.get();<a name="line.136"></a>
<font color="green">137</font>        }<a name="line.137"></a>
<font color="green">138</font>    <a name="line.138"></a>
<font color="green">139</font>        /**<a name="line.139"></a>
<font color="green">140</font>         * The set of &lt;code&gt;WrapDynaClass&lt;/code&gt; instances that have ever been<a name="line.140"></a>
<font color="green">141</font>         * created, keyed by the underlying bean Class. The keys to this map<a name="line.141"></a>
<font color="green">142</font>         * are Class objects, and the values are corresponding WrapDynaClass<a name="line.142"></a>
<font color="green">143</font>         * objects.<a name="line.143"></a>
<font color="green">144</font>         * &lt;p&gt;<a name="line.144"></a>
<font color="green">145</font>         * This static variable is safe even when this code is deployed via a<a name="line.145"></a>
<font color="green">146</font>         * shared classloader because it is keyed via a Class object. The same<a name="line.146"></a>
<font color="green">147</font>         * class loaded via two different classloaders will result in different<a name="line.147"></a>
<font color="green">148</font>         * entries in this map.<a name="line.148"></a>
<font color="green">149</font>         * &lt;p&gt;<a name="line.149"></a>
<font color="green">150</font>         * Note, however, that this HashMap can result in a memory leak. When<a name="line.150"></a>
<font color="green">151</font>         * this class is in a shared classloader it will retain references to<a name="line.151"></a>
<font color="green">152</font>         * classes loaded via a webapp classloader even after the webapp has been<a name="line.152"></a>
<font color="green">153</font>         * undeployed. That will prevent the entire classloader and all the classes<a name="line.153"></a>
<font color="green">154</font>         * it refers to and all their static members from being freed.<a name="line.154"></a>
<font color="green">155</font>         *<a name="line.155"></a>
<font color="green">156</font>         ************* !!!!!!!!!!!! PLEASE NOTE !!!!!!!!!!!! *************<a name="line.156"></a>
<font color="green">157</font>         *<a name="line.157"></a>
<font color="green">158</font>         * THE FOLLOWING IS A NASTY HACK TO SO THAT BEANUTILS REMAINS BINARY<a name="line.158"></a>
<font color="green">159</font>         *              COMPATIBLE WITH PREVIOUS RELEASES.<a name="line.159"></a>
<font color="green">160</font>         *<a name="line.160"></a>
<font color="green">161</font>         * There are two issues here:<a name="line.161"></a>
<font color="green">162</font>         * <a name="line.162"></a>
<font color="green">163</font>         * 1) Memory Issues: The static HashMap caused memory problems (See BEANUTILS-59)<a name="line.163"></a>
<font color="green">164</font>         *    to resolve this it has been moved into a ContextClassLoaderLocal instance<a name="line.164"></a>
<font color="green">165</font>         *    (named CLASSLOADER_CACHE above) which holds one copy per<a name="line.165"></a>
<font color="green">166</font>         *    ClassLoader in a WeakHashMap.<a name="line.166"></a>
<font color="green">167</font>         * <a name="line.167"></a>
<font color="green">168</font>         * 2) Binary Compatibility: As the "dynaClasses" static HashMap is "protected"<a name="line.168"></a>
<font color="green">169</font>         *    removing it breaks BeanUtils binary compatibility with previous versions.<a name="line.169"></a>
<font color="green">170</font>         *    To resolve this all the methods have been overriden to delegate to the<a name="line.170"></a>
<font color="green">171</font>         *    Map for the ClassLoader in the ContextClassLoaderLocal.<a name="line.171"></a>
<font color="green">172</font>         *<a name="line.172"></a>
<font color="green">173</font>         * @deprecated The dynaClasses Map will be removed in a subsequent release<a name="line.173"></a>
<font color="green">174</font>         */<a name="line.174"></a>
<font color="green">175</font>        protected static HashMap dynaClasses = new HashMap() {<a name="line.175"></a>
<font color="green">176</font>            public void clear() {<a name="line.176"></a>
<font color="green">177</font>                getDynaClassesMap().clear();<a name="line.177"></a>
<font color="green">178</font>            }<a name="line.178"></a>
<font color="green">179</font>            public boolean containsKey(Object key) {<a name="line.179"></a>
<font color="green">180</font>                return getDynaClassesMap().containsKey(key);<a name="line.180"></a>
<font color="green">181</font>            }<a name="line.181"></a>
<font color="green">182</font>            public boolean containsValue(Object value) {<a name="line.182"></a>
<font color="green">183</font>                return getDynaClassesMap().containsValue(value);<a name="line.183"></a>
<font color="green">184</font>            }<a name="line.184"></a>
<font color="green">185</font>            public Set entrySet() {<a name="line.185"></a>
<font color="green">186</font>                return getDynaClassesMap().entrySet();<a name="line.186"></a>
<font color="green">187</font>            }<a name="line.187"></a>
<font color="green">188</font>            public boolean equals(Object o) {<a name="line.188"></a>
<font color="green">189</font>                return getDynaClassesMap().equals(o);<a name="line.189"></a>
<font color="green">190</font>            }<a name="line.190"></a>
<font color="green">191</font>            public Object get(Object key) {<a name="line.191"></a>
<font color="green">192</font>                return getDynaClassesMap().get(key);<a name="line.192"></a>
<font color="green">193</font>            }<a name="line.193"></a>
<font color="green">194</font>            public int hashCode() {<a name="line.194"></a>
<font color="green">195</font>                return getDynaClassesMap().hashCode();<a name="line.195"></a>
<font color="green">196</font>            }<a name="line.196"></a>
<font color="green">197</font>            public boolean isEmpty() {<a name="line.197"></a>
<font color="green">198</font>                return getDynaClassesMap().isEmpty();<a name="line.198"></a>
<font color="green">199</font>            }<a name="line.199"></a>
<font color="green">200</font>            public Set keySet() {<a name="line.200"></a>
<font color="green">201</font>                return getDynaClassesMap().keySet();<a name="line.201"></a>
<font color="green">202</font>            }<a name="line.202"></a>
<font color="green">203</font>            public Object put(Object key, Object value) {<a name="line.203"></a>
<font color="green">204</font>                return getDynaClassesMap().put(key, value);<a name="line.204"></a>
<font color="green">205</font>            }<a name="line.205"></a>
<font color="green">206</font>            public void putAll(Map m) {<a name="line.206"></a>
<font color="green">207</font>                getDynaClassesMap().putAll(m);<a name="line.207"></a>
<font color="green">208</font>            }<a name="line.208"></a>
<font color="green">209</font>            public Object remove(Object key) {<a name="line.209"></a>
<font color="green">210</font>                return getDynaClassesMap().remove(key);<a name="line.210"></a>
<font color="green">211</font>            }<a name="line.211"></a>
<font color="green">212</font>            public int size() {<a name="line.212"></a>
<font color="green">213</font>                return getDynaClassesMap().size();<a name="line.213"></a>
<font color="green">214</font>            }<a name="line.214"></a>
<font color="green">215</font>            public Collection values() {<a name="line.215"></a>
<font color="green">216</font>                return getDynaClassesMap().values();<a name="line.216"></a>
<font color="green">217</font>            }<a name="line.217"></a>
<font color="green">218</font>        };<a name="line.218"></a>
<font color="green">219</font>    <a name="line.219"></a>
<font color="green">220</font>    <a name="line.220"></a>
<font color="green">221</font>        // ------------------------------------------------------ DynaClass Methods<a name="line.221"></a>
<font color="green">222</font>    <a name="line.222"></a>
<font color="green">223</font>        /**<a name="line.223"></a>
<font color="green">224</font>         * Return the class of the underlying wrapped bean.<a name="line.224"></a>
<font color="green">225</font>         *<a name="line.225"></a>
<font color="green">226</font>         * @return the class of the underlying wrapped bean<a name="line.226"></a>
<font color="green">227</font>         * @since 1.8.0<a name="line.227"></a>
<font color="green">228</font>         */<a name="line.228"></a>
<font color="green">229</font>        protected Class getBeanClass() {<a name="line.229"></a>
<font color="green">230</font>            return (Class)beanClassRef.get();<a name="line.230"></a>
<font color="green">231</font>        }<a name="line.231"></a>
<font color="green">232</font>    <a name="line.232"></a>
<font color="green">233</font>        /**<a name="line.233"></a>
<font color="green">234</font>         * Return the name of this DynaClass (analogous to the<a name="line.234"></a>
<font color="green">235</font>         * &lt;code&gt;getName()&lt;/code&gt; method of &lt;code&gt;java.lang.Class&lt;/code), which<a name="line.235"></a>
<font color="green">236</font>         * allows the same &lt;code&gt;DynaClass&lt;/code&gt; implementation class to support<a name="line.236"></a>
<font color="green">237</font>         * different dynamic classes, with different sets of properties.<a name="line.237"></a>
<font color="green">238</font>         *<a name="line.238"></a>
<font color="green">239</font>         * @return the name of the DynaClass<a name="line.239"></a>
<font color="green">240</font>         */<a name="line.240"></a>
<font color="green">241</font>        public String getName() {<a name="line.241"></a>
<font color="green">242</font>    <a name="line.242"></a>
<font color="green">243</font>            return beanClassName;<a name="line.243"></a>
<font color="green">244</font>    <a name="line.244"></a>
<font color="green">245</font>        }<a name="line.245"></a>
<font color="green">246</font>    <a name="line.246"></a>
<font color="green">247</font>    <a name="line.247"></a>
<font color="green">248</font>        /**<a name="line.248"></a>
<font color="green">249</font>         * Return a property descriptor for the specified property, if it exists;<a name="line.249"></a>
<font color="green">250</font>         * otherwise, return &lt;code&gt;null&lt;/code&gt;.<a name="line.250"></a>
<font color="green">251</font>         *<a name="line.251"></a>
<font color="green">252</font>         * @param name Name of the dynamic property for which a descriptor<a name="line.252"></a>
<font color="green">253</font>         *  is requested<a name="line.253"></a>
<font color="green">254</font>         * @return The descriptor for the specified property<a name="line.254"></a>
<font color="green">255</font>         *<a name="line.255"></a>
<font color="green">256</font>         * @exception IllegalArgumentException if no property name is specified<a name="line.256"></a>
<font color="green">257</font>         */<a name="line.257"></a>
<font color="green">258</font>        public DynaProperty getDynaProperty(String name) {<a name="line.258"></a>
<font color="green">259</font>    <a name="line.259"></a>
<font color="green">260</font>            if (name == null) {<a name="line.260"></a>
<font color="green">261</font>                throw new IllegalArgumentException<a name="line.261"></a>
<font color="green">262</font>                        ("No property name specified");<a name="line.262"></a>
<font color="green">263</font>            }<a name="line.263"></a>
<font color="green">264</font>            return ((DynaProperty) propertiesMap.get(name));<a name="line.264"></a>
<font color="green">265</font>    <a name="line.265"></a>
<font color="green">266</font>        }<a name="line.266"></a>
<font color="green">267</font>    <a name="line.267"></a>
<font color="green">268</font>    <a name="line.268"></a>
<font color="green">269</font>        /**<a name="line.269"></a>
<font color="green">270</font>         * &lt;p&gt;Return an array of &lt;code&gt;ProperyDescriptors&lt;/code&gt; for the properties<a name="line.270"></a>
<font color="green">271</font>         * currently defined in this DynaClass.  If no properties are defined, a<a name="line.271"></a>
<font color="green">272</font>         * zero-length array will be returned.&lt;/p&gt;<a name="line.272"></a>
<font color="green">273</font>         *<a name="line.273"></a>
<font color="green">274</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Should we really be implementing<a name="line.274"></a>
<font color="green">275</font>         * &lt;code&gt;getBeanInfo()&lt;/code&gt; instead, which returns property descriptors<a name="line.275"></a>
<font color="green">276</font>         * and a bunch of other stuff?&lt;/p&gt;<a name="line.276"></a>
<font color="green">277</font>         *<a name="line.277"></a>
<font color="green">278</font>         * @return the set of properties for this DynaClass<a name="line.278"></a>
<font color="green">279</font>         */<a name="line.279"></a>
<font color="green">280</font>        public DynaProperty[] getDynaProperties() {<a name="line.280"></a>
<font color="green">281</font>    <a name="line.281"></a>
<font color="green">282</font>            return (properties);<a name="line.282"></a>
<font color="green">283</font>    <a name="line.283"></a>
<font color="green">284</font>        }<a name="line.284"></a>
<font color="green">285</font>    <a name="line.285"></a>
<font color="green">286</font>    <a name="line.286"></a>
<font color="green">287</font>        /**<a name="line.287"></a>
<font color="green">288</font>         * &lt;p&gt;Instantiates a new standard JavaBean instance associated with<a name="line.288"></a>
<font color="green">289</font>         * this DynaClass and return it wrapped in a new WrapDynaBean   <a name="line.289"></a>
<font color="green">290</font>         * instance. &lt;strong&gt;NOTE&lt;/strong&gt; the JavaBean should have a <a name="line.290"></a>
<font color="green">291</font>         * no argument constructor.&lt;/p&gt;<a name="line.291"></a>
<font color="green">292</font>         *<a name="line.292"></a>
<font color="green">293</font>         * &lt;strong&gt;NOTE&lt;/strong&gt; - Most common use cases should not need to use<a name="line.293"></a>
<font color="green">294</font>         * this method. It is usually better to create new<a name="line.294"></a>
<font color="green">295</font>         * &lt;code&gt;WrapDynaBean&lt;/code&gt; instances by calling its constructor.<a name="line.295"></a>
<font color="green">296</font>         * For example:&lt;/p&gt;<a name="line.296"></a>
<font color="green">297</font>         * &lt;code&gt;&lt;pre&gt;<a name="line.297"></a>
<font color="green">298</font>         *   Object javaBean = ...;<a name="line.298"></a>
<font color="green">299</font>         *   DynaBean wrapper = new WrapDynaBean(javaBean);<a name="line.299"></a>
<font color="green">300</font>         * &lt;/pre&gt;&lt;/code&gt;<a name="line.300"></a>
<font color="green">301</font>         * &lt;p&gt;<a name="line.301"></a>
<font color="green">302</font>         * (This method is needed for some kinds of &lt;code&gt;DynaBean&lt;/code&gt; framework.)<a name="line.302"></a>
<font color="green">303</font>         * &lt;/p&gt;<a name="line.303"></a>
<font color="green">304</font>         *<a name="line.304"></a>
<font color="green">305</font>         * @return A new &lt;code&gt;DynaBean&lt;/code&gt; instance<a name="line.305"></a>
<font color="green">306</font>         * @exception IllegalAccessException if the Class or the appropriate<a name="line.306"></a>
<font color="green">307</font>         *  constructor is not accessible<a name="line.307"></a>
<font color="green">308</font>         * @exception InstantiationException if this Class represents an abstract<a name="line.308"></a>
<font color="green">309</font>         *  class, an array class, a primitive type, or void; or if instantiation<a name="line.309"></a>
<font color="green">310</font>         *  fails for some other reason<a name="line.310"></a>
<font color="green">311</font>         */<a name="line.311"></a>
<font color="green">312</font>        public DynaBean newInstance()<a name="line.312"></a>
<font color="green">313</font>                throws IllegalAccessException, InstantiationException {<a name="line.313"></a>
<font color="green">314</font>    <a name="line.314"></a>
<font color="green">315</font>            return new WrapDynaBean(getBeanClass().newInstance());<a name="line.315"></a>
<font color="green">316</font>    <a name="line.316"></a>
<font color="green">317</font>        }<a name="line.317"></a>
<font color="green">318</font>    <a name="line.318"></a>
<font color="green">319</font>    <a name="line.319"></a>
<font color="green">320</font>        // --------------------------------------------------------- Public Methods<a name="line.320"></a>
<font color="green">321</font>    <a name="line.321"></a>
<font color="green">322</font>    <a name="line.322"></a>
<font color="green">323</font>        /**<a name="line.323"></a>
<font color="green">324</font>         * Return the PropertyDescriptor for the specified property name, if any;<a name="line.324"></a>
<font color="green">325</font>         * otherwise return &lt;code&gt;null&lt;/code&gt;.<a name="line.325"></a>
<font color="green">326</font>         *<a name="line.326"></a>
<font color="green">327</font>         * @param name Name of the property to be retrieved<a name="line.327"></a>
<font color="green">328</font>         * @return The descriptor for the specified property<a name="line.328"></a>
<font color="green">329</font>         */<a name="line.329"></a>
<font color="green">330</font>        public PropertyDescriptor getPropertyDescriptor(String name) {<a name="line.330"></a>
<font color="green">331</font>    <a name="line.331"></a>
<font color="green">332</font>            return ((PropertyDescriptor) descriptorsMap.get(name));<a name="line.332"></a>
<font color="green">333</font>    <a name="line.333"></a>
<font color="green">334</font>        }<a name="line.334"></a>
<font color="green">335</font>    <a name="line.335"></a>
<font color="green">336</font>    <a name="line.336"></a>
<font color="green">337</font>        // --------------------------------------------------------- Static Methods<a name="line.337"></a>
<font color="green">338</font>    <a name="line.338"></a>
<font color="green">339</font>    <a name="line.339"></a>
<font color="green">340</font>        /**<a name="line.340"></a>
<font color="green">341</font>         * Clear our cache of WrapDynaClass instances.<a name="line.341"></a>
<font color="green">342</font>         */<a name="line.342"></a>
<font color="green">343</font>        public static void clear() {<a name="line.343"></a>
<font color="green">344</font>    <a name="line.344"></a>
<font color="green">345</font>            getDynaClassesMap().clear();<a name="line.345"></a>
<font color="green">346</font>    <a name="line.346"></a>
<font color="green">347</font>        }<a name="line.347"></a>
<font color="green">348</font>    <a name="line.348"></a>
<font color="green">349</font>    <a name="line.349"></a>
<font color="green">350</font>        /**<a name="line.350"></a>
<font color="green">351</font>         * Create (if necessary) and return a new &lt;code&gt;WrapDynaClass&lt;/code&gt;<a name="line.351"></a>
<font color="green">352</font>         * instance for the specified bean class.<a name="line.352"></a>
<font color="green">353</font>         *<a name="line.353"></a>
<font color="green">354</font>         * @param beanClass Bean class for which a WrapDynaClass is requested<a name="line.354"></a>
<font color="green">355</font>         * @return A new &lt;i&gt;Wrap&lt;/i&gt; {@link DynaClass}<a name="line.355"></a>
<font color="green">356</font>         */<a name="line.356"></a>
<font color="green">357</font>        public static WrapDynaClass createDynaClass(Class beanClass) {<a name="line.357"></a>
<font color="green">358</font>    <a name="line.358"></a>
<font color="green">359</font>                WrapDynaClass dynaClass =<a name="line.359"></a>
<font color="green">360</font>                        (WrapDynaClass) getDynaClassesMap().get(beanClass);<a name="line.360"></a>
<font color="green">361</font>                if (dynaClass == null) {<a name="line.361"></a>
<font color="green">362</font>                    dynaClass = new WrapDynaClass(beanClass);<a name="line.362"></a>
<font color="green">363</font>                    getDynaClassesMap().put(beanClass, dynaClass);<a name="line.363"></a>
<font color="green">364</font>                }<a name="line.364"></a>
<font color="green">365</font>                return (dynaClass);<a name="line.365"></a>
<font color="green">366</font>    <a name="line.366"></a>
<font color="green">367</font>        }<a name="line.367"></a>
<font color="green">368</font>    <a name="line.368"></a>
<font color="green">369</font>    <a name="line.369"></a>
<font color="green">370</font>        // ------------------------------------------------------ Protected Methods<a name="line.370"></a>
<font color="green">371</font>    <a name="line.371"></a>
<font color="green">372</font>    <a name="line.372"></a>
<font color="green">373</font>        /**<a name="line.373"></a>
<font color="green">374</font>         * Introspect our bean class to identify the supported properties.<a name="line.374"></a>
<font color="green">375</font>         */<a name="line.375"></a>
<font color="green">376</font>        protected void introspect() {<a name="line.376"></a>
<font color="green">377</font>    <a name="line.377"></a>
<font color="green">378</font>            // Look up the property descriptors for this bean class<a name="line.378"></a>
<font color="green">379</font>            Class beanClass = getBeanClass();<a name="line.379"></a>
<font color="green">380</font>            PropertyDescriptor[] regulars =<a name="line.380"></a>
<font color="green">381</font>                    PropertyUtils.getPropertyDescriptors(beanClass);<a name="line.381"></a>
<font color="green">382</font>            if (regulars == null) {<a name="line.382"></a>
<font color="green">383</font>                regulars = new PropertyDescriptor[0];<a name="line.383"></a>
<font color="green">384</font>            }<a name="line.384"></a>
<font color="green">385</font>            Map mappeds =<a name="line.385"></a>
<font color="green">386</font>                    PropertyUtils.getMappedPropertyDescriptors(beanClass);<a name="line.386"></a>
<font color="green">387</font>            if (mappeds == null) {<a name="line.387"></a>
<font color="green">388</font>                mappeds = new HashMap();<a name="line.388"></a>
<font color="green">389</font>            }<a name="line.389"></a>
<font color="green">390</font>    <a name="line.390"></a>
<font color="green">391</font>            // Construct corresponding DynaProperty information<a name="line.391"></a>
<font color="green">392</font>            properties = new DynaProperty[regulars.length + mappeds.size()];<a name="line.392"></a>
<font color="green">393</font>            for (int i = 0; i &lt; regulars.length; i++) {<a name="line.393"></a>
<font color="green">394</font>                descriptorsMap.put(regulars[i].getName(),<a name="line.394"></a>
<font color="green">395</font>                        regulars[i]);<a name="line.395"></a>
<font color="green">396</font>                properties[i] =<a name="line.396"></a>
<font color="green">397</font>                        new DynaProperty(regulars[i].getName(),<a name="line.397"></a>
<font color="green">398</font>                                regulars[i].getPropertyType());<a name="line.398"></a>
<font color="green">399</font>                propertiesMap.put(properties[i].getName(),<a name="line.399"></a>
<font color="green">400</font>                        properties[i]);<a name="line.400"></a>
<font color="green">401</font>            }<a name="line.401"></a>
<font color="green">402</font>            int j = regulars.length;<a name="line.402"></a>
<font color="green">403</font>            Iterator names = mappeds.keySet().iterator();<a name="line.403"></a>
<font color="green">404</font>            while (names.hasNext()) {<a name="line.404"></a>
<font color="green">405</font>                String name = (String) names.next();<a name="line.405"></a>
<font color="green">406</font>                PropertyDescriptor descriptor =<a name="line.406"></a>
<font color="green">407</font>                        (PropertyDescriptor) mappeds.get(name);<a name="line.407"></a>
<font color="green">408</font>                properties[j] =<a name="line.408"></a>
<font color="green">409</font>                        new DynaProperty(descriptor.getName(),<a name="line.409"></a>
<font color="green">410</font>                                Map.class);<a name="line.410"></a>
<font color="green">411</font>                propertiesMap.put(properties[j].getName(),<a name="line.411"></a>
<font color="green">412</font>                        properties[j]);<a name="line.412"></a>
<font color="green">413</font>                j++;<a name="line.413"></a>
<font color="green">414</font>            }<a name="line.414"></a>
<font color="green">415</font>    <a name="line.415"></a>
<font color="green">416</font>        }<a name="line.416"></a>
<font color="green">417</font>    <a name="line.417"></a>
<font color="green">418</font>    <a name="line.418"></a>
<font color="green">419</font>    }<a name="line.419"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/WrapDynaBean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/WrapDynaBean/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:13:59" itemprop="dateModified" datetime="2010-03-24T17:13:59+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>    <a name="line.17"></a>
<font color="green">018</font>    <a name="line.18"></a>
<font color="green">019</font>    package org.apache.commons.beanutils;<a name="line.19"></a>
<font color="green">020</font>    <a name="line.20"></a>
<font color="green">021</font>    import java.io.Serializable;<a name="line.21"></a>
<font color="green">022</font>    import java.lang.reflect.InvocationTargetException;<a name="line.22"></a>
<font color="green">023</font>    <a name="line.23"></a>
<font color="green">024</font>    <a name="line.24"></a>
<font color="green">025</font>    /**<a name="line.25"></a>
<font color="green">026</font>     * &lt;p&gt;Implementation of &lt;code&gt;DynaBean&lt;/code&gt; that wraps a standard JavaBean<a name="line.26"></a>
<font color="green">027</font>     * instance, so that DynaBean APIs can be used to access its properties.&lt;/p&gt;<a name="line.27"></a>
<font color="green">028</font>     *<a name="line.28"></a>
<font color="green">029</font>     * &lt;p&gt;<a name="line.29"></a>
<font color="green">030</font>     * The most common use cases for this class involve wrapping an existing java bean.<a name="line.30"></a>
<font color="green">031</font>     * (This makes it different from the typical use cases for other &lt;code&gt;DynaBean&lt;/code&gt;'s.) <a name="line.31"></a>
<font color="green">032</font>     * For example:<a name="line.32"></a>
<font color="green">033</font>     * &lt;/p&gt;<a name="line.33"></a>
<font color="green">034</font>     * &lt;code&gt;&lt;pre&gt;<a name="line.34"></a>
<font color="green">035</font>     *  Object aJavaBean = ...;<a name="line.35"></a>
<font color="green">036</font>     *  ...<a name="line.36"></a>
<font color="green">037</font>     *  DynaBean db = new WrapDynaBean(aJavaBean);<a name="line.37"></a>
<font color="green">038</font>     *  ...<a name="line.38"></a>
<font color="green">039</font>     * &lt;/pre&gt;&lt;/code&gt;<a name="line.39"></a>
<font color="green">040</font>     *<a name="line.40"></a>
<font color="green">041</font>     * &lt;p&gt;&lt;strong&gt;IMPLEMENTATION NOTE&lt;/strong&gt; - This implementation does not<a name="line.41"></a>
<font color="green">042</font>     * support the &lt;code&gt;contains()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt; methods.&lt;/p&gt;<a name="line.42"></a>
<font color="green">043</font>     *<a name="line.43"></a>
<font color="green">044</font>     * @author Craig McClanahan<a name="line.44"></a>
<font color="green">045</font>     * @version $Revision: 926529 $ $Date: 2010-03-23 11:44:24 +0000 (Tue, 23 Mar 2010) $<a name="line.45"></a>
<font color="green">046</font>     */<a name="line.46"></a>
<font color="green">047</font>    <a name="line.47"></a>
<font color="green">048</font>    public class WrapDynaBean implements DynaBean, Serializable {<a name="line.48"></a>
<font color="green">049</font>    <a name="line.49"></a>
<font color="green">050</font>    <a name="line.50"></a>
<font color="green">051</font>        // ---------------------------------------------------------- Constructors<a name="line.51"></a>
<font color="green">052</font>    <a name="line.52"></a>
<font color="green">053</font>    <a name="line.53"></a>
<font color="green">054</font>        /**<a name="line.54"></a>
<font color="green">055</font>         * Construct a new &lt;code&gt;DynaBean&lt;/code&gt; associated with the specified<a name="line.55"></a>
<font color="green">056</font>         * JavaBean instance.<a name="line.56"></a>
<font color="green">057</font>         *<a name="line.57"></a>
<font color="green">058</font>         * @param instance JavaBean instance to be wrapped<a name="line.58"></a>
<font color="green">059</font>         */<a name="line.59"></a>
<font color="green">060</font>        public WrapDynaBean(Object instance) {<a name="line.60"></a>
<font color="green">061</font>    <a name="line.61"></a>
<font color="green">062</font>            super();<a name="line.62"></a>
<font color="green">063</font>            this.instance = instance;<a name="line.63"></a>
<font color="green">064</font>            this.dynaClass = (WrapDynaClass)getDynaClass();<a name="line.64"></a>
<font color="green">065</font>    <a name="line.65"></a>
<font color="green">066</font>        }<a name="line.66"></a>
<font color="green">067</font>    <a name="line.67"></a>
<font color="green">068</font>    <a name="line.68"></a>
<font color="green">069</font>        // ---------------------------------------------------- Instance Variables<a name="line.69"></a>
<font color="green">070</font>    <a name="line.70"></a>
<font color="green">071</font>    <a name="line.71"></a>
<font color="green">072</font>        /**<a name="line.72"></a>
<font color="green">073</font>         * The &lt;code&gt;DynaClass&lt;/code&gt; "base class" that this DynaBean<a name="line.73"></a>
<font color="green">074</font>         * is associated with.<a name="line.74"></a>
<font color="green">075</font>         */<a name="line.75"></a>
<font color="green">076</font>        protected transient WrapDynaClass dynaClass = null;<a name="line.76"></a>
<font color="green">077</font>    <a name="line.77"></a>
<font color="green">078</font>    <a name="line.78"></a>
<font color="green">079</font>        /**<a name="line.79"></a>
<font color="green">080</font>         * The JavaBean instance wrapped by this WrapDynaBean.<a name="line.80"></a>
<font color="green">081</font>         */<a name="line.81"></a>
<font color="green">082</font>        protected Object instance = null;<a name="line.82"></a>
<font color="green">083</font>    <a name="line.83"></a>
<font color="green">084</font>    <a name="line.84"></a>
<font color="green">085</font>        // ------------------------------------------------------ DynaBean Methods<a name="line.85"></a>
<font color="green">086</font>    <a name="line.86"></a>
<font color="green">087</font>    <a name="line.87"></a>
<font color="green">088</font>        /**<a name="line.88"></a>
<font color="green">089</font>         * Does the specified mapped property contain a value for the specified<a name="line.89"></a>
<font color="green">090</font>         * key value?<a name="line.90"></a>
<font color="green">091</font>         *<a name="line.91"></a>
<font color="green">092</font>         * @param name Name of the property to check<a name="line.92"></a>
<font color="green">093</font>         * @param key Name of the key to check<a name="line.93"></a>
<font color="green">094</font>         * @return &lt;code&gt;true&lt;code&gt; if the mapped property contains a value for<a name="line.94"></a>
<font color="green">095</font>         * the specified key, otherwise &lt;code&gt;false&lt;/code&gt;<a name="line.95"></a>
<font color="green">096</font>         *<a name="line.96"></a>
<font color="green">097</font>         * @exception IllegalArgumentException if there is no property<a name="line.97"></a>
<font color="green">098</font>         *  of the specified name<a name="line.98"></a>
<font color="green">099</font>         */<a name="line.99"></a>
<font color="green">100</font>        public boolean contains(String name, String key) {<a name="line.100"></a>
<font color="green">101</font>    <a name="line.101"></a>
<font color="green">102</font>            throw new UnsupportedOperationException<a name="line.102"></a>
<font color="green">103</font>                    ("WrapDynaBean does not support contains()");<a name="line.103"></a>
<font color="green">104</font>    <a name="line.104"></a>
<font color="green">105</font>        }<a name="line.105"></a>
<font color="green">106</font>    <a name="line.106"></a>
<font color="green">107</font>    <a name="line.107"></a>
<font color="green">108</font>        /**<a name="line.108"></a>
<font color="green">109</font>         * Return the value of a simple property with the specified name.<a name="line.109"></a>
<font color="green">110</font>         *<a name="line.110"></a>
<font color="green">111</font>         * @param name Name of the property whose value is to be retrieved<a name="line.111"></a>
<font color="green">112</font>         * @return The property's value<a name="line.112"></a>
<font color="green">113</font>         *<a name="line.113"></a>
<font color="green">114</font>         * @exception IllegalArgumentException if there is no property<a name="line.114"></a>
<font color="green">115</font>         *  of the specified name<a name="line.115"></a>
<font color="green">116</font>         */<a name="line.116"></a>
<font color="green">117</font>        public Object get(String name) {<a name="line.117"></a>
<font color="green">118</font>    <a name="line.118"></a>
<font color="green">119</font>            Object value = null;<a name="line.119"></a>
<font color="green">120</font>            try {<a name="line.120"></a>
<font color="green">121</font>                value = PropertyUtils.getSimpleProperty(instance, name);<a name="line.121"></a>
<font color="green">122</font>            } catch (InvocationTargetException ite) {<a name="line.122"></a>
<font color="green">123</font>                Throwable cause = ite.getTargetException();<a name="line.123"></a>
<font color="green">124</font>                throw new IllegalArgumentException<a name="line.124"></a>
<font color="green">125</font>                        ("Error reading property '" + name +<a name="line.125"></a>
<font color="green">126</font>                                  "' nested exception - " + cause);<a name="line.126"></a>
<font color="green">127</font>            } catch (Throwable t) {<a name="line.127"></a>
<font color="green">128</font>                throw new IllegalArgumentException<a name="line.128"></a>
<font color="green">129</font>                        ("Error reading property '" + name +<a name="line.129"></a>
<font color="green">130</font>                                  "', exception - " + t);<a name="line.130"></a>
<font color="green">131</font>            }<a name="line.131"></a>
<font color="green">132</font>            return (value);<a name="line.132"></a>
<font color="green">133</font>    <a name="line.133"></a>
<font color="green">134</font>        }<a name="line.134"></a>
<font color="green">135</font>    <a name="line.135"></a>
<font color="green">136</font>    <a name="line.136"></a>
<font color="green">137</font>        /**<a name="line.137"></a>
<font color="green">138</font>         * Return the value of an indexed property with the specified name.<a name="line.138"></a>
<font color="green">139</font>         *<a name="line.139"></a>
<font color="green">140</font>         * @param name Name of the property whose value is to be retrieved<a name="line.140"></a>
<font color="green">141</font>         * @param index Index of the value to be retrieved<a name="line.141"></a>
<font color="green">142</font>         * @return The indexed property's value<a name="line.142"></a>
<font color="green">143</font>         *<a name="line.143"></a>
<font color="green">144</font>         * @exception IllegalArgumentException if there is no property<a name="line.144"></a>
<font color="green">145</font>         *  of the specified name<a name="line.145"></a>
<font color="green">146</font>         * @exception IllegalArgumentException if the specified property<a name="line.146"></a>
<font color="green">147</font>         *  exists, but is not indexed<a name="line.147"></a>
<font color="green">148</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.148"></a>
<font color="green">149</font>         *  is outside the range of the underlying property<a name="line.149"></a>
<font color="green">150</font>         * @exception NullPointerException if no array or List has been<a name="line.150"></a>
<font color="green">151</font>         *  initialized for this property<a name="line.151"></a>
<font color="green">152</font>         */<a name="line.152"></a>
<font color="green">153</font>        public Object get(String name, int index) {<a name="line.153"></a>
<font color="green">154</font>    <a name="line.154"></a>
<font color="green">155</font>            Object value = null;<a name="line.155"></a>
<font color="green">156</font>            try {<a name="line.156"></a>
<font color="green">157</font>                value = PropertyUtils.getIndexedProperty(instance, name, index);<a name="line.157"></a>
<font color="green">158</font>            } catch (IndexOutOfBoundsException e) {<a name="line.158"></a>
<font color="green">159</font>                throw e;<a name="line.159"></a>
<font color="green">160</font>            } catch (InvocationTargetException ite) {<a name="line.160"></a>
<font color="green">161</font>                Throwable cause = ite.getTargetException();<a name="line.161"></a>
<font color="green">162</font>                throw new IllegalArgumentException<a name="line.162"></a>
<font color="green">163</font>                        ("Error reading indexed property '" + name +<a name="line.163"></a>
<font color="green">164</font>                                  "' nested exception - " + cause);<a name="line.164"></a>
<font color="green">165</font>            } catch (Throwable t) {<a name="line.165"></a>
<font color="green">166</font>                throw new IllegalArgumentException<a name="line.166"></a>
<font color="green">167</font>                        ("Error reading indexed property '" + name +<a name="line.167"></a>
<font color="green">168</font>                                  "', exception - " + t);<a name="line.168"></a>
<font color="green">169</font>            }<a name="line.169"></a>
<font color="green">170</font>            return (value);<a name="line.170"></a>
<font color="green">171</font>    <a name="line.171"></a>
<font color="green">172</font>        }<a name="line.172"></a>
<font color="green">173</font>    <a name="line.173"></a>
<font color="green">174</font>    <a name="line.174"></a>
<font color="green">175</font>        /**<a name="line.175"></a>
<font color="green">176</font>         * Return the value of a mapped property with the specified name,<a name="line.176"></a>
<font color="green">177</font>         * or &lt;code&gt;null&lt;/code&gt; if there is no value for the specified key.<a name="line.177"></a>
<font color="green">178</font>         *<a name="line.178"></a>
<font color="green">179</font>         * @param name Name of the property whose value is to be retrieved<a name="line.179"></a>
<font color="green">180</font>         * @param key Key of the value to be retrieved<a name="line.180"></a>
<font color="green">181</font>         * @return The mapped property's value<a name="line.181"></a>
<font color="green">182</font>         *<a name="line.182"></a>
<font color="green">183</font>         * @exception IllegalArgumentException if there is no property<a name="line.183"></a>
<font color="green">184</font>         *  of the specified name<a name="line.184"></a>
<font color="green">185</font>         * @exception IllegalArgumentException if the specified property<a name="line.185"></a>
<font color="green">186</font>         *  exists, but is not mapped<a name="line.186"></a>
<font color="green">187</font>         */<a name="line.187"></a>
<font color="green">188</font>        public Object get(String name, String key) {<a name="line.188"></a>
<font color="green">189</font>    <a name="line.189"></a>
<font color="green">190</font>            Object value = null;<a name="line.190"></a>
<font color="green">191</font>            try {<a name="line.191"></a>
<font color="green">192</font>                value = PropertyUtils.getMappedProperty(instance, name, key);<a name="line.192"></a>
<font color="green">193</font>            } catch (InvocationTargetException ite) {<a name="line.193"></a>
<font color="green">194</font>                Throwable cause = ite.getTargetException();<a name="line.194"></a>
<font color="green">195</font>                throw new IllegalArgumentException<a name="line.195"></a>
<font color="green">196</font>                        ("Error reading mapped property '" + name +<a name="line.196"></a>
<font color="green">197</font>                                  "' nested exception - " + cause);<a name="line.197"></a>
<font color="green">198</font>            } catch (Throwable t) {<a name="line.198"></a>
<font color="green">199</font>                throw new IllegalArgumentException<a name="line.199"></a>
<font color="green">200</font>                        ("Error reading mapped property '" + name +<a name="line.200"></a>
<font color="green">201</font>                                  "', exception - " + t);<a name="line.201"></a>
<font color="green">202</font>            }<a name="line.202"></a>
<font color="green">203</font>            return (value);<a name="line.203"></a>
<font color="green">204</font>    <a name="line.204"></a>
<font color="green">205</font>        }<a name="line.205"></a>
<font color="green">206</font>    <a name="line.206"></a>
<font color="green">207</font>    <a name="line.207"></a>
<font color="green">208</font>        /**<a name="line.208"></a>
<font color="green">209</font>         * Return the &lt;code&gt;DynaClass&lt;/code&gt; instance that describes the set of<a name="line.209"></a>
<font color="green">210</font>         * properties available for this DynaBean.<a name="line.210"></a>
<font color="green">211</font>         * @return The associated DynaClass<a name="line.211"></a>
<font color="green">212</font>         */<a name="line.212"></a>
<font color="green">213</font>        public DynaClass getDynaClass() {<a name="line.213"></a>
<font color="green">214</font>    <a name="line.214"></a>
<font color="green">215</font>            if (dynaClass == null) {<a name="line.215"></a>
<font color="green">216</font>                dynaClass = WrapDynaClass.createDynaClass(instance.getClass());<a name="line.216"></a>
<font color="green">217</font>            }<a name="line.217"></a>
<font color="green">218</font>    <a name="line.218"></a>
<font color="green">219</font>            return (this.dynaClass);<a name="line.219"></a>
<font color="green">220</font>    <a name="line.220"></a>
<font color="green">221</font>        }<a name="line.221"></a>
<font color="green">222</font>    <a name="line.222"></a>
<font color="green">223</font>    <a name="line.223"></a>
<font color="green">224</font>        /**<a name="line.224"></a>
<font color="green">225</font>         * Remove any existing value for the specified key on the<a name="line.225"></a>
<font color="green">226</font>         * specified mapped property.<a name="line.226"></a>
<font color="green">227</font>         *<a name="line.227"></a>
<font color="green">228</font>         * @param name Name of the property for which a value is to<a name="line.228"></a>
<font color="green">229</font>         *  be removed<a name="line.229"></a>
<font color="green">230</font>         * @param key Key of the value to be removed<a name="line.230"></a>
<font color="green">231</font>         *<a name="line.231"></a>
<font color="green">232</font>         * @exception IllegalArgumentException if there is no property<a name="line.232"></a>
<font color="green">233</font>         *  of the specified name<a name="line.233"></a>
<font color="green">234</font>         */<a name="line.234"></a>
<font color="green">235</font>        public void remove(String name, String key) {<a name="line.235"></a>
<font color="green">236</font>    <a name="line.236"></a>
<font color="green">237</font>    <a name="line.237"></a>
<font color="green">238</font>            throw new UnsupportedOperationException<a name="line.238"></a>
<font color="green">239</font>                    ("WrapDynaBean does not support remove()");<a name="line.239"></a>
<font color="green">240</font>    <a name="line.240"></a>
<font color="green">241</font>        }<a name="line.241"></a>
<font color="green">242</font>    <a name="line.242"></a>
<font color="green">243</font>    <a name="line.243"></a>
<font color="green">244</font>        /**<a name="line.244"></a>
<font color="green">245</font>         * Set the value of a simple property with the specified name.<a name="line.245"></a>
<font color="green">246</font>         *<a name="line.246"></a>
<font color="green">247</font>         * @param name Name of the property whose value is to be set<a name="line.247"></a>
<font color="green">248</font>         * @param value Value to which this property is to be set<a name="line.248"></a>
<font color="green">249</font>         *<a name="line.249"></a>
<font color="green">250</font>         * @exception ConversionException if the specified value cannot be<a name="line.250"></a>
<font color="green">251</font>         *  converted to the type required for this property<a name="line.251"></a>
<font color="green">252</font>         * @exception IllegalArgumentException if there is no property<a name="line.252"></a>
<font color="green">253</font>         *  of the specified name<a name="line.253"></a>
<font color="green">254</font>         * @exception NullPointerException if an attempt is made to set a<a name="line.254"></a>
<font color="green">255</font>         *  primitive property to null<a name="line.255"></a>
<font color="green">256</font>         */<a name="line.256"></a>
<font color="green">257</font>        public void set(String name, Object value) {<a name="line.257"></a>
<font color="green">258</font>    <a name="line.258"></a>
<font color="green">259</font>            try {<a name="line.259"></a>
<font color="green">260</font>                PropertyUtils.setSimpleProperty(instance, name, value);<a name="line.260"></a>
<font color="green">261</font>            } catch (InvocationTargetException ite) {<a name="line.261"></a>
<font color="green">262</font>                Throwable cause = ite.getTargetException();<a name="line.262"></a>
<font color="green">263</font>                throw new IllegalArgumentException<a name="line.263"></a>
<font color="green">264</font>                        ("Error setting property '" + name +<a name="line.264"></a>
<font color="green">265</font>                                  "' nested exception -" + cause);<a name="line.265"></a>
<font color="green">266</font>            } catch (Throwable t) {<a name="line.266"></a>
<font color="green">267</font>                throw new IllegalArgumentException<a name="line.267"></a>
<font color="green">268</font>                        ("Error setting property '" + name +<a name="line.268"></a>
<font color="green">269</font>                                  "', exception - " + t);<a name="line.269"></a>
<font color="green">270</font>            }<a name="line.270"></a>
<font color="green">271</font>    <a name="line.271"></a>
<font color="green">272</font>        }<a name="line.272"></a>
<font color="green">273</font>    <a name="line.273"></a>
<font color="green">274</font>    <a name="line.274"></a>
<font color="green">275</font>        /**<a name="line.275"></a>
<font color="green">276</font>         * Set the value of an indexed property with the specified name.<a name="line.276"></a>
<font color="green">277</font>         *<a name="line.277"></a>
<font color="green">278</font>         * @param name Name of the property whose value is to be set<a name="line.278"></a>
<font color="green">279</font>         * @param index Index of the property to be set<a name="line.279"></a>
<font color="green">280</font>         * @param value Value to which this property is to be set<a name="line.280"></a>
<font color="green">281</font>         *<a name="line.281"></a>
<font color="green">282</font>         * @exception ConversionException if the specified value cannot be<a name="line.282"></a>
<font color="green">283</font>         *  converted to the type required for this property<a name="line.283"></a>
<font color="green">284</font>         * @exception IllegalArgumentException if there is no property<a name="line.284"></a>
<font color="green">285</font>         *  of the specified name<a name="line.285"></a>
<font color="green">286</font>         * @exception IllegalArgumentException if the specified property<a name="line.286"></a>
<font color="green">287</font>         *  exists, but is not indexed<a name="line.287"></a>
<font color="green">288</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.288"></a>
<font color="green">289</font>         *  is outside the range of the underlying property<a name="line.289"></a>
<font color="green">290</font>         */<a name="line.290"></a>
<font color="green">291</font>        public void set(String name, int index, Object value) {<a name="line.291"></a>
<font color="green">292</font>    <a name="line.292"></a>
<font color="green">293</font>            try {<a name="line.293"></a>
<font color="green">294</font>                PropertyUtils.setIndexedProperty(instance, name, index, value);<a name="line.294"></a>
<font color="green">295</font>            } catch (IndexOutOfBoundsException e) {<a name="line.295"></a>
<font color="green">296</font>                throw e;<a name="line.296"></a>
<font color="green">297</font>            } catch (InvocationTargetException ite) {<a name="line.297"></a>
<font color="green">298</font>                Throwable cause = ite.getTargetException();<a name="line.298"></a>
<font color="green">299</font>                throw new IllegalArgumentException<a name="line.299"></a>
<font color="green">300</font>                        ("Error setting indexed property '" + name +<a name="line.300"></a>
<font color="green">301</font>                                  "' nested exception - " + cause);<a name="line.301"></a>
<font color="green">302</font>            } catch (Throwable t) {<a name="line.302"></a>
<font color="green">303</font>                throw new IllegalArgumentException<a name="line.303"></a>
<font color="green">304</font>                        ("Error setting indexed property '" + name +<a name="line.304"></a>
<font color="green">305</font>                                  "', exception - " + t);<a name="line.305"></a>
<font color="green">306</font>            }<a name="line.306"></a>
<font color="green">307</font>    <a name="line.307"></a>
<font color="green">308</font>        }<a name="line.308"></a>
<font color="green">309</font>    <a name="line.309"></a>
<font color="green">310</font>    <a name="line.310"></a>
<font color="green">311</font>        /**<a name="line.311"></a>
<font color="green">312</font>         * Set the value of a mapped property with the specified name.<a name="line.312"></a>
<font color="green">313</font>         *<a name="line.313"></a>
<font color="green">314</font>         * @param name Name of the property whose value is to be set<a name="line.314"></a>
<font color="green">315</font>         * @param key Key of the property to be set<a name="line.315"></a>
<font color="green">316</font>         * @param value Value to which this property is to be set<a name="line.316"></a>
<font color="green">317</font>         *<a name="line.317"></a>
<font color="green">318</font>         * @exception ConversionException if the specified value cannot be<a name="line.318"></a>
<font color="green">319</font>         *  converted to the type required for this property<a name="line.319"></a>
<font color="green">320</font>         * @exception IllegalArgumentException if there is no property<a name="line.320"></a>
<font color="green">321</font>         *  of the specified name<a name="line.321"></a>
<font color="green">322</font>         * @exception IllegalArgumentException if the specified property<a name="line.322"></a>
<font color="green">323</font>         *  exists, but is not mapped<a name="line.323"></a>
<font color="green">324</font>         */<a name="line.324"></a>
<font color="green">325</font>        public void set(String name, String key, Object value) {<a name="line.325"></a>
<font color="green">326</font>    <a name="line.326"></a>
<font color="green">327</font>            try {<a name="line.327"></a>
<font color="green">328</font>                PropertyUtils.setMappedProperty(instance, name, key, value);<a name="line.328"></a>
<font color="green">329</font>            } catch (InvocationTargetException ite) {<a name="line.329"></a>
<font color="green">330</font>                Throwable cause = ite.getTargetException();<a name="line.330"></a>
<font color="green">331</font>                throw new IllegalArgumentException<a name="line.331"></a>
<font color="green">332</font>                        ("Error setting mapped property '" + name +<a name="line.332"></a>
<font color="green">333</font>                                  "' nested exception - " + cause);<a name="line.333"></a>
<font color="green">334</font>            } catch (Throwable t) {<a name="line.334"></a>
<font color="green">335</font>                throw new IllegalArgumentException<a name="line.335"></a>
<font color="green">336</font>                        ("Error setting mapped property '" + name +<a name="line.336"></a>
<font color="green">337</font>                                  "', exception - " + t);<a name="line.337"></a>
<font color="green">338</font>            }<a name="line.338"></a>
<font color="green">339</font>    <a name="line.339"></a>
<font color="green">340</font>        }<a name="line.340"></a>
<font color="green">341</font>    <a name="line.341"></a>
<font color="green">342</font>        /** <a name="line.342"></a>
<font color="green">343</font>         * Gets the bean instance wrapped by this DynaBean.<a name="line.343"></a>
<font color="green">344</font>         * For most common use cases, <a name="line.344"></a>
<font color="green">345</font>         * this object should already be known <a name="line.345"></a>
<font color="green">346</font>         * and this method safely be ignored.<a name="line.346"></a>
<font color="green">347</font>         * But some creators of frameworks using &lt;code&gt;DynaBean&lt;/code&gt;'s may <a name="line.347"></a>
<font color="green">348</font>         * find this useful.<a name="line.348"></a>
<font color="green">349</font>         *<a name="line.349"></a>
<font color="green">350</font>         * @return the java bean Object wrapped by this &lt;code&gt;DynaBean&lt;/code&gt;<a name="line.350"></a>
<font color="green">351</font>         */<a name="line.351"></a>
<font color="green">352</font>        public Object getInstance() {<a name="line.352"></a>
<font color="green">353</font>            return instance;<a name="line.353"></a>
<font color="green">354</font>        }<a name="line.354"></a>
<font color="green">355</font>    <a name="line.355"></a>
<font color="green">356</font>    <a name="line.356"></a>
<font color="green">357</font>        // ------------------------------------------------------ Protected Methods<a name="line.357"></a>
<font color="green">358</font>    <a name="line.358"></a>
<font color="green">359</font>    <a name="line.359"></a>
<font color="green">360</font>        /**<a name="line.360"></a>
<font color="green">361</font>         * Return the property descriptor for the specified property name.<a name="line.361"></a>
<font color="green">362</font>         *<a name="line.362"></a>
<font color="green">363</font>         * @param name Name of the property for which to retrieve the descriptor<a name="line.363"></a>
<font color="green">364</font>         * @return The descriptor for the specified property<a name="line.364"></a>
<font color="green">365</font>         *<a name="line.365"></a>
<font color="green">366</font>         * @exception IllegalArgumentException if this is not a valid property<a name="line.366"></a>
<font color="green">367</font>         *  name for our DynaClass<a name="line.367"></a>
<font color="green">368</font>         */<a name="line.368"></a>
<font color="green">369</font>        protected DynaProperty getDynaProperty(String name) {<a name="line.369"></a>
<font color="green">370</font>    <a name="line.370"></a>
<font color="green">371</font>            DynaProperty descriptor = getDynaClass().getDynaProperty(name);<a name="line.371"></a>
<font color="green">372</font>            if (descriptor == null) {<a name="line.372"></a>
<font color="green">373</font>                throw new IllegalArgumentException<a name="line.373"></a>
<font color="green">374</font>                        ("Invalid property name '" + name + "'");<a name="line.374"></a>
<font color="green">375</font>            }<a name="line.375"></a>
<font color="green">376</font>            return (descriptor);<a name="line.376"></a>
<font color="green">377</font>    <a name="line.377"></a>
<font color="green">378</font>        }<a name="line.378"></a>
<font color="green">379</font>    <a name="line.379"></a>
<font color="green">380</font>    <a name="line.380"></a>
<font color="green">381</font>    }<a name="line.381"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/RowSetDynaClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/RowSetDynaClass/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:14:01" itemprop="dateModified" datetime="2010-03-24T17:14:01+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>    <a name="line.17"></a>
<font color="green">018</font>    <a name="line.18"></a>
<font color="green">019</font>    package org.apache.commons.beanutils;<a name="line.19"></a>
<font color="green">020</font>    <a name="line.20"></a>
<font color="green">021</font>    <a name="line.21"></a>
<font color="green">022</font>    import java.io.Serializable;<a name="line.22"></a>
<font color="green">023</font>    import java.sql.ResultSet;<a name="line.23"></a>
<font color="green">024</font>    import java.sql.SQLException;<a name="line.24"></a>
<font color="green">025</font>    import java.util.ArrayList;<a name="line.25"></a>
<font color="green">026</font>    import java.util.List;<a name="line.26"></a>
<font color="green">027</font>    <a name="line.27"></a>
<font color="green">028</font>    <a name="line.28"></a>
<font color="green">029</font>    /**<a name="line.29"></a>
<font color="green">030</font>     * &lt;p&gt;Implementation of {@link DynaClass} that creates an in-memory collection<a name="line.30"></a>
<font color="green">031</font>     * of {@link DynaBean}s representing the results of an SQL query.  Once the<a name="line.31"></a>
<font color="green">032</font>     * {@link DynaClass} instance has been created, the JDBC &lt;code&gt;ResultSet&lt;/code&gt;<a name="line.32"></a>
<font color="green">033</font>     * and &lt;code&gt;Statement&lt;/code&gt; on which it is based can be closed, and the<a name="line.33"></a>
<font color="green">034</font>     * underlying &lt;code&gt;Connection&lt;/code&gt; can be returned to its connection pool<a name="line.34"></a>
<font color="green">035</font>     * (if you are using one).&lt;/p&gt;<a name="line.35"></a>
<font color="green">036</font>     *<a name="line.36"></a>
<font color="green">037</font>     * &lt;p&gt;The normal usage pattern is something like:&lt;/p&gt;<a name="line.37"></a>
<font color="green">038</font>     * &lt;pre&gt;<a name="line.38"></a>
<font color="green">039</font>     *   Connection conn = ...;  // Acquire connection from pool<a name="line.39"></a>
<font color="green">040</font>     *   Statement stmt = conn.createStatement();<a name="line.40"></a>
<font color="green">041</font>     *   ResultSet rs = stmt.executeQuery("SELECT ...");<a name="line.41"></a>
<font color="green">042</font>     *   RowSetDynaClass rsdc = new RowSetDynaClass(rs);<a name="line.42"></a>
<font color="green">043</font>     *   rs.close();<a name="line.43"></a>
<font color="green">044</font>     *   stmt.close();<a name="line.44"></a>
<font color="green">045</font>     *   ...;                    // Return connection to pool<a name="line.45"></a>
<font color="green">046</font>     *   List rows = rsdc.getRows();<a name="line.46"></a>
<font color="green">047</font>     *   ...;                   // Process the rows as desired<a name="line.47"></a>
<font color="green">048</font>     * &lt;/pre&gt;<a name="line.48"></a>
<font color="green">049</font>     *<a name="line.49"></a>
<font color="green">050</font>     * &lt;p&gt;Each column in the result set will be represented as a {@link DynaBean}<a name="line.50"></a>
<font color="green">051</font>     * property of the corresponding name (optionally forced to lower case<a name="line.51"></a>
<font color="green">052</font>     * for portability).  There will be one {@link DynaBean} in the<a name="line.52"></a>
<font color="green">053</font>     * &lt;code&gt;List&lt;/code&gt; returned by &lt;code&gt;getRows()&lt;/code&gt; for each<a name="line.53"></a>
<font color="green">054</font>     * row in the original &lt;code&gt;ResultSet&lt;/code&gt;.&lt;/p&gt;<a name="line.54"></a>
<font color="green">055</font>     *<a name="line.55"></a>
<font color="green">056</font>     * &lt;p&gt;In general, instances of {@link RowSetDynaClass} can be serialized<a name="line.56"></a>
<font color="green">057</font>     * and deserialized, which will automatically include the list of<a name="line.57"></a>
<font color="green">058</font>     * {@link DynaBean}s representing the data content.  The only exception<a name="line.58"></a>
<font color="green">059</font>     * to this rule would be when the underlying property values that were<a name="line.59"></a>
<font color="green">060</font>     * copied from the &lt;code&gt;ResultSet&lt;/code&gt; originally cannot themselves<a name="line.60"></a>
<font color="green">061</font>     * be serialized.  Therefore, a {@link RowSetDynaClass} makes a very<a name="line.61"></a>
<font color="green">062</font>     * convenient mechanism for transporting data sets to remote Java-based<a name="line.62"></a>
<font color="green">063</font>     * application components.&lt;/p&gt;<a name="line.63"></a>
<font color="green">064</font>     *<a name="line.64"></a>
<font color="green">065</font>     * @author Craig R. McClanahan<a name="line.65"></a>
<font color="green">066</font>     * @version $Revision: 926685 $ $Date: 2010-03-23 17:59:08 +0000 (Tue, 23 Mar 2010) $<a name="line.66"></a>
<font color="green">067</font>     */<a name="line.67"></a>
<font color="green">068</font>    <a name="line.68"></a>
<font color="green">069</font>    public class RowSetDynaClass extends JDBCDynaClass implements DynaClass, Serializable {<a name="line.69"></a>
<font color="green">070</font>    <a name="line.70"></a>
<font color="green">071</font>    <a name="line.71"></a>
<font color="green">072</font>        // ----------------------------------------------------- Instance variables<a name="line.72"></a>
<font color="green">073</font>        <a name="line.73"></a>
<font color="green">074</font>        /**<a name="line.74"></a>
<font color="green">075</font>         * &lt;p&gt;Limits the size of the returned list.  The call to <a name="line.75"></a>
<font color="green">076</font>         * &lt;code&gt;getRows()&lt;/code&gt; will return at most limit number of rows.<a name="line.76"></a>
<font color="green">077</font>         * If less than or equal to 0, does not limit the size of the result.<a name="line.77"></a>
<font color="green">078</font>         */<a name="line.78"></a>
<font color="green">079</font>        protected int limit = -1;<a name="line.79"></a>
<font color="green">080</font>    <a name="line.80"></a>
<font color="green">081</font>        /**<a name="line.81"></a>
<font color="green">082</font>         * &lt;p&gt;The list of {@link DynaBean}s representing the contents of<a name="line.82"></a>
<font color="green">083</font>         * the original &lt;code&gt;ResultSet&lt;/code&gt; on which this<a name="line.83"></a>
<font color="green">084</font>         * {@link RowSetDynaClass} was based.&lt;/p&gt;<a name="line.84"></a>
<font color="green">085</font>         */<a name="line.85"></a>
<font color="green">086</font>        protected List rows = new ArrayList();<a name="line.86"></a>
<font color="green">087</font>    <a name="line.87"></a>
<font color="green">088</font>        // ----------------------------------------------------------- Constructors<a name="line.88"></a>
<font color="green">089</font>    <a name="line.89"></a>
<font color="green">090</font>    <a name="line.90"></a>
<font color="green">091</font>        /**<a name="line.91"></a>
<font color="green">092</font>         * &lt;p&gt;Construct a new {@link RowSetDynaClass} for the specified<a name="line.92"></a>
<font color="green">093</font>         * &lt;code&gt;ResultSet&lt;/code&gt;.  The property names corresponding<a name="line.93"></a>
<font color="green">094</font>         * to column names in the result set will be lower cased.&lt;/p&gt;<a name="line.94"></a>
<font color="green">095</font>         *<a name="line.95"></a>
<font color="green">096</font>         * @param resultSet The result set to be wrapped<a name="line.96"></a>
<font color="green">097</font>         *<a name="line.97"></a>
<font color="green">098</font>         * @exception NullPointerException if &lt;code&gt;resultSet&lt;/code&gt;<a name="line.98"></a>
<font color="green">099</font>         *  is &lt;code&gt;null&lt;/code&gt;<a name="line.99"></a>
<font color="green">100</font>         * @exception SQLException if the metadata for this result set<a name="line.100"></a>
<font color="green">101</font>         *  cannot be introspected<a name="line.101"></a>
<font color="green">102</font>         */<a name="line.102"></a>
<font color="green">103</font>        public RowSetDynaClass(ResultSet resultSet) throws SQLException {<a name="line.103"></a>
<font color="green">104</font>    <a name="line.104"></a>
<font color="green">105</font>            this(resultSet, true, -1);<a name="line.105"></a>
<font color="green">106</font>    <a name="line.106"></a>
<font color="green">107</font>        }<a name="line.107"></a>
<font color="green">108</font>    <a name="line.108"></a>
<font color="green">109</font>        /**<a name="line.109"></a>
<font color="green">110</font>         * &lt;p&gt;Construct a new {@link RowSetDynaClass} for the specified<a name="line.110"></a>
<font color="green">111</font>         * &lt;code&gt;ResultSet&lt;/code&gt;.  The property names corresponding<a name="line.111"></a>
<font color="green">112</font>         * to column names in the result set will be lower cased.&lt;/p&gt;<a name="line.112"></a>
<font color="green">113</font>         * <a name="line.113"></a>
<font color="green">114</font>         * If &lt;code&gt;limit&lt;/code&gt; is not less than 0, max &lt;code&gt;limit&lt;/code&gt;<a name="line.114"></a>
<font color="green">115</font>         * number of rows will be copied into the list. <a name="line.115"></a>
<font color="green">116</font>         *<a name="line.116"></a>
<font color="green">117</font>         * @param resultSet The result set to be wrapped<a name="line.117"></a>
<font color="green">118</font>         * @param limit The maximum for the size of the result. <a name="line.118"></a>
<font color="green">119</font>         *<a name="line.119"></a>
<font color="green">120</font>         * @exception NullPointerException if &lt;code&gt;resultSet&lt;/code&gt;<a name="line.120"></a>
<font color="green">121</font>         *  is &lt;code&gt;null&lt;/code&gt;<a name="line.121"></a>
<font color="green">122</font>         * @exception SQLException if the metadata for this result set<a name="line.122"></a>
<font color="green">123</font>         *  cannot be introspected<a name="line.123"></a>
<font color="green">124</font>         */<a name="line.124"></a>
<font color="green">125</font>        public RowSetDynaClass(ResultSet resultSet, int limit) throws SQLException {<a name="line.125"></a>
<font color="green">126</font>    <a name="line.126"></a>
<font color="green">127</font>            this(resultSet, true, limit);<a name="line.127"></a>
<font color="green">128</font>    <a name="line.128"></a>
<font color="green">129</font>        }<a name="line.129"></a>
<font color="green">130</font>    <a name="line.130"></a>
<font color="green">131</font>    <a name="line.131"></a>
<font color="green">132</font>        /**<a name="line.132"></a>
<font color="green">133</font>         * &lt;p&gt;Construct a new {@link RowSetDynaClass} for the specified<a name="line.133"></a>
<font color="green">134</font>         * &lt;code&gt;ResultSet&lt;/code&gt;.  The property names corresponding<a name="line.134"></a>
<font color="green">135</font>         * to the column names in the result set will be lower cased or not,<a name="line.135"></a>
<font color="green">136</font>         * depending on the specified &lt;code&gt;lowerCase&lt;/code&gt; value.&lt;/p&gt;<a name="line.136"></a>
<font color="green">137</font>         *<a name="line.137"></a>
<font color="green">138</font>         * If &lt;code&gt;limit&lt;/code&gt; is not less than 0, max &lt;code&gt;limit&lt;/code&gt;<a name="line.138"></a>
<font color="green">139</font>         * number of rows will be copied into the resultset. <a name="line.139"></a>
<font color="green">140</font>         *<a name="line.140"></a>
<font color="green">141</font>         *<a name="line.141"></a>
<font color="green">142</font>         * @param resultSet The result set to be wrapped<a name="line.142"></a>
<font color="green">143</font>         * @param lowerCase Should property names be lower cased?<a name="line.143"></a>
<font color="green">144</font>         *<a name="line.144"></a>
<font color="green">145</font>         * @exception NullPointerException if &lt;code&gt;resultSet&lt;/code&gt;<a name="line.145"></a>
<font color="green">146</font>         *  is &lt;code&gt;null&lt;/code&gt;<a name="line.146"></a>
<font color="green">147</font>         * @exception SQLException if the metadata for this result set<a name="line.147"></a>
<font color="green">148</font>         *  cannot be introspected<a name="line.148"></a>
<font color="green">149</font>         */<a name="line.149"></a>
<font color="green">150</font>        public RowSetDynaClass(ResultSet resultSet, boolean lowerCase)<a name="line.150"></a>
<font color="green">151</font>                                                        throws SQLException {<a name="line.151"></a>
<font color="green">152</font>            this(resultSet, lowerCase, -1);<a name="line.152"></a>
<font color="green">153</font>    <a name="line.153"></a>
<font color="green">154</font>        }<a name="line.154"></a>
<font color="green">155</font>    <a name="line.155"></a>
<font color="green">156</font>        /**<a name="line.156"></a>
<font color="green">157</font>         * &lt;p&gt;Construct a new {@link RowSetDynaClass} for the specified<a name="line.157"></a>
<font color="green">158</font>         * &lt;code&gt;ResultSet&lt;/code&gt;.  The property names corresponding<a name="line.158"></a>
<font color="green">159</font>         * to the column names in the result set will be lower cased or not,<a name="line.159"></a>
<font color="green">160</font>         * depending on the specified &lt;code&gt;lowerCase&lt;/code&gt; value.&lt;/p&gt;<a name="line.160"></a>
<font color="green">161</font>         *<a name="line.161"></a>
<font color="green">162</font>         * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - If you specify &lt;code&gt;false&lt;/code&gt;<a name="line.162"></a>
<font color="green">163</font>         * for &lt;code&gt;lowerCase&lt;/code&gt;, the returned property names will<a name="line.163"></a>
<font color="green">164</font>         * exactly match the column names returned by your JDBC driver.<a name="line.164"></a>
<font color="green">165</font>         * Because different drivers might return column names in different<a name="line.165"></a>
<font color="green">166</font>         * cases, the property names seen by your application will vary<a name="line.166"></a>
<font color="green">167</font>         * depending on which JDBC driver you are using.&lt;/p&gt;<a name="line.167"></a>
<font color="green">168</font>         *<a name="line.168"></a>
<font color="green">169</font>         * @param resultSet The result set to be wrapped<a name="line.169"></a>
<font color="green">170</font>         * @param lowerCase Should property names be lower cased?<a name="line.170"></a>
<font color="green">171</font>         * @param limit Maximum limit for the &lt;code&gt;List&lt;/code&gt; of {@link DynaBean}<a name="line.171"></a>
<font color="green">172</font>         *<a name="line.172"></a>
<font color="green">173</font>         * @exception NullPointerException if &lt;code&gt;resultSet&lt;/code&gt;<a name="line.173"></a>
<font color="green">174</font>         *  is &lt;code&gt;null&lt;/code&gt;<a name="line.174"></a>
<font color="green">175</font>         * @exception SQLException if the metadata for this result set<a name="line.175"></a>
<font color="green">176</font>         *  cannot be introspected<a name="line.176"></a>
<font color="green">177</font>         */<a name="line.177"></a>
<font color="green">178</font>        public RowSetDynaClass(ResultSet resultSet, boolean lowerCase, int limit)<a name="line.178"></a>
<font color="green">179</font>                                                                throws SQLException {<a name="line.179"></a>
<font color="green">180</font>    <a name="line.180"></a>
<font color="green">181</font>            this(resultSet, lowerCase, limit, false);<a name="line.181"></a>
<font color="green">182</font>    <a name="line.182"></a>
<font color="green">183</font>        }<a name="line.183"></a>
<font color="green">184</font>    <a name="line.184"></a>
<font color="green">185</font>        /**<a name="line.185"></a>
<font color="green">186</font>         * &lt;p&gt;Construct a new {@link RowSetDynaClass} for the specified<a name="line.186"></a>
<font color="green">187</font>         * &lt;code&gt;ResultSet&lt;/code&gt;.  The property names corresponding<a name="line.187"></a>
<font color="green">188</font>         * to the column names in the result set will be lower cased or not,<a name="line.188"></a>
<font color="green">189</font>         * depending on the specified &lt;code&gt;lowerCase&lt;/code&gt; value.&lt;/p&gt;<a name="line.189"></a>
<font color="green">190</font>         *<a name="line.190"></a>
<font color="green">191</font>         * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - If you specify &lt;code&gt;false&lt;/code&gt;<a name="line.191"></a>
<font color="green">192</font>         * for &lt;code&gt;lowerCase&lt;/code&gt;, the returned property names will<a name="line.192"></a>
<font color="green">193</font>         * exactly match the column names returned by your JDBC driver.<a name="line.193"></a>
<font color="green">194</font>         * Because different drivers might return column names in different<a name="line.194"></a>
<font color="green">195</font>         * cases, the property names seen by your application will vary<a name="line.195"></a>
<font color="green">196</font>         * depending on which JDBC driver you are using.&lt;/p&gt;<a name="line.196"></a>
<font color="green">197</font>         *<a name="line.197"></a>
<font color="green">198</font>         * @param resultSet The result set to be wrapped<a name="line.198"></a>
<font color="green">199</font>         * @param lowerCase Should property names be lower cased?<a name="line.199"></a>
<font color="green">200</font>         * @param useColumnLabel true if the column label should be used, otherwise false<a name="line.200"></a>
<font color="green">201</font>         *<a name="line.201"></a>
<font color="green">202</font>         * @exception NullPointerException if &lt;code&gt;resultSet&lt;/code&gt;<a name="line.202"></a>
<font color="green">203</font>         *  is &lt;code&gt;null&lt;/code&gt;<a name="line.203"></a>
<font color="green">204</font>         * @exception SQLException if the metadata for this result set<a name="line.204"></a>
<font color="green">205</font>         *  cannot be introspected<a name="line.205"></a>
<font color="green">206</font>         * @since 1.8.3<a name="line.206"></a>
<font color="green">207</font>         */<a name="line.207"></a>
<font color="green">208</font>        public RowSetDynaClass(ResultSet resultSet, boolean lowerCase, boolean useColumnLabel)<a name="line.208"></a>
<font color="green">209</font>            throws SQLException {<a name="line.209"></a>
<font color="green">210</font>            this(resultSet, lowerCase, -1, useColumnLabel);<a name="line.210"></a>
<font color="green">211</font>    <a name="line.211"></a>
<font color="green">212</font>        }<a name="line.212"></a>
<font color="green">213</font>    <a name="line.213"></a>
<font color="green">214</font>        /**<a name="line.214"></a>
<font color="green">215</font>         * &lt;p&gt;Construct a new {@link RowSetDynaClass} for the specified<a name="line.215"></a>
<font color="green">216</font>         * &lt;code&gt;ResultSet&lt;/code&gt;.  The property names corresponding<a name="line.216"></a>
<font color="green">217</font>         * to the column names in the result set will be lower cased or not,<a name="line.217"></a>
<font color="green">218</font>         * depending on the specified &lt;code&gt;lowerCase&lt;/code&gt; value.&lt;/p&gt;<a name="line.218"></a>
<font color="green">219</font>         *<a name="line.219"></a>
<font color="green">220</font>         * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - If you specify &lt;code&gt;false&lt;/code&gt;<a name="line.220"></a>
<font color="green">221</font>         * for &lt;code&gt;lowerCase&lt;/code&gt;, the returned property names will<a name="line.221"></a>
<font color="green">222</font>         * exactly match the column names returned by your JDBC driver.<a name="line.222"></a>
<font color="green">223</font>         * Because different drivers might return column names in different<a name="line.223"></a>
<font color="green">224</font>         * cases, the property names seen by your application will vary<a name="line.224"></a>
<font color="green">225</font>         * depending on which JDBC driver you are using.&lt;/p&gt;<a name="line.225"></a>
<font color="green">226</font>         *<a name="line.226"></a>
<font color="green">227</font>         * @param resultSet The result set to be wrapped<a name="line.227"></a>
<font color="green">228</font>         * @param lowerCase Should property names be lower cased?<a name="line.228"></a>
<font color="green">229</font>         * @param limit Maximum limit for the &lt;code&gt;List&lt;/code&gt; of {@link DynaBean}<a name="line.229"></a>
<font color="green">230</font>         * @param useColumnLabel true if the column label should be used, otherwise false<a name="line.230"></a>
<font color="green">231</font>         *<a name="line.231"></a>
<font color="green">232</font>         * @exception NullPointerException if &lt;code&gt;resultSet&lt;/code&gt;<a name="line.232"></a>
<font color="green">233</font>         *  is &lt;code&gt;null&lt;/code&gt;<a name="line.233"></a>
<font color="green">234</font>         * @exception SQLException if the metadata for this result set<a name="line.234"></a>
<font color="green">235</font>         *  cannot be introspected<a name="line.235"></a>
<font color="green">236</font>         * @since 1.8.3<a name="line.236"></a>
<font color="green">237</font>         */<a name="line.237"></a>
<font color="green">238</font>        public RowSetDynaClass(ResultSet resultSet, boolean lowerCase, int limit, boolean useColumnLabel)<a name="line.238"></a>
<font color="green">239</font>                                                                throws SQLException {<a name="line.239"></a>
<font color="green">240</font>    <a name="line.240"></a>
<font color="green">241</font>            if (resultSet == null) {<a name="line.241"></a>
<font color="green">242</font>                throw new NullPointerException();<a name="line.242"></a>
<font color="green">243</font>            }<a name="line.243"></a>
<font color="green">244</font>            this.lowerCase = lowerCase;<a name="line.244"></a>
<font color="green">245</font>            this.limit = limit;<a name="line.245"></a>
<font color="green">246</font>            setUseColumnLabel(useColumnLabel);<a name="line.246"></a>
<font color="green">247</font>            introspect(resultSet);<a name="line.247"></a>
<font color="green">248</font>            copy(resultSet);<a name="line.248"></a>
<font color="green">249</font>    <a name="line.249"></a>
<font color="green">250</font>        }<a name="line.250"></a>
<font color="green">251</font>    <a name="line.251"></a>
<font color="green">252</font>        /**<a name="line.252"></a>
<font color="green">253</font>         * &lt;p&gt;Return a &lt;code&gt;List&lt;/code&gt; containing the {@link DynaBean}s that<a name="line.253"></a>
<font color="green">254</font>         * represent the contents of each &lt;code&gt;Row&lt;/code&gt; from the<a name="line.254"></a>
<font color="green">255</font>         * &lt;code&gt;ResultSet&lt;/code&gt; that was the basis of this<a name="line.255"></a>
<font color="green">256</font>         * {@link RowSetDynaClass} instance.  These {@link DynaBean}s are<a name="line.256"></a>
<font color="green">257</font>         * disconnected from the database itself, so there is no problem with<a name="line.257"></a>
<font color="green">258</font>         * modifying the contents of the list, or the values of the properties<a name="line.258"></a>
<font color="green">259</font>         * of these {@link DynaBean}s.  However, it is the application's<a name="line.259"></a>
<font color="green">260</font>         * responsibility to persist any such changes back to the database,<a name="line.260"></a>
<font color="green">261</font>         * if it so desires.&lt;/p&gt;<a name="line.261"></a>
<font color="green">262</font>         *<a name="line.262"></a>
<font color="green">263</font>         * @return A &lt;code&gt;List&lt;/code&gt; of {@link DynaBean} instances<a name="line.263"></a>
<font color="green">264</font>         */<a name="line.264"></a>
<font color="green">265</font>        public List getRows() {<a name="line.265"></a>
<font color="green">266</font>    <a name="line.266"></a>
<font color="green">267</font>            return (this.rows);<a name="line.267"></a>
<font color="green">268</font>    <a name="line.268"></a>
<font color="green">269</font>        }<a name="line.269"></a>
<font color="green">270</font>    <a name="line.270"></a>
<font color="green">271</font>    <a name="line.271"></a>
<font color="green">272</font>        // ------------------------------------------------------ Protected Methods<a name="line.272"></a>
<font color="green">273</font>    <a name="line.273"></a>
<font color="green">274</font>    <a name="line.274"></a>
<font color="green">275</font>        /**<a name="line.275"></a>
<font color="green">276</font>         * &lt;p&gt;Copy the column values for each row in the specified<a name="line.276"></a>
<font color="green">277</font>         * &lt;code&gt;ResultSet&lt;/code&gt; into a newly created {@link DynaBean}, and add<a name="line.277"></a>
<font color="green">278</font>         * this bean to the list of {@link DynaBean}s that will later by<a name="line.278"></a>
<font color="green">279</font>         * returned by a call to &lt;code&gt;getRows()&lt;/code&gt;.&lt;/p&gt;<a name="line.279"></a>
<font color="green">280</font>         *<a name="line.280"></a>
<font color="green">281</font>         * @param resultSet The &lt;code&gt;ResultSet&lt;/code&gt; whose data is to be<a name="line.281"></a>
<font color="green">282</font>         *  copied<a name="line.282"></a>
<font color="green">283</font>         *<a name="line.283"></a>
<font color="green">284</font>         * @exception SQLException if an error is encountered copying the data<a name="line.284"></a>
<font color="green">285</font>         */<a name="line.285"></a>
<font color="green">286</font>        protected void copy(ResultSet resultSet) throws SQLException {<a name="line.286"></a>
<font color="green">287</font>    <a name="line.287"></a>
<font color="green">288</font>            int cnt = 0;<a name="line.288"></a>
<font color="green">289</font>            while (resultSet.next() &amp;&amp; (limit &lt; 0  || cnt++ &lt; limit) ) {<a name="line.289"></a>
<font color="green">290</font>                DynaBean bean = createDynaBean();<a name="line.290"></a>
<font color="green">291</font>                for (int i = 0; i &lt; properties.length; i++) {<a name="line.291"></a>
<font color="green">292</font>                    String name = properties[i].getName();<a name="line.292"></a>
<font color="green">293</font>                    Object value = getObject(resultSet, name);<a name="line.293"></a>
<font color="green">294</font>                    bean.set(name, value);<a name="line.294"></a>
<font color="green">295</font>                }<a name="line.295"></a>
<font color="green">296</font>                rows.add(bean);<a name="line.296"></a>
<font color="green">297</font>            }<a name="line.297"></a>
<font color="green">298</font>    <a name="line.298"></a>
<font color="green">299</font>        }<a name="line.299"></a>
<font color="green">300</font>    <a name="line.300"></a>
<font color="green">301</font>    <a name="line.301"></a>
<font color="green">302</font>        /**<a name="line.302"></a>
<font color="green">303</font>         * &lt;p&gt;Create and return a new {@link DynaBean} instance to be used for<a name="line.303"></a>
<font color="green">304</font>         * representing a row in the underlying result set.&lt;/p&gt;<a name="line.304"></a>
<font color="green">305</font>         *<a name="line.305"></a>
<font color="green">306</font>         * @return A new &lt;code&gt;DynaBean&lt;/code&gt; instance<a name="line.306"></a>
<font color="green">307</font>         */<a name="line.307"></a>
<font color="green">308</font>        protected DynaBean createDynaBean() {<a name="line.308"></a>
<font color="green">309</font>    <a name="line.309"></a>
<font color="green">310</font>            return (new BasicDynaBean(this));<a name="line.310"></a>
<font color="green">311</font>    <a name="line.311"></a>
<font color="green">312</font>        }<a name="line.312"></a>
<font color="green">313</font>    <a name="line.313"></a>
<font color="green">314</font>    <a name="line.314"></a>
<font color="green">315</font>    }<a name="line.315"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/ResultSetIterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/ResultSetIterator/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:14:01" itemprop="dateModified" datetime="2010-03-24T17:14:01+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>    <a name="line.17"></a>
<font color="green">018</font>    <a name="line.18"></a>
<font color="green">019</font>    package org.apache.commons.beanutils;<a name="line.19"></a>
<font color="green">020</font>    <a name="line.20"></a>
<font color="green">021</font>    <a name="line.21"></a>
<font color="green">022</font>    import java.sql.SQLException;<a name="line.22"></a>
<font color="green">023</font>    import java.util.Iterator;<a name="line.23"></a>
<font color="green">024</font>    import java.util.NoSuchElementException;<a name="line.24"></a>
<font color="green">025</font>    <a name="line.25"></a>
<font color="green">026</font>    <a name="line.26"></a>
<font color="green">027</font>    /**<a name="line.27"></a>
<font color="green">028</font>     * &lt;p&gt;Implementation of &lt;code&gt;java.util.Iterator&lt;/code&gt; returned by the<a name="line.28"></a>
<font color="green">029</font>     * &lt;code&gt;iterator()&lt;/code&gt; method of {@link ResultSetDynaClass}.  Each<a name="line.29"></a>
<font color="green">030</font>     * object returned by this iterator will be a {@link DynaBean} that<a name="line.30"></a>
<font color="green">031</font>     * represents a single row from the result set being wrapped.&lt;/p&gt;<a name="line.31"></a>
<font color="green">032</font>     *<a name="line.32"></a>
<font color="green">033</font>     * @author Craig R. McClanahan<a name="line.33"></a>
<font color="green">034</font>     * @version $Revision: 556221 $ $Date: 2007-07-14 05:19:21 +0100 (Sat, 14 Jul 2007) $<a name="line.34"></a>
<font color="green">035</font>     */<a name="line.35"></a>
<font color="green">036</font>    <a name="line.36"></a>
<font color="green">037</font>    public class ResultSetIterator implements DynaBean, Iterator {<a name="line.37"></a>
<font color="green">038</font>    <a name="line.38"></a>
<font color="green">039</font>    <a name="line.39"></a>
<font color="green">040</font>        // ------------------------------------------------------------ Constructor<a name="line.40"></a>
<font color="green">041</font>    <a name="line.41"></a>
<font color="green">042</font>    <a name="line.42"></a>
<font color="green">043</font>        /**<a name="line.43"></a>
<font color="green">044</font>         * &lt;p&gt;Construct an &lt;code&gt;Iterator&lt;/code&gt; for the result set being wrapped<a name="line.44"></a>
<font color="green">045</font>         * by the specified {@link ResultSetDynaClass}.&lt;/p&gt;<a name="line.45"></a>
<font color="green">046</font>         *<a name="line.46"></a>
<font color="green">047</font>         * @param dynaClass The {@link ResultSetDynaClass} wrapping the<a name="line.47"></a>
<font color="green">048</font>         *  result set we will iterate over<a name="line.48"></a>
<font color="green">049</font>         */<a name="line.49"></a>
<font color="green">050</font>        ResultSetIterator(ResultSetDynaClass dynaClass) {<a name="line.50"></a>
<font color="green">051</font>    <a name="line.51"></a>
<font color="green">052</font>            this.dynaClass = dynaClass;<a name="line.52"></a>
<font color="green">053</font>    <a name="line.53"></a>
<font color="green">054</font>        }<a name="line.54"></a>
<font color="green">055</font>    <a name="line.55"></a>
<font color="green">056</font>    <a name="line.56"></a>
<font color="green">057</font>        // ----------------------------------------------------- Instance Variables<a name="line.57"></a>
<font color="green">058</font>    <a name="line.58"></a>
<font color="green">059</font>    <a name="line.59"></a>
<font color="green">060</font>    <a name="line.60"></a>
<font color="green">061</font>        /**<a name="line.61"></a>
<font color="green">062</font>         * &lt;p&gt;Flag indicating whether the result set is currently positioned at a<a name="line.62"></a>
<font color="green">063</font>         * row for which we have not yet returned an element in the iteration.&lt;/p&gt;<a name="line.63"></a>
<font color="green">064</font>         */<a name="line.64"></a>
<font color="green">065</font>        protected boolean current = false;<a name="line.65"></a>
<font color="green">066</font>    <a name="line.66"></a>
<font color="green">067</font>    <a name="line.67"></a>
<font color="green">068</font>        /**<a name="line.68"></a>
<font color="green">069</font>         * &lt;p&gt;The {@link ResultSetDynaClass} we are associated with.&lt;/p&gt;<a name="line.69"></a>
<font color="green">070</font>         */<a name="line.70"></a>
<font color="green">071</font>        protected ResultSetDynaClass dynaClass = null;<a name="line.71"></a>
<font color="green">072</font>    <a name="line.72"></a>
<font color="green">073</font>    <a name="line.73"></a>
<font color="green">074</font>        /**<a name="line.74"></a>
<font color="green">075</font>         * &lt;p&gt;Flag indicating whether the result set has indicated that there are<a name="line.75"></a>
<font color="green">076</font>         * no further rows.&lt;/p&gt;<a name="line.76"></a>
<font color="green">077</font>         */<a name="line.77"></a>
<font color="green">078</font>        protected boolean eof = false;<a name="line.78"></a>
<font color="green">079</font>    <a name="line.79"></a>
<font color="green">080</font>    <a name="line.80"></a>
<font color="green">081</font>        // ------------------------------------------------------- DynaBean Methods<a name="line.81"></a>
<font color="green">082</font>    <a name="line.82"></a>
<font color="green">083</font>    <a name="line.83"></a>
<font color="green">084</font>        /**<a name="line.84"></a>
<font color="green">085</font>         * Does the specified mapped property contain a value for the specified<a name="line.85"></a>
<font color="green">086</font>         * key value?<a name="line.86"></a>
<font color="green">087</font>         *<a name="line.87"></a>
<font color="green">088</font>         * @param name Name of the property to check<a name="line.88"></a>
<font color="green">089</font>         * @param key Name of the key to check<a name="line.89"></a>
<font color="green">090</font>         * @return &lt;code&gt;true&lt;code&gt; if the mapped property contains a value for<a name="line.90"></a>
<font color="green">091</font>         * the specified key, otherwise &lt;code&gt;false&lt;/code&gt;<a name="line.91"></a>
<font color="green">092</font>         *<a name="line.92"></a>
<font color="green">093</font>         * @exception IllegalArgumentException if there is no property<a name="line.93"></a>
<font color="green">094</font>         *  of the specified name<a name="line.94"></a>
<font color="green">095</font>         */<a name="line.95"></a>
<font color="green">096</font>        public boolean contains(String name, String key) {<a name="line.96"></a>
<font color="green">097</font>    <a name="line.97"></a>
<font color="green">098</font>            throw new UnsupportedOperationException<a name="line.98"></a>
<font color="green">099</font>                ("FIXME - mapped properties not currently supported");<a name="line.99"></a>
<font color="green">100</font>    <a name="line.100"></a>
<font color="green">101</font>        }<a name="line.101"></a>
<font color="green">102</font>    <a name="line.102"></a>
<font color="green">103</font>    <a name="line.103"></a>
<font color="green">104</font>        /**<a name="line.104"></a>
<font color="green">105</font>         * Return the value of a simple property with the specified name.<a name="line.105"></a>
<font color="green">106</font>         *<a name="line.106"></a>
<font color="green">107</font>         * @param name Name of the property whose value is to be retrieved<a name="line.107"></a>
<font color="green">108</font>         * @return The property's value<a name="line.108"></a>
<font color="green">109</font>         *<a name="line.109"></a>
<font color="green">110</font>         * @exception IllegalArgumentException if there is no property<a name="line.110"></a>
<font color="green">111</font>         *  of the specified name<a name="line.111"></a>
<font color="green">112</font>         */<a name="line.112"></a>
<font color="green">113</font>        public Object get(String name) {<a name="line.113"></a>
<font color="green">114</font>    <a name="line.114"></a>
<font color="green">115</font>            if (dynaClass.getDynaProperty(name) == null) {<a name="line.115"></a>
<font color="green">116</font>                throw new IllegalArgumentException(name);<a name="line.116"></a>
<font color="green">117</font>            }<a name="line.117"></a>
<font color="green">118</font>            try {<a name="line.118"></a>
<font color="green">119</font>                return dynaClass.getObjectFromResultSet(name);<a name="line.119"></a>
<font color="green">120</font>            } catch (SQLException e) {<a name="line.120"></a>
<font color="green">121</font>                throw new RuntimeException<a name="line.121"></a>
<font color="green">122</font>                    ("get(" + name + "): SQLException: " + e);<a name="line.122"></a>
<font color="green">123</font>            }<a name="line.123"></a>
<font color="green">124</font>    <a name="line.124"></a>
<font color="green">125</font>        }<a name="line.125"></a>
<font color="green">126</font>    <a name="line.126"></a>
<font color="green">127</font>    <a name="line.127"></a>
<font color="green">128</font>        /**<a name="line.128"></a>
<font color="green">129</font>         * Return the value of an indexed property with the specified name.<a name="line.129"></a>
<font color="green">130</font>         *<a name="line.130"></a>
<font color="green">131</font>         * @param name Name of the property whose value is to be retrieved<a name="line.131"></a>
<font color="green">132</font>         * @param index Index of the value to be retrieved<a name="line.132"></a>
<font color="green">133</font>         * @return The indexed property's value<a name="line.133"></a>
<font color="green">134</font>         *<a name="line.134"></a>
<font color="green">135</font>         * @exception IllegalArgumentException if there is no property<a name="line.135"></a>
<font color="green">136</font>         *  of the specified name<a name="line.136"></a>
<font color="green">137</font>         * @exception IllegalArgumentException if the specified property<a name="line.137"></a>
<font color="green">138</font>         *  exists, but is not indexed<a name="line.138"></a>
<font color="green">139</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.139"></a>
<font color="green">140</font>         *  is outside the range of the underlying property<a name="line.140"></a>
<font color="green">141</font>         * @exception NullPointerException if no array or List has been<a name="line.141"></a>
<font color="green">142</font>         *  initialized for this property<a name="line.142"></a>
<font color="green">143</font>         */<a name="line.143"></a>
<font color="green">144</font>        public Object get(String name, int index) {<a name="line.144"></a>
<font color="green">145</font>    <a name="line.145"></a>
<font color="green">146</font>            throw new UnsupportedOperationException<a name="line.146"></a>
<font color="green">147</font>                ("FIXME - indexed properties not currently supported");<a name="line.147"></a>
<font color="green">148</font>    <a name="line.148"></a>
<font color="green">149</font>        }<a name="line.149"></a>
<font color="green">150</font>    <a name="line.150"></a>
<font color="green">151</font>    <a name="line.151"></a>
<font color="green">152</font>        /**<a name="line.152"></a>
<font color="green">153</font>         * Return the value of a mapped property with the specified name,<a name="line.153"></a>
<font color="green">154</font>         * or &lt;code&gt;null&lt;/code&gt; if there is no value for the specified key.<a name="line.154"></a>
<font color="green">155</font>         *<a name="line.155"></a>
<font color="green">156</font>         * @param name Name of the property whose value is to be retrieved<a name="line.156"></a>
<font color="green">157</font>         * @param key Key of the value to be retrieved<a name="line.157"></a>
<font color="green">158</font>         * @return The mapped property's value<a name="line.158"></a>
<font color="green">159</font>         *<a name="line.159"></a>
<font color="green">160</font>         * @exception IllegalArgumentException if there is no property<a name="line.160"></a>
<font color="green">161</font>         *  of the specified name<a name="line.161"></a>
<font color="green">162</font>         * @exception IllegalArgumentException if the specified property<a name="line.162"></a>
<font color="green">163</font>         *  exists, but is not mapped<a name="line.163"></a>
<font color="green">164</font>         */<a name="line.164"></a>
<font color="green">165</font>        public Object get(String name, String key) {<a name="line.165"></a>
<font color="green">166</font>    <a name="line.166"></a>
<font color="green">167</font>            throw new UnsupportedOperationException<a name="line.167"></a>
<font color="green">168</font>                ("FIXME - mapped properties not currently supported");<a name="line.168"></a>
<font color="green">169</font>    <a name="line.169"></a>
<font color="green">170</font>        }<a name="line.170"></a>
<font color="green">171</font>    <a name="line.171"></a>
<font color="green">172</font>    <a name="line.172"></a>
<font color="green">173</font>        /**<a name="line.173"></a>
<font color="green">174</font>         * Return the &lt;code&gt;DynaClass&lt;/code&gt; instance that describes the set of<a name="line.174"></a>
<font color="green">175</font>         * properties available for this DynaBean.<a name="line.175"></a>
<font color="green">176</font>         *<a name="line.176"></a>
<font color="green">177</font>         * @return The associated DynaClass<a name="line.177"></a>
<font color="green">178</font>         */<a name="line.178"></a>
<font color="green">179</font>        public DynaClass getDynaClass() {<a name="line.179"></a>
<font color="green">180</font>    <a name="line.180"></a>
<font color="green">181</font>            return (this.dynaClass);<a name="line.181"></a>
<font color="green">182</font>    <a name="line.182"></a>
<font color="green">183</font>        }<a name="line.183"></a>
<font color="green">184</font>    <a name="line.184"></a>
<font color="green">185</font>    <a name="line.185"></a>
<font color="green">186</font>        /**<a name="line.186"></a>
<font color="green">187</font>         * Remove any existing value for the specified key on the<a name="line.187"></a>
<font color="green">188</font>         * specified mapped property.<a name="line.188"></a>
<font color="green">189</font>         *<a name="line.189"></a>
<font color="green">190</font>         * @param name Name of the property for which a value is to<a name="line.190"></a>
<font color="green">191</font>         *  be removed<a name="line.191"></a>
<font color="green">192</font>         * @param key Key of the value to be removed<a name="line.192"></a>
<font color="green">193</font>         *<a name="line.193"></a>
<font color="green">194</font>         * @exception IllegalArgumentException if there is no property<a name="line.194"></a>
<font color="green">195</font>         *  of the specified name<a name="line.195"></a>
<font color="green">196</font>         */<a name="line.196"></a>
<font color="green">197</font>        public void remove(String name, String key) {<a name="line.197"></a>
<font color="green">198</font>    <a name="line.198"></a>
<font color="green">199</font>            throw new UnsupportedOperationException<a name="line.199"></a>
<font color="green">200</font>                ("FIXME - mapped operations not currently supported");<a name="line.200"></a>
<font color="green">201</font>    <a name="line.201"></a>
<font color="green">202</font>        }<a name="line.202"></a>
<font color="green">203</font>    <a name="line.203"></a>
<font color="green">204</font>    <a name="line.204"></a>
<font color="green">205</font>        /**<a name="line.205"></a>
<font color="green">206</font>         * Set the value of a simple property with the specified name.<a name="line.206"></a>
<font color="green">207</font>         *<a name="line.207"></a>
<font color="green">208</font>         * @param name Name of the property whose value is to be set<a name="line.208"></a>
<font color="green">209</font>         * @param value Value to which this property is to be set<a name="line.209"></a>
<font color="green">210</font>         *<a name="line.210"></a>
<font color="green">211</font>         * @exception ConversionException if the specified value cannot be<a name="line.211"></a>
<font color="green">212</font>         *  converted to the type required for this property<a name="line.212"></a>
<font color="green">213</font>         * @exception IllegalArgumentException if there is no property<a name="line.213"></a>
<font color="green">214</font>         *  of the specified name<a name="line.214"></a>
<font color="green">215</font>         * @exception NullPointerException if an attempt is made to set a<a name="line.215"></a>
<font color="green">216</font>         *  primitive property to null<a name="line.216"></a>
<font color="green">217</font>         */<a name="line.217"></a>
<font color="green">218</font>        public void set(String name, Object value) {<a name="line.218"></a>
<font color="green">219</font>    <a name="line.219"></a>
<font color="green">220</font>            if (dynaClass.getDynaProperty(name) == null) {<a name="line.220"></a>
<font color="green">221</font>                throw new IllegalArgumentException(name);<a name="line.221"></a>
<font color="green">222</font>            }<a name="line.222"></a>
<font color="green">223</font>            try {<a name="line.223"></a>
<font color="green">224</font>                dynaClass.getResultSet().updateObject(name, value);<a name="line.224"></a>
<font color="green">225</font>            } catch (SQLException e) {<a name="line.225"></a>
<font color="green">226</font>                throw new RuntimeException<a name="line.226"></a>
<font color="green">227</font>                    ("set(" + name + "): SQLException: " + e);<a name="line.227"></a>
<font color="green">228</font>            }<a name="line.228"></a>
<font color="green">229</font>    <a name="line.229"></a>
<font color="green">230</font>        }<a name="line.230"></a>
<font color="green">231</font>    <a name="line.231"></a>
<font color="green">232</font>    <a name="line.232"></a>
<font color="green">233</font>        /**<a name="line.233"></a>
<font color="green">234</font>         * Set the value of an indexed property with the specified name.<a name="line.234"></a>
<font color="green">235</font>         *<a name="line.235"></a>
<font color="green">236</font>         * @param name Name of the property whose value is to be set<a name="line.236"></a>
<font color="green">237</font>         * @param index Index of the property to be set<a name="line.237"></a>
<font color="green">238</font>         * @param value Value to which this property is to be set<a name="line.238"></a>
<font color="green">239</font>         *<a name="line.239"></a>
<font color="green">240</font>         * @exception ConversionException if the specified value cannot be<a name="line.240"></a>
<font color="green">241</font>         *  converted to the type required for this property<a name="line.241"></a>
<font color="green">242</font>         * @exception IllegalArgumentException if there is no property<a name="line.242"></a>
<font color="green">243</font>         *  of the specified name<a name="line.243"></a>
<font color="green">244</font>         * @exception IllegalArgumentException if the specified property<a name="line.244"></a>
<font color="green">245</font>         *  exists, but is not indexed<a name="line.245"></a>
<font color="green">246</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.246"></a>
<font color="green">247</font>         *  is outside the range of the underlying property<a name="line.247"></a>
<font color="green">248</font>         */<a name="line.248"></a>
<font color="green">249</font>        public void set(String name, int index, Object value) {<a name="line.249"></a>
<font color="green">250</font>    <a name="line.250"></a>
<font color="green">251</font>            throw new UnsupportedOperationException<a name="line.251"></a>
<font color="green">252</font>                ("FIXME - indexed properties not currently supported");<a name="line.252"></a>
<font color="green">253</font>    <a name="line.253"></a>
<font color="green">254</font>        }<a name="line.254"></a>
<font color="green">255</font>    <a name="line.255"></a>
<font color="green">256</font>    <a name="line.256"></a>
<font color="green">257</font>        /**<a name="line.257"></a>
<font color="green">258</font>         * Set the value of a mapped property with the specified name.<a name="line.258"></a>
<font color="green">259</font>         *<a name="line.259"></a>
<font color="green">260</font>         * @param name Name of the property whose value is to be set<a name="line.260"></a>
<font color="green">261</font>         * @param key Key of the property to be set<a name="line.261"></a>
<font color="green">262</font>         * @param value Value to which this property is to be set<a name="line.262"></a>
<font color="green">263</font>         *<a name="line.263"></a>
<font color="green">264</font>         * @exception ConversionException if the specified value cannot be<a name="line.264"></a>
<font color="green">265</font>         *  converted to the type required for this property<a name="line.265"></a>
<font color="green">266</font>         * @exception IllegalArgumentException if there is no property<a name="line.266"></a>
<font color="green">267</font>         *  of the specified name<a name="line.267"></a>
<font color="green">268</font>         * @exception IllegalArgumentException if the specified property<a name="line.268"></a>
<font color="green">269</font>         *  exists, but is not mapped<a name="line.269"></a>
<font color="green">270</font>         */<a name="line.270"></a>
<font color="green">271</font>        public void set(String name, String key, Object value) {<a name="line.271"></a>
<font color="green">272</font>    <a name="line.272"></a>
<font color="green">273</font>            throw new UnsupportedOperationException<a name="line.273"></a>
<font color="green">274</font>                ("FIXME - mapped properties not currently supported");<a name="line.274"></a>
<font color="green">275</font>    <a name="line.275"></a>
<font color="green">276</font>        }<a name="line.276"></a>
<font color="green">277</font>    <a name="line.277"></a>
<font color="green">278</font>    <a name="line.278"></a>
<font color="green">279</font>        // ------------------------------------------------------- Iterator Methods<a name="line.279"></a>
<font color="green">280</font>    <a name="line.280"></a>
<font color="green">281</font>    <a name="line.281"></a>
<font color="green">282</font>        /**<a name="line.282"></a>
<font color="green">283</font>         * &lt;p&gt;Return &lt;code&gt;true&lt;/code&gt; if the iteration has more elements.&lt;/p&gt;<a name="line.283"></a>
<font color="green">284</font>         *<a name="line.284"></a>
<font color="green">285</font>         * @return &lt;code&gt;true&lt;/code&gt; if the result set has another<a name="line.285"></a>
<font color="green">286</font>         * row, otherwise &lt;code&gt;false&lt;/code&gt;<a name="line.286"></a>
<font color="green">287</font>         */<a name="line.287"></a>
<font color="green">288</font>        public boolean hasNext() {<a name="line.288"></a>
<font color="green">289</font>    <a name="line.289"></a>
<font color="green">290</font>            try {<a name="line.290"></a>
<font color="green">291</font>                advance();<a name="line.291"></a>
<font color="green">292</font>                return (!eof);<a name="line.292"></a>
<font color="green">293</font>            } catch (SQLException e) {<a name="line.293"></a>
<font color="green">294</font>                throw new RuntimeException("hasNext():  SQLException:  " + e);<a name="line.294"></a>
<font color="green">295</font>            }<a name="line.295"></a>
<font color="green">296</font>    <a name="line.296"></a>
<font color="green">297</font>        }<a name="line.297"></a>
<font color="green">298</font>    <a name="line.298"></a>
<font color="green">299</font>    <a name="line.299"></a>
<font color="green">300</font>        /**<a name="line.300"></a>
<font color="green">301</font>         * &lt;p&gt;Return the next element in the iteration.&lt;/p&gt;<a name="line.301"></a>
<font color="green">302</font>         *<a name="line.302"></a>
<font color="green">303</font>         * @return advance to the new row and return this<a name="line.303"></a>
<font color="green">304</font>         */<a name="line.304"></a>
<font color="green">305</font>        public Object next() {<a name="line.305"></a>
<font color="green">306</font>    <a name="line.306"></a>
<font color="green">307</font>            try {<a name="line.307"></a>
<font color="green">308</font>                advance();<a name="line.308"></a>
<font color="green">309</font>                if (eof) {<a name="line.309"></a>
<font color="green">310</font>                    throw new NoSuchElementException();<a name="line.310"></a>
<font color="green">311</font>                }<a name="line.311"></a>
<font color="green">312</font>                current = false;<a name="line.312"></a>
<font color="green">313</font>                return (this);<a name="line.313"></a>
<font color="green">314</font>            } catch (SQLException e) {<a name="line.314"></a>
<font color="green">315</font>                throw new RuntimeException("next():  SQLException:  " + e);<a name="line.315"></a>
<font color="green">316</font>            }<a name="line.316"></a>
<font color="green">317</font>    <a name="line.317"></a>
<font color="green">318</font>        }<a name="line.318"></a>
<font color="green">319</font>    <a name="line.319"></a>
<font color="green">320</font>    <a name="line.320"></a>
<font color="green">321</font>        /**<a name="line.321"></a>
<font color="green">322</font>         * &lt;p&gt;Remove the current element from the iteration.  This method is<a name="line.322"></a>
<font color="green">323</font>         * not supported.&lt;/p&gt;<a name="line.323"></a>
<font color="green">324</font>         */<a name="line.324"></a>
<font color="green">325</font>        public void remove() {<a name="line.325"></a>
<font color="green">326</font>    <a name="line.326"></a>
<font color="green">327</font>            throw new UnsupportedOperationException("remove()");<a name="line.327"></a>
<font color="green">328</font>    <a name="line.328"></a>
<font color="green">329</font>        }<a name="line.329"></a>
<font color="green">330</font>    <a name="line.330"></a>
<font color="green">331</font>    <a name="line.331"></a>
<font color="green">332</font>        // ------------------------------------------------------ Protected Methods<a name="line.332"></a>
<font color="green">333</font>    <a name="line.333"></a>
<font color="green">334</font>    <a name="line.334"></a>
<font color="green">335</font>        /**<a name="line.335"></a>
<font color="green">336</font>         * &lt;p&gt;Advance the result set to the next row, if there is not a current<a name="line.336"></a>
<font color="green">337</font>         * row (and if we are not already at eof).&lt;/p&gt;<a name="line.337"></a>
<font color="green">338</font>         *<a name="line.338"></a>
<font color="green">339</font>         * @exception SQLException if the result set throws an exception<a name="line.339"></a>
<font color="green">340</font>         */<a name="line.340"></a>
<font color="green">341</font>        protected void advance() throws SQLException {<a name="line.341"></a>
<font color="green">342</font>    <a name="line.342"></a>
<font color="green">343</font>            if (!current &amp;&amp; !eof) {<a name="line.343"></a>
<font color="green">344</font>                if (dynaClass.getResultSet().next()) {<a name="line.344"></a>
<font color="green">345</font>                    current = true;<a name="line.345"></a>
<font color="green">346</font>                    eof = false;<a name="line.346"></a>
<font color="green">347</font>                } else {<a name="line.347"></a>
<font color="green">348</font>                    current = false;<a name="line.348"></a>
<font color="green">349</font>                    eof = true;<a name="line.349"></a>
<font color="green">350</font>                }<a name="line.350"></a>
<font color="green">351</font>            }<a name="line.351"></a>
<font color="green">352</font>    <a name="line.352"></a>
<font color="green">353</font>        }<a name="line.353"></a>
<font color="green">354</font>    <a name="line.354"></a>
<font color="green">355</font>    <a name="line.355"></a>
<font color="green">356</font>    }<a name="line.356"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/ResultSetDynaClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/ResultSetDynaClass/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:14:01" itemprop="dateModified" datetime="2010-03-24T17:14:01+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>    <a name="line.17"></a>
<font color="green">018</font>    <a name="line.18"></a>
<font color="green">019</font>    package org.apache.commons.beanutils;<a name="line.19"></a>
<font color="green">020</font>    <a name="line.20"></a>
<font color="green">021</font>    <a name="line.21"></a>
<font color="green">022</font>    import java.sql.ResultSet;<a name="line.22"></a>
<font color="green">023</font>    import java.sql.SQLException;<a name="line.23"></a>
<font color="green">024</font>    import java.util.Iterator;<a name="line.24"></a>
<font color="green">025</font>    <a name="line.25"></a>
<font color="green">026</font>    <a name="line.26"></a>
<font color="green">027</font>    /**<a name="line.27"></a>
<font color="green">028</font>     * &lt;p&gt;Implementation of &lt;code&gt;DynaClass&lt;/code&gt; for DynaBeans that wrap the<a name="line.28"></a>
<font color="green">029</font>     * &lt;code&gt;java.sql.Row&lt;/code&gt; objects of a &lt;code&gt;java.sql.ResultSet&lt;/code&gt;.<a name="line.29"></a>
<font color="green">030</font>     * The normal usage pattern is something like:&lt;/p&gt;<a name="line.30"></a>
<font color="green">031</font>     * &lt;pre&gt;<a name="line.31"></a>
<font color="green">032</font>     *   ResultSet rs = ...;<a name="line.32"></a>
<font color="green">033</font>     *   ResultSetDynaClass rsdc = new ResultSetDynaClass(rs);<a name="line.33"></a>
<font color="green">034</font>     *   Iterator rows = rsdc.iterator();<a name="line.34"></a>
<font color="green">035</font>     *   while (rows.hasNext())  {<a name="line.35"></a>
<font color="green">036</font>     *     DynaBean row = (DynaBean) rows.next();<a name="line.36"></a>
<font color="green">037</font>     *     ... process this row ...<a name="line.37"></a>
<font color="green">038</font>     *   }<a name="line.38"></a>
<font color="green">039</font>     *   rs.close();<a name="line.39"></a>
<font color="green">040</font>     * &lt;/pre&gt;<a name="line.40"></a>
<font color="green">041</font>     *<a name="line.41"></a>
<font color="green">042</font>     * &lt;p&gt;Each column in the result set will be represented as a DynaBean<a name="line.42"></a>
<font color="green">043</font>     * property of the corresponding name (optionally forced to lower case<a name="line.43"></a>
<font color="green">044</font>     * for portability).&lt;/p&gt;<a name="line.44"></a>
<font color="green">045</font>     *<a name="line.45"></a>
<font color="green">046</font>     * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - Any {@link DynaBean} instance returned by<a name="line.46"></a>
<font color="green">047</font>     * this class, or from the &lt;code&gt;Iterator&lt;/code&gt; returned by the<a name="line.47"></a>
<font color="green">048</font>     * &lt;code&gt;iterator()&lt;/code&gt; method, is directly linked to the row that the<a name="line.48"></a>
<font color="green">049</font>     * underlying result set is currently positioned at.  This has the following<a name="line.49"></a>
<font color="green">050</font>     * implications:&lt;/p&gt;<a name="line.50"></a>
<font color="green">051</font>     * &lt;ul&gt;<a name="line.51"></a>
<font color="green">052</font>     * &lt;li&gt;Once you retrieve a different {@link DynaBean} instance, you should<a name="line.52"></a>
<font color="green">053</font>     *     no longer use any previous instance.&lt;/li&gt;<a name="line.53"></a>
<font color="green">054</font>     * &lt;li&gt;Changing the position of the underlying result set will change the<a name="line.54"></a>
<font color="green">055</font>     *     data that the {@link DynaBean} references.&lt;/li&gt;<a name="line.55"></a>
<font color="green">056</font>     * &lt;li&gt;Once the underlying result set is closed, the {@link DynaBean}<a name="line.56"></a>
<font color="green">057</font>     *     instance may no longer be used.&lt;/li&gt;<a name="line.57"></a>
<font color="green">058</font>     * &lt;/ul&gt;<a name="line.58"></a>
<font color="green">059</font>     *<a name="line.59"></a>
<font color="green">060</font>     * &lt;p&gt;Any database data that you wish to utilize outside the context of the<a name="line.60"></a>
<font color="green">061</font>     * current row of an open result set must be copied.  For example, you could<a name="line.61"></a>
<font color="green">062</font>     * use the following code to create standalone copies of the information in<a name="line.62"></a>
<font color="green">063</font>     * a result set:&lt;/p&gt;<a name="line.63"></a>
<font color="green">064</font>     * &lt;pre&gt;<a name="line.64"></a>
<font color="green">065</font>     *   ArrayList results = new ArrayList(); // To hold copied list<a name="line.65"></a>
<font color="green">066</font>     *   ResultSetDynaClass rsdc = ...;<a name="line.66"></a>
<font color="green">067</font>     *   DynaProperty[] properties = rsdc.getDynaProperties();<a name="line.67"></a>
<font color="green">068</font>     *   BasicDynaClass bdc =<a name="line.68"></a>
<font color="green">069</font>     *     new BasicDynaClass("foo", BasicDynaBean.class,<a name="line.69"></a>
<font color="green">070</font>     *                        rsdc.getDynaProperties());<a name="line.70"></a>
<font color="green">071</font>     *   Iterator rows = rsdc.iterator();<a name="line.71"></a>
<font color="green">072</font>     *   while (rows.hasNext()) {<a name="line.72"></a>
<font color="green">073</font>     *     DynaBean oldRow = (DynaBean) rows.next();<a name="line.73"></a>
<font color="green">074</font>     *     DynaBean newRow = bdc.newInstance();<a name="line.74"></a>
<font color="green">075</font>     *     PropertyUtils.copyProperties(newRow, oldRow);<a name="line.75"></a>
<font color="green">076</font>     *     results.add(newRow);<a name="line.76"></a>
<font color="green">077</font>     *   }<a name="line.77"></a>
<font color="green">078</font>     * &lt;/pre&gt;<a name="line.78"></a>
<font color="green">079</font>     *<a name="line.79"></a>
<font color="green">080</font>     * @author Craig R. McClanahan<a name="line.80"></a>
<font color="green">081</font>     * @version $Revision: 926685 $ $Date: 2010-03-23 17:59:08 +0000 (Tue, 23 Mar 2010) $<a name="line.81"></a>
<font color="green">082</font>     */<a name="line.82"></a>
<font color="green">083</font>    <a name="line.83"></a>
<font color="green">084</font>    public class ResultSetDynaClass extends JDBCDynaClass implements DynaClass {<a name="line.84"></a>
<font color="green">085</font>    <a name="line.85"></a>
<font color="green">086</font>    <a name="line.86"></a>
<font color="green">087</font>        // ----------------------------------------------------------- Constructors<a name="line.87"></a>
<font color="green">088</font>    <a name="line.88"></a>
<font color="green">089</font>    <a name="line.89"></a>
<font color="green">090</font>        /**<a name="line.90"></a>
<font color="green">091</font>         * &lt;p&gt;Construct a new ResultSetDynaClass for the specified<a name="line.91"></a>
<font color="green">092</font>         * &lt;code&gt;ResultSet&lt;/code&gt;.  The property names corresponding<a name="line.92"></a>
<font color="green">093</font>         * to column names in the result set will be lower cased.&lt;/p&gt;<a name="line.93"></a>
<font color="green">094</font>         *<a name="line.94"></a>
<font color="green">095</font>         * @param resultSet The result set to be wrapped<a name="line.95"></a>
<font color="green">096</font>         *<a name="line.96"></a>
<font color="green">097</font>         * @exception NullPointerException if &lt;code&gt;resultSet&lt;/code&gt;<a name="line.97"></a>
<font color="green">098</font>         *  is &lt;code&gt;null&lt;/code&gt;<a name="line.98"></a>
<font color="green">099</font>         * @exception SQLException if the metadata for this result set<a name="line.99"></a>
<font color="green">100</font>         *  cannot be introspected<a name="line.100"></a>
<font color="green">101</font>         */<a name="line.101"></a>
<font color="green">102</font>        public ResultSetDynaClass(ResultSet resultSet) throws SQLException {<a name="line.102"></a>
<font color="green">103</font>    <a name="line.103"></a>
<font color="green">104</font>            this(resultSet, true);<a name="line.104"></a>
<font color="green">105</font>    <a name="line.105"></a>
<font color="green">106</font>        }<a name="line.106"></a>
<font color="green">107</font>    <a name="line.107"></a>
<font color="green">108</font>    <a name="line.108"></a>
<font color="green">109</font>        /**<a name="line.109"></a>
<font color="green">110</font>         * &lt;p&gt;Construct a new ResultSetDynaClass for the specified<a name="line.110"></a>
<font color="green">111</font>         * &lt;code&gt;ResultSet&lt;/code&gt;.  The property names corresponding<a name="line.111"></a>
<font color="green">112</font>         * to the column names in the result set will be lower cased or not,<a name="line.112"></a>
<font color="green">113</font>         * depending on the specified &lt;code&gt;lowerCase&lt;/code&gt; value.&lt;/p&gt;<a name="line.113"></a>
<font color="green">114</font>         *<a name="line.114"></a>
<font color="green">115</font>         * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - If you specify &lt;code&gt;false&lt;/code&gt;<a name="line.115"></a>
<font color="green">116</font>         * for &lt;code&gt;lowerCase&lt;/code&gt;, the returned property names will<a name="line.116"></a>
<font color="green">117</font>         * exactly match the column names returned by your JDBC driver.<a name="line.117"></a>
<font color="green">118</font>         * Because different drivers might return column names in different<a name="line.118"></a>
<font color="green">119</font>         * cases, the property names seen by your application will vary<a name="line.119"></a>
<font color="green">120</font>         * depending on which JDBC driver you are using.&lt;/p&gt;<a name="line.120"></a>
<font color="green">121</font>         *<a name="line.121"></a>
<font color="green">122</font>         * @param resultSet The result set to be wrapped<a name="line.122"></a>
<font color="green">123</font>         * @param lowerCase Should property names be lower cased?<a name="line.123"></a>
<font color="green">124</font>         *<a name="line.124"></a>
<font color="green">125</font>         * @exception NullPointerException if &lt;code&gt;resultSet&lt;/code&gt;<a name="line.125"></a>
<font color="green">126</font>         *  is &lt;code&gt;null&lt;/code&gt;<a name="line.126"></a>
<font color="green">127</font>         * @exception SQLException if the metadata for this result set<a name="line.127"></a>
<font color="green">128</font>         *  cannot be introspected<a name="line.128"></a>
<font color="green">129</font>         */<a name="line.129"></a>
<font color="green">130</font>        public ResultSetDynaClass(ResultSet resultSet, boolean lowerCase)<a name="line.130"></a>
<font color="green">131</font>            throws SQLException {<a name="line.131"></a>
<font color="green">132</font>    <a name="line.132"></a>
<font color="green">133</font>            this(resultSet, lowerCase, false);<a name="line.133"></a>
<font color="green">134</font>    <a name="line.134"></a>
<font color="green">135</font>        }<a name="line.135"></a>
<font color="green">136</font>    <a name="line.136"></a>
<font color="green">137</font>    <a name="line.137"></a>
<font color="green">138</font>        /**<a name="line.138"></a>
<font color="green">139</font>         * &lt;p&gt;Construct a new ResultSetDynaClass for the specified<a name="line.139"></a>
<font color="green">140</font>         * &lt;code&gt;ResultSet&lt;/code&gt;.  The property names corresponding<a name="line.140"></a>
<font color="green">141</font>         * to the column names in the result set will be lower cased or not,<a name="line.141"></a>
<font color="green">142</font>         * depending on the specified &lt;code&gt;lowerCase&lt;/code&gt; value.&lt;/p&gt;<a name="line.142"></a>
<font color="green">143</font>         *<a name="line.143"></a>
<font color="green">144</font>         * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - If you specify &lt;code&gt;false&lt;/code&gt;<a name="line.144"></a>
<font color="green">145</font>         * for &lt;code&gt;lowerCase&lt;/code&gt;, the returned property names will<a name="line.145"></a>
<font color="green">146</font>         * exactly match the column names returned by your JDBC driver.<a name="line.146"></a>
<font color="green">147</font>         * Because different drivers might return column names in different<a name="line.147"></a>
<font color="green">148</font>         * cases, the property names seen by your application will vary<a name="line.148"></a>
<font color="green">149</font>         * depending on which JDBC driver you are using.&lt;/p&gt;<a name="line.149"></a>
<font color="green">150</font>         *<a name="line.150"></a>
<font color="green">151</font>         * @param resultSet The result set to be wrapped<a name="line.151"></a>
<font color="green">152</font>         * @param lowerCase Should property names be lower cased?<a name="line.152"></a>
<font color="green">153</font>         * @param useColumnLabel true if the column label should be used, otherwise false<a name="line.153"></a>
<font color="green">154</font>         *<a name="line.154"></a>
<font color="green">155</font>         * @exception NullPointerException if &lt;code&gt;resultSet&lt;/code&gt;<a name="line.155"></a>
<font color="green">156</font>         *  is &lt;code&gt;null&lt;/code&gt;<a name="line.156"></a>
<font color="green">157</font>         * @exception SQLException if the metadata for this result set<a name="line.157"></a>
<font color="green">158</font>         *  cannot be introspected<a name="line.158"></a>
<font color="green">159</font>         * @since 1.8.3<a name="line.159"></a>
<font color="green">160</font>         */<a name="line.160"></a>
<font color="green">161</font>        public ResultSetDynaClass(ResultSet resultSet, boolean lowerCase, boolean useColumnLabel)<a name="line.161"></a>
<font color="green">162</font>            throws SQLException {<a name="line.162"></a>
<font color="green">163</font>    <a name="line.163"></a>
<font color="green">164</font>            if (resultSet == null) {<a name="line.164"></a>
<font color="green">165</font>                throw new NullPointerException();<a name="line.165"></a>
<font color="green">166</font>            }<a name="line.166"></a>
<font color="green">167</font>            this.resultSet = resultSet;<a name="line.167"></a>
<font color="green">168</font>            this.lowerCase = lowerCase;<a name="line.168"></a>
<font color="green">169</font>            setUseColumnLabel(useColumnLabel);<a name="line.169"></a>
<font color="green">170</font>            introspect(resultSet);<a name="line.170"></a>
<font color="green">171</font>    <a name="line.171"></a>
<font color="green">172</font>        }<a name="line.172"></a>
<font color="green">173</font>    <a name="line.173"></a>
<font color="green">174</font>    <a name="line.174"></a>
<font color="green">175</font>        // ----------------------------------------------------- Instance Variables<a name="line.175"></a>
<font color="green">176</font>    <a name="line.176"></a>
<font color="green">177</font>    <a name="line.177"></a>
<font color="green">178</font>        /**<a name="line.178"></a>
<font color="green">179</font>         * &lt;p&gt;The &lt;code&gt;ResultSet&lt;/code&gt; we are wrapping.&lt;/p&gt;<a name="line.179"></a>
<font color="green">180</font>         */<a name="line.180"></a>
<font color="green">181</font>        protected ResultSet resultSet = null;<a name="line.181"></a>
<font color="green">182</font>    <a name="line.182"></a>
<font color="green">183</font>    <a name="line.183"></a>
<font color="green">184</font>        // --------------------------------------------------------- Public Methods<a name="line.184"></a>
<font color="green">185</font>    <a name="line.185"></a>
<font color="green">186</font>    <a name="line.186"></a>
<font color="green">187</font>        /**<a name="line.187"></a>
<font color="green">188</font>         * &lt;p&gt;Return an &lt;code&gt;Iterator&lt;/code&gt; of {@link DynaBean} instances for<a name="line.188"></a>
<font color="green">189</font>         * each row of the wrapped &lt;code&gt;ResultSet&lt;/code&gt;, in "forward" order.<a name="line.189"></a>
<font color="green">190</font>         * Unless the underlying result set supports scrolling, this method<a name="line.190"></a>
<font color="green">191</font>         * should be called only once.&lt;/p&gt;<a name="line.191"></a>
<font color="green">192</font>         * @return An &lt;code&gt;Iterator&lt;/code&gt; of {@link DynaBean} instances<a name="line.192"></a>
<font color="green">193</font>         */<a name="line.193"></a>
<font color="green">194</font>        public Iterator iterator() {<a name="line.194"></a>
<font color="green">195</font>    <a name="line.195"></a>
<font color="green">196</font>            return (new ResultSetIterator(this));<a name="line.196"></a>
<font color="green">197</font>    <a name="line.197"></a>
<font color="green">198</font>        }<a name="line.198"></a>
<font color="green">199</font>    <a name="line.199"></a>
<font color="green">200</font>    <a name="line.200"></a>
<font color="green">201</font>        /**<a name="line.201"></a>
<font color="green">202</font>         * Get a value from the {@link ResultSet} for the specified<a name="line.202"></a>
<font color="green">203</font>         * property name.<a name="line.203"></a>
<font color="green">204</font>         *<a name="line.204"></a>
<font color="green">205</font>         * @param name The property name<a name="line.205"></a>
<font color="green">206</font>         * @return The value<a name="line.206"></a>
<font color="green">207</font>         * @throws SQLException if an error occurs<a name="line.207"></a>
<font color="green">208</font>         * @since 1.8.0<a name="line.208"></a>
<font color="green">209</font>         */<a name="line.209"></a>
<font color="green">210</font>        public Object getObjectFromResultSet(String name) throws SQLException {<a name="line.210"></a>
<font color="green">211</font>            return getObject(getResultSet(), name);<a name="line.211"></a>
<font color="green">212</font>        }<a name="line.212"></a>
<font color="green">213</font>    <a name="line.213"></a>
<font color="green">214</font>        // -------------------------------------------------------- Package Methods<a name="line.214"></a>
<font color="green">215</font>    <a name="line.215"></a>
<font color="green">216</font>    <a name="line.216"></a>
<font color="green">217</font>        /**<a name="line.217"></a>
<font color="green">218</font>         * &lt;p&gt;Return the result set we are wrapping.&lt;/p&gt;<a name="line.218"></a>
<font color="green">219</font>         */<a name="line.219"></a>
<font color="green">220</font>        ResultSet getResultSet() {<a name="line.220"></a>
<font color="green">221</font>    <a name="line.221"></a>
<font color="green">222</font>            return (this.resultSet);<a name="line.222"></a>
<font color="green">223</font>    <a name="line.223"></a>
<font color="green">224</font>        }<a name="line.224"></a>
<font color="green">225</font>    <a name="line.225"></a>
<font color="green">226</font>    <a name="line.226"></a>
<font color="green">227</font>        // ------------------------------------------------------ Protected Methods<a name="line.227"></a>
<font color="green">228</font>        <a name="line.228"></a>
<font color="green">229</font>        /**<a name="line.229"></a>
<font color="green">230</font>         * &lt;p&gt;Loads the class of the given name which by default uses the class loader used <a name="line.230"></a>
<font color="green">231</font>         * to load this library.<a name="line.231"></a>
<font color="green">232</font>         * Dervations of this class could implement alternative class loading policies such as<a name="line.232"></a>
<font color="green">233</font>         * using custom ClassLoader or using the Threads's context class loader etc.<a name="line.233"></a>
<font color="green">234</font>         * &lt;/p&gt;<a name="line.234"></a>
<font color="green">235</font>         * @param className The name of the class to load<a name="line.235"></a>
<font color="green">236</font>         * @return The loaded class<a name="line.236"></a>
<font color="green">237</font>         * @throws SQLException if the class cannot be loaded<a name="line.237"></a>
<font color="green">238</font>         */        <a name="line.238"></a>
<font color="green">239</font>        protected Class loadClass(String className) throws SQLException {<a name="line.239"></a>
<font color="green">240</font>    <a name="line.240"></a>
<font color="green">241</font>            try {<a name="line.241"></a>
<font color="green">242</font>                return getClass().getClassLoader().loadClass(className);<a name="line.242"></a>
<font color="green">243</font>            } <a name="line.243"></a>
<font color="green">244</font>            catch (Exception e) {<a name="line.244"></a>
<font color="green">245</font>                throw new SQLException("Cannot load column class '" +<a name="line.245"></a>
<font color="green">246</font>                                       className + "': " + e);<a name="line.246"></a>
<font color="green">247</font>            }<a name="line.247"></a>
<font color="green">248</font>        }<a name="line.248"></a>
<font color="green">249</font>    }<a name="line.249"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/PropertyUtilsBean/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/PropertyUtilsBean/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:14:01" itemprop="dateModified" datetime="2010-03-24T17:14:01+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>    <a name="line.17"></a>
<font color="green">018</font>    package org.apache.commons.beanutils;<a name="line.18"></a>
<font color="green">019</font>    <a name="line.19"></a>
<font color="green">020</font>    <a name="line.20"></a>
<font color="green">021</font>    import java.beans.BeanInfo;<a name="line.21"></a>
<font color="green">022</font>    import java.beans.IndexedPropertyDescriptor;<a name="line.22"></a>
<font color="green">023</font>    import java.beans.IntrospectionException;<a name="line.23"></a>
<font color="green">024</font>    import java.beans.Introspector;<a name="line.24"></a>
<font color="green">025</font>    import java.beans.PropertyDescriptor;<a name="line.25"></a>
<font color="green">026</font>    import java.lang.reflect.Array;<a name="line.26"></a>
<font color="green">027</font>    import java.lang.reflect.InvocationTargetException;<a name="line.27"></a>
<font color="green">028</font>    import java.lang.reflect.Method;<a name="line.28"></a>
<font color="green">029</font>    import java.util.HashMap;<a name="line.29"></a>
<font color="green">030</font>    import java.util.Iterator;<a name="line.30"></a>
<font color="green">031</font>    import java.util.List;<a name="line.31"></a>
<font color="green">032</font>    import java.util.Map;<a name="line.32"></a>
<font color="green">033</font>    <a name="line.33"></a>
<font color="green">034</font>    import org.apache.commons.beanutils.expression.DefaultResolver;<a name="line.34"></a>
<font color="green">035</font>    import org.apache.commons.beanutils.expression.Resolver;<a name="line.35"></a>
<font color="green">036</font>    import org.apache.commons.collections.FastHashMap;<a name="line.36"></a>
<font color="green">037</font>    import org.apache.commons.logging.Log;<a name="line.37"></a>
<font color="green">038</font>    import org.apache.commons.logging.LogFactory;<a name="line.38"></a>
<font color="green">039</font>    <a name="line.39"></a>
<font color="green">040</font>    <a name="line.40"></a>
<font color="green">041</font>    /**<a name="line.41"></a>
<font color="green">042</font>     * Utility methods for using Java Reflection APIs to facilitate generic<a name="line.42"></a>
<font color="green">043</font>     * property getter and setter operations on Java objects.  Much of this<a name="line.43"></a>
<font color="green">044</font>     * code was originally included in &lt;code&gt;BeanUtils&lt;/code&gt;, but has been<a name="line.44"></a>
<font color="green">045</font>     * separated because of the volume of code involved.<a name="line.45"></a>
<font color="green">046</font>     * &lt;p&gt;<a name="line.46"></a>
<font color="green">047</font>     * In general, the objects that are examined and modified using these<a name="line.47"></a>
<font color="green">048</font>     * methods are expected to conform to the property getter and setter method<a name="line.48"></a>
<font color="green">049</font>     * naming conventions described in the JavaBeans Specification (Version 1.0.1).<a name="line.49"></a>
<font color="green">050</font>     * No data type conversions are performed, and there are no usage of any<a name="line.50"></a>
<font color="green">051</font>     * &lt;code&gt;PropertyEditor&lt;/code&gt; classes that have been registered, although<a name="line.51"></a>
<font color="green">052</font>     * a convenient way to access the registered classes themselves is included.<a name="line.52"></a>
<font color="green">053</font>     * &lt;p&gt;<a name="line.53"></a>
<font color="green">054</font>     * For the purposes of this class, five formats for referencing a particular<a name="line.54"></a>
<font color="green">055</font>     * property value of a bean are defined, with the &lt;i&gt;default&lt;/i&gt; layout of an<a name="line.55"></a>
<font color="green">056</font>     * identifying String in parentheses. However the notation for these formats<a name="line.56"></a>
<font color="green">057</font>     * and how they are resolved is now (since BeanUtils 1.8.0) controlled by<a name="line.57"></a>
<font color="green">058</font>     * the configured {@link Resolver} implementation:<a name="line.58"></a>
<font color="green">059</font>     * &lt;ul&gt;<a name="line.59"></a>
<font color="green">060</font>     * &lt;li&gt;&lt;strong&gt;Simple (&lt;code&gt;name&lt;/code&gt;)&lt;/strong&gt; - The specified<a name="line.60"></a>
<font color="green">061</font>     *     &lt;code&gt;name&lt;/code&gt; identifies an individual property of a particular<a name="line.61"></a>
<font color="green">062</font>     *     JavaBean.  The name of the actual getter or setter method to be used<a name="line.62"></a>
<font color="green">063</font>     *     is determined using standard JavaBeans instrospection, so that (unless<a name="line.63"></a>
<font color="green">064</font>     *     overridden by a &lt;code&gt;BeanInfo&lt;/code&gt; class, a property named "xyz"<a name="line.64"></a>
<font color="green">065</font>     *     will have a getter method named &lt;code&gt;getXyz()&lt;/code&gt; or (for boolean<a name="line.65"></a>
<font color="green">066</font>     *     properties only) &lt;code&gt;isXyz()&lt;/code&gt;, and a setter method named<a name="line.66"></a>
<font color="green">067</font>     *     &lt;code&gt;setXyz()&lt;/code&gt;.&lt;/li&gt;<a name="line.67"></a>
<font color="green">068</font>     * &lt;li&gt;&lt;strong&gt;Nested (&lt;code&gt;name1.name2.name3&lt;/code&gt;)&lt;/strong&gt; The first<a name="line.68"></a>
<font color="green">069</font>     *     name element is used to select a property getter, as for simple<a name="line.69"></a>
<font color="green">070</font>     *     references above.  The object returned for this property is then<a name="line.70"></a>
<font color="green">071</font>     *     consulted, using the same approach, for a property getter for a<a name="line.71"></a>
<font color="green">072</font>     *     property named &lt;code&gt;name2&lt;/code&gt;, and so on.  The property value that<a name="line.72"></a>
<font color="green">073</font>     *     is ultimately retrieved or modified is the one identified by the<a name="line.73"></a>
<font color="green">074</font>     *     last name element.&lt;/li&gt;<a name="line.74"></a>
<font color="green">075</font>     * &lt;li&gt;&lt;strong&gt;Indexed (&lt;code&gt;name[index]&lt;/code&gt;)&lt;/strong&gt; - The underlying<a name="line.75"></a>
<font color="green">076</font>     *     property value is assumed to be an array, or this JavaBean is assumed<a name="line.76"></a>
<font color="green">077</font>     *     to have indexed property getter and setter methods.  The appropriate<a name="line.77"></a>
<font color="green">078</font>     *     (zero-relative) entry in the array is selected.  &lt;code&gt;List&lt;/code&gt;<a name="line.78"></a>
<font color="green">079</font>     *     objects are now also supported for read/write.  You simply need to define<a name="line.79"></a>
<font color="green">080</font>     *     a getter that returns the &lt;code&gt;List&lt;/code&gt;&lt;/li&gt;<a name="line.80"></a>
<font color="green">081</font>     * &lt;li&gt;&lt;strong&gt;Mapped (&lt;code&gt;name(key)&lt;/code&gt;)&lt;/strong&gt; - The JavaBean<a name="line.81"></a>
<font color="green">082</font>     *     is assumed to have an property getter and setter methods with an<a name="line.82"></a>
<font color="green">083</font>     *     additional attribute of type &lt;code&gt;java.lang.String&lt;/code&gt;.&lt;/li&gt;<a name="line.83"></a>
<font color="green">084</font>     * &lt;li&gt;&lt;strong&gt;Combined (&lt;code&gt;name1.name2[index].name3(key)&lt;/code&gt;)&lt;/strong&gt; -<a name="line.84"></a>
<font color="green">085</font>     *     Combining mapped, nested, and indexed references is also<a name="line.85"></a>
<font color="green">086</font>     *     supported.&lt;/li&gt;<a name="line.86"></a>
<font color="green">087</font>     * &lt;/ul&gt;<a name="line.87"></a>
<font color="green">088</font>     *<a name="line.88"></a>
<font color="green">089</font>     * @author Craig R. McClanahan<a name="line.89"></a>
<font color="green">090</font>     * @author Ralph Schaer<a name="line.90"></a>
<font color="green">091</font>     * @author Chris Audley<a name="line.91"></a>
<font color="green">092</font>     * @author Rey Francois<a name="line.92"></a>
<font color="green">093</font>     * @author Gregor Rayman<a name="line.93"></a>
<font color="green">094</font>     * @author Jan Sorensen<a name="line.94"></a>
<font color="green">095</font>     * @author Scott Sanders<a name="line.95"></a>
<font color="green">096</font>     * @author Erik Meade<a name="line.96"></a>
<font color="green">097</font>     * @version $Revision: 822777 $ $Date: 2009-10-07 16:23:23 +0100 (Wed, 07 Oct 2009) $<a name="line.97"></a>
<font color="green">098</font>     * @see Resolver<a name="line.98"></a>
<font color="green">099</font>     * @see PropertyUtils<a name="line.99"></a>
<font color="green">100</font>     * @since 1.7<a name="line.100"></a>
<font color="green">101</font>     */<a name="line.101"></a>
<font color="green">102</font>    <a name="line.102"></a>
<font color="green">103</font>    public class PropertyUtilsBean {<a name="line.103"></a>
<font color="green">104</font>    <a name="line.104"></a>
<font color="green">105</font>        private Resolver resolver = new DefaultResolver();<a name="line.105"></a>
<font color="green">106</font>    <a name="line.106"></a>
<font color="green">107</font>        // --------------------------------------------------------- Class Methods<a name="line.107"></a>
<font color="green">108</font>    <a name="line.108"></a>
<font color="green">109</font>        /**<a name="line.109"></a>
<font color="green">110</font>         * Return the PropertyUtils bean instance.<a name="line.110"></a>
<font color="green">111</font>         * @return The PropertyUtils bean instance<a name="line.111"></a>
<font color="green">112</font>         */<a name="line.112"></a>
<font color="green">113</font>        protected static PropertyUtilsBean getInstance() {<a name="line.113"></a>
<font color="green">114</font>            return BeanUtilsBean.getInstance().getPropertyUtils();<a name="line.114"></a>
<font color="green">115</font>        }<a name="line.115"></a>
<font color="green">116</font>    <a name="line.116"></a>
<font color="green">117</font>        // --------------------------------------------------------- Variables<a name="line.117"></a>
<font color="green">118</font>    <a name="line.118"></a>
<font color="green">119</font>        /**<a name="line.119"></a>
<font color="green">120</font>         * The cache of PropertyDescriptor arrays for beans we have already<a name="line.120"></a>
<font color="green">121</font>         * introspected, keyed by the java.lang.Class of this object.<a name="line.121"></a>
<font color="green">122</font>         */<a name="line.122"></a>
<font color="green">123</font>        private WeakFastHashMap descriptorsCache = null;<a name="line.123"></a>
<font color="green">124</font>        private WeakFastHashMap mappedDescriptorsCache = null;<a name="line.124"></a>
<font color="green">125</font>        private static final Class[] EMPTY_CLASS_PARAMETERS = new Class[0];<a name="line.125"></a>
<font color="green">126</font>        private static final Class[] LIST_CLASS_PARAMETER = new Class[] {java.util.List.class};<a name="line.126"></a>
<font color="green">127</font>        <a name="line.127"></a>
<font color="green">128</font>        /** An empty object array */<a name="line.128"></a>
<font color="green">129</font>        private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];<a name="line.129"></a>
<font color="green">130</font>    <a name="line.130"></a>
<font color="green">131</font>        /** Log instance */<a name="line.131"></a>
<font color="green">132</font>        private Log log = LogFactory.getLog(PropertyUtils.class);<a name="line.132"></a>
<font color="green">133</font>        <a name="line.133"></a>
<font color="green">134</font>        // ---------------------------------------------------------- Constructors<a name="line.134"></a>
<font color="green">135</font>        <a name="line.135"></a>
<font color="green">136</font>        /** Base constructor */<a name="line.136"></a>
<font color="green">137</font>        public PropertyUtilsBean() {<a name="line.137"></a>
<font color="green">138</font>            descriptorsCache = new WeakFastHashMap();<a name="line.138"></a>
<font color="green">139</font>            descriptorsCache.setFast(true);<a name="line.139"></a>
<font color="green">140</font>            mappedDescriptorsCache = new WeakFastHashMap();<a name="line.140"></a>
<font color="green">141</font>            mappedDescriptorsCache.setFast(true);<a name="line.141"></a>
<font color="green">142</font>        }<a name="line.142"></a>
<font color="green">143</font>    <a name="line.143"></a>
<font color="green">144</font>    <a name="line.144"></a>
<font color="green">145</font>        // --------------------------------------------------------- Public Methods<a name="line.145"></a>
<font color="green">146</font>    <a name="line.146"></a>
<font color="green">147</font>    <a name="line.147"></a>
<font color="green">148</font>        /**<a name="line.148"></a>
<font color="green">149</font>         * Return the configured {@link Resolver} implementation used by BeanUtils.<a name="line.149"></a>
<font color="green">150</font>         * &lt;p&gt;<a name="line.150"></a>
<font color="green">151</font>         * The {@link Resolver} handles the &lt;i&gt;property name&lt;/i&gt;<a name="line.151"></a>
<font color="green">152</font>         * expressions and the implementation in use effectively<a name="line.152"></a>
<font color="green">153</font>         * controls the dialect of the &lt;i&gt;expression language&lt;/i&gt;<a name="line.153"></a>
<font color="green">154</font>         * that BeanUtils recongnises.<a name="line.154"></a>
<font color="green">155</font>         * &lt;p&gt;<a name="line.155"></a>
<font color="green">156</font>         * {@link DefaultResolver} is the default implementation used.<a name="line.156"></a>
<font color="green">157</font>         *<a name="line.157"></a>
<font color="green">158</font>         * @return resolver The property expression resolver.<a name="line.158"></a>
<font color="green">159</font>         * @since 1.8.0<a name="line.159"></a>
<font color="green">160</font>         */<a name="line.160"></a>
<font color="green">161</font>        public Resolver getResolver() {<a name="line.161"></a>
<font color="green">162</font>            return resolver;<a name="line.162"></a>
<font color="green">163</font>        }<a name="line.163"></a>
<font color="green">164</font>    <a name="line.164"></a>
<font color="green">165</font>        /**<a name="line.165"></a>
<font color="green">166</font>         * Configure the {@link Resolver} implementation used by BeanUtils.<a name="line.166"></a>
<font color="green">167</font>         * &lt;p&gt;<a name="line.167"></a>
<font color="green">168</font>         * The {@link Resolver} handles the &lt;i&gt;property name&lt;/i&gt;<a name="line.168"></a>
<font color="green">169</font>         * expressions and the implementation in use effectively<a name="line.169"></a>
<font color="green">170</font>         * controls the dialect of the &lt;i&gt;expression language&lt;/i&gt;<a name="line.170"></a>
<font color="green">171</font>         * that BeanUtils recongnises.<a name="line.171"></a>
<font color="green">172</font>         * &lt;p&gt;<a name="line.172"></a>
<font color="green">173</font>         * {@link DefaultResolver} is the default implementation used.<a name="line.173"></a>
<font color="green">174</font>         *<a name="line.174"></a>
<font color="green">175</font>         * @param resolver The property expression resolver.<a name="line.175"></a>
<font color="green">176</font>         * @since 1.8.0<a name="line.176"></a>
<font color="green">177</font>         */<a name="line.177"></a>
<font color="green">178</font>        public void setResolver(Resolver resolver) {<a name="line.178"></a>
<font color="green">179</font>            if (resolver == null) {<a name="line.179"></a>
<font color="green">180</font>                this.resolver = new DefaultResolver();<a name="line.180"></a>
<font color="green">181</font>            } else {<a name="line.181"></a>
<font color="green">182</font>                this.resolver = resolver;<a name="line.182"></a>
<font color="green">183</font>            }<a name="line.183"></a>
<font color="green">184</font>        }<a name="line.184"></a>
<font color="green">185</font>    <a name="line.185"></a>
<font color="green">186</font>        /**<a name="line.186"></a>
<font color="green">187</font>         * Clear any cached property descriptors information for all classes<a name="line.187"></a>
<font color="green">188</font>         * loaded by any class loaders.  This is useful in cases where class<a name="line.188"></a>
<font color="green">189</font>         * loaders are thrown away to implement class reloading.<a name="line.189"></a>
<font color="green">190</font>         */<a name="line.190"></a>
<font color="green">191</font>        public void clearDescriptors() {<a name="line.191"></a>
<font color="green">192</font>    <a name="line.192"></a>
<font color="green">193</font>            descriptorsCache.clear();<a name="line.193"></a>
<font color="green">194</font>            mappedDescriptorsCache.clear();<a name="line.194"></a>
<font color="green">195</font>            Introspector.flushCaches();<a name="line.195"></a>
<font color="green">196</font>    <a name="line.196"></a>
<font color="green">197</font>        }<a name="line.197"></a>
<font color="green">198</font>    <a name="line.198"></a>
<font color="green">199</font>    <a name="line.199"></a>
<font color="green">200</font>        /**<a name="line.200"></a>
<font color="green">201</font>         * &lt;p&gt;Copy property values from the "origin" bean to the "destination" bean<a name="line.201"></a>
<font color="green">202</font>         * for all cases where the property names are the same (even though the<a name="line.202"></a>
<font color="green">203</font>         * actual getter and setter methods might have been customized via<a name="line.203"></a>
<font color="green">204</font>         * &lt;code&gt;BeanInfo&lt;/code&gt; classes).  No conversions are performed on the<a name="line.204"></a>
<font color="green">205</font>         * actual property values -- it is assumed that the values retrieved from<a name="line.205"></a>
<font color="green">206</font>         * the origin bean are assignment-compatible with the types expected by<a name="line.206"></a>
<font color="green">207</font>         * the destination bean.&lt;/p&gt;<a name="line.207"></a>
<font color="green">208</font>         *<a name="line.208"></a>
<font color="green">209</font>         * &lt;p&gt;If the origin "bean" is actually a &lt;code&gt;Map&lt;/code&gt;, it is assumed<a name="line.209"></a>
<font color="green">210</font>         * to contain String-valued &lt;strong&gt;simple&lt;/strong&gt; property names as the keys, pointing<a name="line.210"></a>
<font color="green">211</font>         * at the corresponding property values that will be set in the destination<a name="line.211"></a>
<font color="green">212</font>         * bean.&lt;strong&gt;Note&lt;/strong&gt; that this method is intended to perform <a name="line.212"></a>
<font color="green">213</font>         * a "shallow copy" of the properties and so complex properties <a name="line.213"></a>
<font color="green">214</font>         * (for example, nested ones) will not be copied.&lt;/p&gt;<a name="line.214"></a>
<font color="green">215</font>         * <a name="line.215"></a>
<font color="green">216</font>         * &lt;p&gt;Note, that this method will not copy a List to a List, or an Object[] <a name="line.216"></a>
<font color="green">217</font>         * to an Object[]. It's specifically for copying JavaBean properties. &lt;/p&gt;<a name="line.217"></a>
<font color="green">218</font>         *<a name="line.218"></a>
<font color="green">219</font>         * @param dest Destination bean whose properties are modified<a name="line.219"></a>
<font color="green">220</font>         * @param orig Origin bean whose properties are retrieved<a name="line.220"></a>
<font color="green">221</font>         *<a name="line.221"></a>
<font color="green">222</font>         * @exception IllegalAccessException if the caller does not have<a name="line.222"></a>
<font color="green">223</font>         *  access to the property accessor method<a name="line.223"></a>
<font color="green">224</font>         * @exception IllegalArgumentException if the &lt;code&gt;dest&lt;/code&gt; or<a name="line.224"></a>
<font color="green">225</font>         *  &lt;code&gt;orig&lt;/code&gt; argument is null<a name="line.225"></a>
<font color="green">226</font>         * @exception InvocationTargetException if the property accessor method<a name="line.226"></a>
<font color="green">227</font>         *  throws an exception<a name="line.227"></a>
<font color="green">228</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.228"></a>
<font color="green">229</font>         *  propety cannot be found<a name="line.229"></a>
<font color="green">230</font>         */<a name="line.230"></a>
<font color="green">231</font>        public void copyProperties(Object dest, Object orig)<a name="line.231"></a>
<font color="green">232</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.232"></a>
<font color="green">233</font>                NoSuchMethodException {<a name="line.233"></a>
<font color="green">234</font>    <a name="line.234"></a>
<font color="green">235</font>            if (dest == null) {<a name="line.235"></a>
<font color="green">236</font>                throw new IllegalArgumentException<a name="line.236"></a>
<font color="green">237</font>                        ("No destination bean specified");<a name="line.237"></a>
<font color="green">238</font>            }<a name="line.238"></a>
<font color="green">239</font>            if (orig == null) {<a name="line.239"></a>
<font color="green">240</font>                throw new IllegalArgumentException("No origin bean specified");<a name="line.240"></a>
<font color="green">241</font>            }<a name="line.241"></a>
<font color="green">242</font>    <a name="line.242"></a>
<font color="green">243</font>            if (orig instanceof DynaBean) {<a name="line.243"></a>
<font color="green">244</font>                DynaProperty[] origDescriptors =<a name="line.244"></a>
<font color="green">245</font>                    ((DynaBean) orig).getDynaClass().getDynaProperties();<a name="line.245"></a>
<font color="green">246</font>                for (int i = 0; i &lt; origDescriptors.length; i++) {<a name="line.246"></a>
<font color="green">247</font>                    String name = origDescriptors[i].getName();<a name="line.247"></a>
<font color="green">248</font>                    if (isReadable(orig, name) &amp;&amp; isWriteable(dest, name)) {<a name="line.248"></a>
<font color="green">249</font>                        try {<a name="line.249"></a>
<font color="green">250</font>                            Object value = ((DynaBean) orig).get(name);<a name="line.250"></a>
<font color="green">251</font>                            if (dest instanceof DynaBean) {<a name="line.251"></a>
<font color="green">252</font>                                ((DynaBean) dest).set(name, value);<a name="line.252"></a>
<font color="green">253</font>                            } else {<a name="line.253"></a>
<font color="green">254</font>                                    setSimpleProperty(dest, name, value);<a name="line.254"></a>
<font color="green">255</font>                            }<a name="line.255"></a>
<font color="green">256</font>                        } catch (NoSuchMethodException e) {<a name="line.256"></a>
<font color="green">257</font>                            if (log.isDebugEnabled()) {<a name="line.257"></a>
<font color="green">258</font>                                log.debug("Error writing to '" + name + "' on class '" + dest.getClass() + "'", e);<a name="line.258"></a>
<font color="green">259</font>                            }<a name="line.259"></a>
<font color="green">260</font>                        }<a name="line.260"></a>
<font color="green">261</font>                    }<a name="line.261"></a>
<font color="green">262</font>                }<a name="line.262"></a>
<font color="green">263</font>            } else if (orig instanceof Map) {<a name="line.263"></a>
<font color="green">264</font>                Iterator entries = ((Map) orig).entrySet().iterator();<a name="line.264"></a>
<font color="green">265</font>                while (entries.hasNext()) {<a name="line.265"></a>
<font color="green">266</font>                    Map.Entry entry = (Map.Entry) entries.next();<a name="line.266"></a>
<font color="green">267</font>                    String name = (String)entry.getKey();<a name="line.267"></a>
<font color="green">268</font>                    if (isWriteable(dest, name)) {<a name="line.268"></a>
<font color="green">269</font>                        try {<a name="line.269"></a>
<font color="green">270</font>                            if (dest instanceof DynaBean) {<a name="line.270"></a>
<font color="green">271</font>                                ((DynaBean) dest).set(name, entry.getValue());<a name="line.271"></a>
<font color="green">272</font>                            } else {<a name="line.272"></a>
<font color="green">273</font>                                setSimpleProperty(dest, name, entry.getValue());<a name="line.273"></a>
<font color="green">274</font>                            }<a name="line.274"></a>
<font color="green">275</font>                        } catch (NoSuchMethodException e) {<a name="line.275"></a>
<font color="green">276</font>                            if (log.isDebugEnabled()) {<a name="line.276"></a>
<font color="green">277</font>                                log.debug("Error writing to '" + name + "' on class '" + dest.getClass() + "'", e);<a name="line.277"></a>
<font color="green">278</font>                            }<a name="line.278"></a>
<font color="green">279</font>                        }<a name="line.279"></a>
<font color="green">280</font>                    }<a name="line.280"></a>
<font color="green">281</font>                }<a name="line.281"></a>
<font color="green">282</font>            } else /* if (orig is a standard JavaBean) */ {<a name="line.282"></a>
<font color="green">283</font>                PropertyDescriptor[] origDescriptors =<a name="line.283"></a>
<font color="green">284</font>                    getPropertyDescriptors(orig);<a name="line.284"></a>
<font color="green">285</font>                for (int i = 0; i &lt; origDescriptors.length; i++) {<a name="line.285"></a>
<font color="green">286</font>                    String name = origDescriptors[i].getName();<a name="line.286"></a>
<font color="green">287</font>                    if (isReadable(orig, name) &amp;&amp; isWriteable(dest, name)) {<a name="line.287"></a>
<font color="green">288</font>                        try {<a name="line.288"></a>
<font color="green">289</font>                            Object value = getSimpleProperty(orig, name);<a name="line.289"></a>
<font color="green">290</font>                            if (dest instanceof DynaBean) {<a name="line.290"></a>
<font color="green">291</font>                                ((DynaBean) dest).set(name, value);<a name="line.291"></a>
<font color="green">292</font>                            } else {<a name="line.292"></a>
<font color="green">293</font>                                    setSimpleProperty(dest, name, value);<a name="line.293"></a>
<font color="green">294</font>                            }<a name="line.294"></a>
<font color="green">295</font>                        } catch (NoSuchMethodException e) {<a name="line.295"></a>
<font color="green">296</font>                            if (log.isDebugEnabled()) {<a name="line.296"></a>
<font color="green">297</font>                                log.debug("Error writing to '" + name + "' on class '" + dest.getClass() + "'", e);<a name="line.297"></a>
<font color="green">298</font>                            }<a name="line.298"></a>
<font color="green">299</font>                        }<a name="line.299"></a>
<font color="green">300</font>                    }<a name="line.300"></a>
<font color="green">301</font>                }<a name="line.301"></a>
<font color="green">302</font>            }<a name="line.302"></a>
<font color="green">303</font>    <a name="line.303"></a>
<font color="green">304</font>        }<a name="line.304"></a>
<font color="green">305</font>    <a name="line.305"></a>
<font color="green">306</font>    <a name="line.306"></a>
<font color="green">307</font>        /**<a name="line.307"></a>
<font color="green">308</font>         * &lt;p&gt;Return the entire set of properties for which the specified bean<a name="line.308"></a>
<font color="green">309</font>         * provides a read method.  This map contains the unconverted property<a name="line.309"></a>
<font color="green">310</font>         * values for all properties for which a read method is provided<a name="line.310"></a>
<font color="green">311</font>         * (i.e. where the &lt;code&gt;getReadMethod()&lt;/code&gt; returns non-null).&lt;/p&gt;<a name="line.311"></a>
<font color="green">312</font>         *<a name="line.312"></a>
<font color="green">313</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not account for mapped properties.&lt;/p&gt;<a name="line.313"></a>
<font color="green">314</font>         *<a name="line.314"></a>
<font color="green">315</font>         * @param bean Bean whose properties are to be extracted<a name="line.315"></a>
<font color="green">316</font>         * @return The set of properties for the bean<a name="line.316"></a>
<font color="green">317</font>         *<a name="line.317"></a>
<font color="green">318</font>         * @exception IllegalAccessException if the caller does not have<a name="line.318"></a>
<font color="green">319</font>         *  access to the property accessor method<a name="line.319"></a>
<font color="green">320</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; is null<a name="line.320"></a>
<font color="green">321</font>         * @exception InvocationTargetException if the property accessor method<a name="line.321"></a>
<font color="green">322</font>         *  throws an exception<a name="line.322"></a>
<font color="green">323</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.323"></a>
<font color="green">324</font>         *  propety cannot be found<a name="line.324"></a>
<font color="green">325</font>         */<a name="line.325"></a>
<font color="green">326</font>        public Map describe(Object bean)<a name="line.326"></a>
<font color="green">327</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.327"></a>
<font color="green">328</font>                NoSuchMethodException {<a name="line.328"></a>
<font color="green">329</font>    <a name="line.329"></a>
<font color="green">330</font>            if (bean == null) {<a name="line.330"></a>
<font color="green">331</font>                throw new IllegalArgumentException("No bean specified");<a name="line.331"></a>
<font color="green">332</font>            }<a name="line.332"></a>
<font color="green">333</font>            Map description = new HashMap();<a name="line.333"></a>
<font color="green">334</font>            if (bean instanceof DynaBean) {<a name="line.334"></a>
<font color="green">335</font>                DynaProperty[] descriptors =<a name="line.335"></a>
<font color="green">336</font>                    ((DynaBean) bean).getDynaClass().getDynaProperties();<a name="line.336"></a>
<font color="green">337</font>                for (int i = 0; i &lt; descriptors.length; i++) {<a name="line.337"></a>
<font color="green">338</font>                    String name = descriptors[i].getName();<a name="line.338"></a>
<font color="green">339</font>                    description.put(name, getProperty(bean, name));<a name="line.339"></a>
<font color="green">340</font>                }<a name="line.340"></a>
<font color="green">341</font>            } else {<a name="line.341"></a>
<font color="green">342</font>                PropertyDescriptor[] descriptors =<a name="line.342"></a>
<font color="green">343</font>                    getPropertyDescriptors(bean);<a name="line.343"></a>
<font color="green">344</font>                for (int i = 0; i &lt; descriptors.length; i++) {<a name="line.344"></a>
<font color="green">345</font>                    String name = descriptors[i].getName();<a name="line.345"></a>
<font color="green">346</font>                    if (descriptors[i].getReadMethod() != null) {<a name="line.346"></a>
<font color="green">347</font>                        description.put(name, getProperty(bean, name));<a name="line.347"></a>
<font color="green">348</font>                    }<a name="line.348"></a>
<font color="green">349</font>                }<a name="line.349"></a>
<font color="green">350</font>            }<a name="line.350"></a>
<font color="green">351</font>            return (description);<a name="line.351"></a>
<font color="green">352</font>    <a name="line.352"></a>
<font color="green">353</font>        }<a name="line.353"></a>
<font color="green">354</font>    <a name="line.354"></a>
<font color="green">355</font>    <a name="line.355"></a>
<font color="green">356</font>        /**<a name="line.356"></a>
<font color="green">357</font>         * Return the value of the specified indexed property of the specified<a name="line.357"></a>
<font color="green">358</font>         * bean, with no type conversions.  The zero-relative index of the<a name="line.358"></a>
<font color="green">359</font>         * required value must be included (in square brackets) as a suffix to<a name="line.359"></a>
<font color="green">360</font>         * the property name, or &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be<a name="line.360"></a>
<font color="green">361</font>         * thrown.  In addition to supporting the JavaBeans specification, this<a name="line.361"></a>
<font color="green">362</font>         * method has been extended to support &lt;code&gt;List&lt;/code&gt; objects as well.<a name="line.362"></a>
<font color="green">363</font>         *<a name="line.363"></a>
<font color="green">364</font>         * @param bean Bean whose property is to be extracted<a name="line.364"></a>
<font color="green">365</font>         * @param name &lt;code&gt;propertyname[index]&lt;/code&gt; of the property value<a name="line.365"></a>
<font color="green">366</font>         *  to be extracted<a name="line.366"></a>
<font color="green">367</font>         * @return the indexed property value<a name="line.367"></a>
<font color="green">368</font>         *<a name="line.368"></a>
<font color="green">369</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.369"></a>
<font color="green">370</font>         *  is outside the valid range for the underlying array or List<a name="line.370"></a>
<font color="green">371</font>         * @exception IllegalAccessException if the caller does not have<a name="line.371"></a>
<font color="green">372</font>         *  access to the property accessor method<a name="line.372"></a>
<font color="green">373</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.373"></a>
<font color="green">374</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.374"></a>
<font color="green">375</font>         * @exception InvocationTargetException if the property accessor method<a name="line.375"></a>
<font color="green">376</font>         *  throws an exception<a name="line.376"></a>
<font color="green">377</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.377"></a>
<font color="green">378</font>         *  propety cannot be found<a name="line.378"></a>
<font color="green">379</font>         */<a name="line.379"></a>
<font color="green">380</font>        public Object getIndexedProperty(Object bean, String name)<a name="line.380"></a>
<font color="green">381</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.381"></a>
<font color="green">382</font>                NoSuchMethodException {<a name="line.382"></a>
<font color="green">383</font>    <a name="line.383"></a>
<font color="green">384</font>            if (bean == null) {<a name="line.384"></a>
<font color="green">385</font>                throw new IllegalArgumentException("No bean specified");<a name="line.385"></a>
<font color="green">386</font>            }<a name="line.386"></a>
<font color="green">387</font>            if (name == null) {<a name="line.387"></a>
<font color="green">388</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.388"></a>
<font color="green">389</font>                        bean.getClass() + "'");<a name="line.389"></a>
<font color="green">390</font>            }<a name="line.390"></a>
<font color="green">391</font>    <a name="line.391"></a>
<font color="green">392</font>            // Identify the index of the requested individual property<a name="line.392"></a>
<font color="green">393</font>            int index = -1;<a name="line.393"></a>
<font color="green">394</font>            try {<a name="line.394"></a>
<font color="green">395</font>                index = resolver.getIndex(name);<a name="line.395"></a>
<font color="green">396</font>            } catch (IllegalArgumentException e) {<a name="line.396"></a>
<font color="green">397</font>                throw new IllegalArgumentException("Invalid indexed property '" +<a name="line.397"></a>
<font color="green">398</font>                        name + "' on bean class '" + bean.getClass() + "' " +<a name="line.398"></a>
<font color="green">399</font>                        e.getMessage());<a name="line.399"></a>
<font color="green">400</font>            }<a name="line.400"></a>
<font color="green">401</font>            if (index &lt; 0) {<a name="line.401"></a>
<font color="green">402</font>                throw new IllegalArgumentException("Invalid indexed property '" +<a name="line.402"></a>
<font color="green">403</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.403"></a>
<font color="green">404</font>            }<a name="line.404"></a>
<font color="green">405</font>    <a name="line.405"></a>
<font color="green">406</font>            // Isolate the name<a name="line.406"></a>
<font color="green">407</font>            name = resolver.getProperty(name);<a name="line.407"></a>
<font color="green">408</font>    <a name="line.408"></a>
<font color="green">409</font>            // Request the specified indexed property value<a name="line.409"></a>
<font color="green">410</font>            return (getIndexedProperty(bean, name, index));<a name="line.410"></a>
<font color="green">411</font>    <a name="line.411"></a>
<font color="green">412</font>        }<a name="line.412"></a>
<font color="green">413</font>    <a name="line.413"></a>
<font color="green">414</font>    <a name="line.414"></a>
<font color="green">415</font>        /**<a name="line.415"></a>
<font color="green">416</font>         * Return the value of the specified indexed property of the specified<a name="line.416"></a>
<font color="green">417</font>         * bean, with no type conversions.  In addition to supporting the JavaBeans<a name="line.417"></a>
<font color="green">418</font>         * specification, this method has been extended to support<a name="line.418"></a>
<font color="green">419</font>         * &lt;code&gt;List&lt;/code&gt; objects as well.<a name="line.419"></a>
<font color="green">420</font>         *<a name="line.420"></a>
<font color="green">421</font>         * @param bean Bean whose property is to be extracted<a name="line.421"></a>
<font color="green">422</font>         * @param name Simple property name of the property value to be extracted<a name="line.422"></a>
<font color="green">423</font>         * @param index Index of the property value to be extracted<a name="line.423"></a>
<font color="green">424</font>         * @return the indexed property value<a name="line.424"></a>
<font color="green">425</font>         *<a name="line.425"></a>
<font color="green">426</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.426"></a>
<font color="green">427</font>         *  is outside the valid range for the underlying property<a name="line.427"></a>
<font color="green">428</font>         * @exception IllegalAccessException if the caller does not have<a name="line.428"></a>
<font color="green">429</font>         *  access to the property accessor method<a name="line.429"></a>
<font color="green">430</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.430"></a>
<font color="green">431</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.431"></a>
<font color="green">432</font>         * @exception InvocationTargetException if the property accessor method<a name="line.432"></a>
<font color="green">433</font>         *  throws an exception<a name="line.433"></a>
<font color="green">434</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.434"></a>
<font color="green">435</font>         *  propety cannot be found<a name="line.435"></a>
<font color="green">436</font>         */<a name="line.436"></a>
<font color="green">437</font>        public Object getIndexedProperty(Object bean,<a name="line.437"></a>
<font color="green">438</font>                                                String name, int index)<a name="line.438"></a>
<font color="green">439</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.439"></a>
<font color="green">440</font>                NoSuchMethodException {<a name="line.440"></a>
<font color="green">441</font>    <a name="line.441"></a>
<font color="green">442</font>            if (bean == null) {<a name="line.442"></a>
<font color="green">443</font>                throw new IllegalArgumentException("No bean specified");<a name="line.443"></a>
<font color="green">444</font>            }<a name="line.444"></a>
<font color="green">445</font>            if (name == null || name.length() == 0) {<a name="line.445"></a>
<font color="green">446</font>                if (bean.getClass().isArray()) {<a name="line.446"></a>
<font color="green">447</font>                    return Array.get(bean, index);<a name="line.447"></a>
<font color="green">448</font>                } else if (bean instanceof List) {<a name="line.448"></a>
<font color="green">449</font>                    return ((List)bean).get(index);   <a name="line.449"></a>
<font color="green">450</font>                }<a name="line.450"></a>
<font color="green">451</font>            }<a name="line.451"></a>
<font color="green">452</font>            if (name == null) {<a name="line.452"></a>
<font color="green">453</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.453"></a>
<font color="green">454</font>                        bean.getClass() + "'");<a name="line.454"></a>
<font color="green">455</font>            }<a name="line.455"></a>
<font color="green">456</font>    <a name="line.456"></a>
<font color="green">457</font>            // Handle DynaBean instances specially<a name="line.457"></a>
<font color="green">458</font>            if (bean instanceof DynaBean) {<a name="line.458"></a>
<font color="green">459</font>                DynaProperty descriptor =<a name="line.459"></a>
<font color="green">460</font>                        ((DynaBean) bean).getDynaClass().getDynaProperty(name);<a name="line.460"></a>
<font color="green">461</font>                if (descriptor == null) {<a name="line.461"></a>
<font color="green">462</font>                    throw new NoSuchMethodException("Unknown property '" +<a name="line.462"></a>
<font color="green">463</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.463"></a>
<font color="green">464</font>                }<a name="line.464"></a>
<font color="green">465</font>                return (((DynaBean) bean).get(name, index));<a name="line.465"></a>
<font color="green">466</font>            }<a name="line.466"></a>
<font color="green">467</font>    <a name="line.467"></a>
<font color="green">468</font>            // Retrieve the property descriptor for the specified property<a name="line.468"></a>
<font color="green">469</font>            PropertyDescriptor descriptor =<a name="line.469"></a>
<font color="green">470</font>                    getPropertyDescriptor(bean, name);<a name="line.470"></a>
<font color="green">471</font>            if (descriptor == null) {<a name="line.471"></a>
<font color="green">472</font>                throw new NoSuchMethodException("Unknown property '" +<a name="line.472"></a>
<font color="green">473</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.473"></a>
<font color="green">474</font>            }<a name="line.474"></a>
<font color="green">475</font>    <a name="line.475"></a>
<font color="green">476</font>            // Call the indexed getter method if there is one<a name="line.476"></a>
<font color="green">477</font>            if (descriptor instanceof IndexedPropertyDescriptor) {<a name="line.477"></a>
<font color="green">478</font>                Method readMethod = ((IndexedPropertyDescriptor) descriptor).<a name="line.478"></a>
<font color="green">479</font>                        getIndexedReadMethod();<a name="line.479"></a>
<font color="green">480</font>                readMethod = MethodUtils.getAccessibleMethod(bean.getClass(), readMethod);<a name="line.480"></a>
<font color="green">481</font>                if (readMethod != null) {<a name="line.481"></a>
<font color="green">482</font>                    Object[] subscript = new Object[1];<a name="line.482"></a>
<font color="green">483</font>                    subscript[0] = new Integer(index);<a name="line.483"></a>
<font color="green">484</font>                    try {<a name="line.484"></a>
<font color="green">485</font>                        return (invokeMethod(readMethod,bean, subscript));<a name="line.485"></a>
<font color="green">486</font>                    } catch (InvocationTargetException e) {<a name="line.486"></a>
<font color="green">487</font>                        if (e.getTargetException() instanceof<a name="line.487"></a>
<font color="green">488</font>                                IndexOutOfBoundsException) {<a name="line.488"></a>
<font color="green">489</font>                            throw (IndexOutOfBoundsException)<a name="line.489"></a>
<font color="green">490</font>                                    e.getTargetException();<a name="line.490"></a>
<font color="green">491</font>                        } else {<a name="line.491"></a>
<font color="green">492</font>                            throw e;<a name="line.492"></a>
<font color="green">493</font>                        }<a name="line.493"></a>
<font color="green">494</font>                    }<a name="line.494"></a>
<font color="green">495</font>                }<a name="line.495"></a>
<font color="green">496</font>            }<a name="line.496"></a>
<font color="green">497</font>    <a name="line.497"></a>
<font color="green">498</font>            // Otherwise, the underlying property must be an array<a name="line.498"></a>
<font color="green">499</font>            Method readMethod = getReadMethod(bean.getClass(), descriptor);<a name="line.499"></a>
<font color="green">500</font>            if (readMethod == null) {<a name="line.500"></a>
<font color="green">501</font>                throw new NoSuchMethodException("Property '" + name + "' has no " +<a name="line.501"></a>
<font color="green">502</font>                        "getter method on bean class '" + bean.getClass() + "'");<a name="line.502"></a>
<font color="green">503</font>            }<a name="line.503"></a>
<font color="green">504</font>    <a name="line.504"></a>
<font color="green">505</font>            // Call the property getter and return the value<a name="line.505"></a>
<font color="green">506</font>            Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);<a name="line.506"></a>
<font color="green">507</font>            if (!value.getClass().isArray()) {<a name="line.507"></a>
<font color="green">508</font>                if (!(value instanceof java.util.List)) {<a name="line.508"></a>
<font color="green">509</font>                    throw new IllegalArgumentException("Property '" + name +<a name="line.509"></a>
<font color="green">510</font>                            "' is not indexed on bean class '" + bean.getClass() + "'");<a name="line.510"></a>
<font color="green">511</font>                } else {<a name="line.511"></a>
<font color="green">512</font>                    //get the List's value<a name="line.512"></a>
<font color="green">513</font>                    return ((java.util.List) value).get(index);<a name="line.513"></a>
<font color="green">514</font>                }<a name="line.514"></a>
<font color="green">515</font>            } else {<a name="line.515"></a>
<font color="green">516</font>                //get the array's value<a name="line.516"></a>
<font color="green">517</font>                try {<a name="line.517"></a>
<font color="green">518</font>                    return (Array.get(value, index));<a name="line.518"></a>
<font color="green">519</font>                } catch (ArrayIndexOutOfBoundsException e) {<a name="line.519"></a>
<font color="green">520</font>                    throw new ArrayIndexOutOfBoundsException("Index: " +<a name="line.520"></a>
<font color="green">521</font>                            index + ", Size: " + Array.getLength(value) +<a name="line.521"></a>
<font color="green">522</font>                            " for property '" + name + "'");<a name="line.522"></a>
<font color="green">523</font>                }<a name="line.523"></a>
<font color="green">524</font>            }<a name="line.524"></a>
<font color="green">525</font>    <a name="line.525"></a>
<font color="green">526</font>        }<a name="line.526"></a>
<font color="green">527</font>    <a name="line.527"></a>
<font color="green">528</font>    <a name="line.528"></a>
<font color="green">529</font>        /**<a name="line.529"></a>
<font color="green">530</font>         * Return the value of the specified mapped property of the<a name="line.530"></a>
<font color="green">531</font>         * specified bean, with no type conversions.  The key of the<a name="line.531"></a>
<font color="green">532</font>         * required value must be included (in brackets) as a suffix to<a name="line.532"></a>
<font color="green">533</font>         * the property name, or &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be<a name="line.533"></a>
<font color="green">534</font>         * thrown.<a name="line.534"></a>
<font color="green">535</font>         *<a name="line.535"></a>
<font color="green">536</font>         * @param bean Bean whose property is to be extracted<a name="line.536"></a>
<font color="green">537</font>         * @param name &lt;code&gt;propertyname(key)&lt;/code&gt; of the property value<a name="line.537"></a>
<font color="green">538</font>         *  to be extracted<a name="line.538"></a>
<font color="green">539</font>         * @return the mapped property value<a name="line.539"></a>
<font color="green">540</font>         *<a name="line.540"></a>
<font color="green">541</font>         * @exception IllegalAccessException if the caller does not have<a name="line.541"></a>
<font color="green">542</font>         *  access to the property accessor method<a name="line.542"></a>
<font color="green">543</font>         * @exception InvocationTargetException if the property accessor method<a name="line.543"></a>
<font color="green">544</font>         *  throws an exception<a name="line.544"></a>
<font color="green">545</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.545"></a>
<font color="green">546</font>         *  propety cannot be found<a name="line.546"></a>
<font color="green">547</font>         */<a name="line.547"></a>
<font color="green">548</font>        public Object getMappedProperty(Object bean, String name)<a name="line.548"></a>
<font color="green">549</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.549"></a>
<font color="green">550</font>                NoSuchMethodException {<a name="line.550"></a>
<font color="green">551</font>    <a name="line.551"></a>
<font color="green">552</font>            if (bean == null) {<a name="line.552"></a>
<font color="green">553</font>                throw new IllegalArgumentException("No bean specified");<a name="line.553"></a>
<font color="green">554</font>            }<a name="line.554"></a>
<font color="green">555</font>            if (name == null) {<a name="line.555"></a>
<font color="green">556</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.556"></a>
<font color="green">557</font>                        bean.getClass() + "'");<a name="line.557"></a>
<font color="green">558</font>            }<a name="line.558"></a>
<font color="green">559</font>    <a name="line.559"></a>
<font color="green">560</font>            // Identify the key of the requested individual property<a name="line.560"></a>
<font color="green">561</font>            String key  = null;<a name="line.561"></a>
<font color="green">562</font>            try {<a name="line.562"></a>
<font color="green">563</font>                key = resolver.getKey(name);<a name="line.563"></a>
<font color="green">564</font>            } catch (IllegalArgumentException e) {<a name="line.564"></a>
<font color="green">565</font>                throw new IllegalArgumentException<a name="line.565"></a>
<font color="green">566</font>                        ("Invalid mapped property '" + name +<a name="line.566"></a>
<font color="green">567</font>                        "' on bean class '" + bean.getClass() + "' " + e.getMessage());<a name="line.567"></a>
<font color="green">568</font>            }<a name="line.568"></a>
<font color="green">569</font>            if (key == null) {<a name="line.569"></a>
<font color="green">570</font>                throw new IllegalArgumentException("Invalid mapped property '" +<a name="line.570"></a>
<font color="green">571</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.571"></a>
<font color="green">572</font>            }<a name="line.572"></a>
<font color="green">573</font>    <a name="line.573"></a>
<font color="green">574</font>            // Isolate the name<a name="line.574"></a>
<font color="green">575</font>            name = resolver.getProperty(name);<a name="line.575"></a>
<font color="green">576</font>    <a name="line.576"></a>
<font color="green">577</font>            // Request the specified indexed property value<a name="line.577"></a>
<font color="green">578</font>            return (getMappedProperty(bean, name, key));<a name="line.578"></a>
<font color="green">579</font>    <a name="line.579"></a>
<font color="green">580</font>        }<a name="line.580"></a>
<font color="green">581</font>    <a name="line.581"></a>
<font color="green">582</font>    <a name="line.582"></a>
<font color="green">583</font>        /**<a name="line.583"></a>
<font color="green">584</font>         * Return the value of the specified mapped property of the specified<a name="line.584"></a>
<font color="green">585</font>         * bean, with no type conversions.<a name="line.585"></a>
<font color="green">586</font>         *<a name="line.586"></a>
<font color="green">587</font>         * @param bean Bean whose property is to be extracted<a name="line.587"></a>
<font color="green">588</font>         * @param name Mapped property name of the property value to be extracted<a name="line.588"></a>
<font color="green">589</font>         * @param key Key of the property value to be extracted<a name="line.589"></a>
<font color="green">590</font>         * @return the mapped property value<a name="line.590"></a>
<font color="green">591</font>         *<a name="line.591"></a>
<font color="green">592</font>         * @exception IllegalAccessException if the caller does not have<a name="line.592"></a>
<font color="green">593</font>         *  access to the property accessor method<a name="line.593"></a>
<font color="green">594</font>         * @exception InvocationTargetException if the property accessor method<a name="line.594"></a>
<font color="green">595</font>         *  throws an exception<a name="line.595"></a>
<font color="green">596</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.596"></a>
<font color="green">597</font>         *  propety cannot be found<a name="line.597"></a>
<font color="green">598</font>         */<a name="line.598"></a>
<font color="green">599</font>        public Object getMappedProperty(Object bean,<a name="line.599"></a>
<font color="green">600</font>                                               String name, String key)<a name="line.600"></a>
<font color="green">601</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.601"></a>
<font color="green">602</font>                NoSuchMethodException {<a name="line.602"></a>
<font color="green">603</font>    <a name="line.603"></a>
<font color="green">604</font>            if (bean == null) {<a name="line.604"></a>
<font color="green">605</font>                throw new IllegalArgumentException("No bean specified");<a name="line.605"></a>
<font color="green">606</font>            }<a name="line.606"></a>
<font color="green">607</font>            if (name == null) {<a name="line.607"></a>
<font color="green">608</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.608"></a>
<font color="green">609</font>                        bean.getClass() + "'");<a name="line.609"></a>
<font color="green">610</font>            }<a name="line.610"></a>
<font color="green">611</font>            if (key == null) {<a name="line.611"></a>
<font color="green">612</font>                throw new IllegalArgumentException("No key specified for property '" +<a name="line.612"></a>
<font color="green">613</font>                        name + "' on bean class " + bean.getClass() + "'");<a name="line.613"></a>
<font color="green">614</font>            }<a name="line.614"></a>
<font color="green">615</font>    <a name="line.615"></a>
<font color="green">616</font>            // Handle DynaBean instances specially<a name="line.616"></a>
<font color="green">617</font>            if (bean instanceof DynaBean) {<a name="line.617"></a>
<font color="green">618</font>                DynaProperty descriptor =<a name="line.618"></a>
<font color="green">619</font>                        ((DynaBean) bean).getDynaClass().getDynaProperty(name);<a name="line.619"></a>
<font color="green">620</font>                if (descriptor == null) {<a name="line.620"></a>
<font color="green">621</font>                    throw new NoSuchMethodException("Unknown property '" +<a name="line.621"></a>
<font color="green">622</font>                            name + "'+ on bean class '" + bean.getClass() + "'");<a name="line.622"></a>
<font color="green">623</font>                }<a name="line.623"></a>
<font color="green">624</font>                return (((DynaBean) bean).get(name, key));<a name="line.624"></a>
<font color="green">625</font>            }<a name="line.625"></a>
<font color="green">626</font>    <a name="line.626"></a>
<font color="green">627</font>            Object result = null;<a name="line.627"></a>
<font color="green">628</font>    <a name="line.628"></a>
<font color="green">629</font>            // Retrieve the property descriptor for the specified property<a name="line.629"></a>
<font color="green">630</font>            PropertyDescriptor descriptor = getPropertyDescriptor(bean, name);<a name="line.630"></a>
<font color="green">631</font>            if (descriptor == null) {<a name="line.631"></a>
<font color="green">632</font>                throw new NoSuchMethodException("Unknown property '" +<a name="line.632"></a>
<font color="green">633</font>                        name + "'+ on bean class '" + bean.getClass() + "'");<a name="line.633"></a>
<font color="green">634</font>            }<a name="line.634"></a>
<font color="green">635</font>    <a name="line.635"></a>
<font color="green">636</font>            if (descriptor instanceof MappedPropertyDescriptor) {<a name="line.636"></a>
<font color="green">637</font>                // Call the keyed getter method if there is one<a name="line.637"></a>
<font color="green">638</font>                Method readMethod = ((MappedPropertyDescriptor) descriptor).<a name="line.638"></a>
<font color="green">639</font>                        getMappedReadMethod();<a name="line.639"></a>
<font color="green">640</font>                readMethod = MethodUtils.getAccessibleMethod(bean.getClass(), readMethod);<a name="line.640"></a>
<font color="green">641</font>                if (readMethod != null) {<a name="line.641"></a>
<font color="green">642</font>                    Object[] keyArray = new Object[1];<a name="line.642"></a>
<font color="green">643</font>                    keyArray[0] = key;<a name="line.643"></a>
<font color="green">644</font>                    result = invokeMethod(readMethod, bean, keyArray);<a name="line.644"></a>
<font color="green">645</font>                } else {<a name="line.645"></a>
<font color="green">646</font>                    throw new NoSuchMethodException("Property '" + name +<a name="line.646"></a>
<font color="green">647</font>                            "' has no mapped getter method on bean class '" +<a name="line.647"></a>
<font color="green">648</font>                            bean.getClass() + "'");<a name="line.648"></a>
<font color="green">649</font>                }<a name="line.649"></a>
<font color="green">650</font>            } else {<a name="line.650"></a>
<font color="green">651</font>              /* means that the result has to be retrieved from a map */<a name="line.651"></a>
<font color="green">652</font>              Method readMethod = getReadMethod(bean.getClass(), descriptor);<a name="line.652"></a>
<font color="green">653</font>              if (readMethod != null) {<a name="line.653"></a>
<font color="green">654</font>                Object invokeResult = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);<a name="line.654"></a>
<font color="green">655</font>                /* test and fetch from the map */<a name="line.655"></a>
<font color="green">656</font>                if (invokeResult instanceof java.util.Map) {<a name="line.656"></a>
<font color="green">657</font>                  result = ((java.util.Map)invokeResult).get(key);<a name="line.657"></a>
<font color="green">658</font>                }<a name="line.658"></a>
<font color="green">659</font>              } else {<a name="line.659"></a>
<font color="green">660</font>                throw new NoSuchMethodException("Property '" + name +<a name="line.660"></a>
<font color="green">661</font>                        "' has no mapped getter method on bean class '" +<a name="line.661"></a>
<font color="green">662</font>                        bean.getClass() + "'");<a name="line.662"></a>
<font color="green">663</font>              }<a name="line.663"></a>
<font color="green">664</font>            }<a name="line.664"></a>
<font color="green">665</font>            return result;<a name="line.665"></a>
<font color="green">666</font>    <a name="line.666"></a>
<font color="green">667</font>        }<a name="line.667"></a>
<font color="green">668</font>    <a name="line.668"></a>
<font color="green">669</font>    <a name="line.669"></a>
<font color="green">670</font>        /**<a name="line.670"></a>
<font color="green">671</font>         * &lt;p&gt;Return the mapped property descriptors for this bean class.&lt;/p&gt;<a name="line.671"></a>
<font color="green">672</font>         *<a name="line.672"></a>
<font color="green">673</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.673"></a>
<font color="green">674</font>         *<a name="line.674"></a>
<font color="green">675</font>         * @param beanClass Bean class to be introspected<a name="line.675"></a>
<font color="green">676</font>         * @return the mapped property descriptors<a name="line.676"></a>
<font color="green">677</font>         * @deprecated This method should not be exposed<a name="line.677"></a>
<font color="green">678</font>         */<a name="line.678"></a>
<font color="green">679</font>        public FastHashMap getMappedPropertyDescriptors(Class beanClass) {<a name="line.679"></a>
<font color="green">680</font>    <a name="line.680"></a>
<font color="green">681</font>            if (beanClass == null) {<a name="line.681"></a>
<font color="green">682</font>                return null;<a name="line.682"></a>
<font color="green">683</font>            }<a name="line.683"></a>
<font color="green">684</font>    <a name="line.684"></a>
<font color="green">685</font>            // Look up any cached descriptors for this bean class<a name="line.685"></a>
<font color="green">686</font>            return (FastHashMap) mappedDescriptorsCache.get(beanClass);<a name="line.686"></a>
<font color="green">687</font>    <a name="line.687"></a>
<font color="green">688</font>        }<a name="line.688"></a>
<font color="green">689</font>    <a name="line.689"></a>
<font color="green">690</font>    <a name="line.690"></a>
<font color="green">691</font>        /**<a name="line.691"></a>
<font color="green">692</font>         * &lt;p&gt;Return the mapped property descriptors for this bean.&lt;/p&gt;<a name="line.692"></a>
<font color="green">693</font>         *<a name="line.693"></a>
<font color="green">694</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.694"></a>
<font color="green">695</font>         *<a name="line.695"></a>
<font color="green">696</font>         * @param bean Bean to be introspected<a name="line.696"></a>
<font color="green">697</font>         * @return the mapped property descriptors<a name="line.697"></a>
<font color="green">698</font>         * @deprecated This method should not be exposed<a name="line.698"></a>
<font color="green">699</font>         */<a name="line.699"></a>
<font color="green">700</font>        public FastHashMap getMappedPropertyDescriptors(Object bean) {<a name="line.700"></a>
<font color="green">701</font>    <a name="line.701"></a>
<font color="green">702</font>            if (bean == null) {<a name="line.702"></a>
<font color="green">703</font>                return null;<a name="line.703"></a>
<font color="green">704</font>            }<a name="line.704"></a>
<font color="green">705</font>            return (getMappedPropertyDescriptors(bean.getClass()));<a name="line.705"></a>
<font color="green">706</font>    <a name="line.706"></a>
<font color="green">707</font>        }<a name="line.707"></a>
<font color="green">708</font>    <a name="line.708"></a>
<font color="green">709</font>    <a name="line.709"></a>
<font color="green">710</font>        /**<a name="line.710"></a>
<font color="green">711</font>         * Return the value of the (possibly nested) property of the specified<a name="line.711"></a>
<font color="green">712</font>         * name, for the specified bean, with no type conversions.<a name="line.712"></a>
<font color="green">713</font>         *<a name="line.713"></a>
<font color="green">714</font>         * @param bean Bean whose property is to be extracted<a name="line.714"></a>
<font color="green">715</font>         * @param name Possibly nested name of the property to be extracted<a name="line.715"></a>
<font color="green">716</font>         * @return the nested property value<a name="line.716"></a>
<font color="green">717</font>         *<a name="line.717"></a>
<font color="green">718</font>         * @exception IllegalAccessException if the caller does not have<a name="line.718"></a>
<font color="green">719</font>         *  access to the property accessor method<a name="line.719"></a>
<font color="green">720</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.720"></a>
<font color="green">721</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.721"></a>
<font color="green">722</font>         * @exception NestedNullException if a nested reference to a<a name="line.722"></a>
<font color="green">723</font>         *  property returns null<a name="line.723"></a>
<font color="green">724</font>         * @exception InvocationTargetException <a name="line.724"></a>
<font color="green">725</font>         * if the property accessor method throws an exception<a name="line.725"></a>
<font color="green">726</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.726"></a>
<font color="green">727</font>         *  propety cannot be found<a name="line.727"></a>
<font color="green">728</font>         */<a name="line.728"></a>
<font color="green">729</font>        public Object getNestedProperty(Object bean, String name)<a name="line.729"></a>
<font color="green">730</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.730"></a>
<font color="green">731</font>                NoSuchMethodException {<a name="line.731"></a>
<font color="green">732</font>    <a name="line.732"></a>
<font color="green">733</font>            if (bean == null) {<a name="line.733"></a>
<font color="green">734</font>                throw new IllegalArgumentException("No bean specified");<a name="line.734"></a>
<font color="green">735</font>            }<a name="line.735"></a>
<font color="green">736</font>            if (name == null) {<a name="line.736"></a>
<font color="green">737</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.737"></a>
<font color="green">738</font>                        bean.getClass() + "'");<a name="line.738"></a>
<font color="green">739</font>            }<a name="line.739"></a>
<font color="green">740</font>    <a name="line.740"></a>
<font color="green">741</font>            // Resolve nested references<a name="line.741"></a>
<font color="green">742</font>            while (resolver.hasNested(name)) {<a name="line.742"></a>
<font color="green">743</font>                String next = resolver.next(name);<a name="line.743"></a>
<font color="green">744</font>                Object nestedBean = null;<a name="line.744"></a>
<font color="green">745</font>                if (bean instanceof Map) {<a name="line.745"></a>
<font color="green">746</font>                    nestedBean = getPropertyOfMapBean((Map) bean, next);<a name="line.746"></a>
<font color="green">747</font>                } else if (resolver.isMapped(next)) {<a name="line.747"></a>
<font color="green">748</font>                    nestedBean = getMappedProperty(bean, next);<a name="line.748"></a>
<font color="green">749</font>                } else if (resolver.isIndexed(next)) {<a name="line.749"></a>
<font color="green">750</font>                    nestedBean = getIndexedProperty(bean, next);<a name="line.750"></a>
<font color="green">751</font>                } else {<a name="line.751"></a>
<font color="green">752</font>                    nestedBean = getSimpleProperty(bean, next);<a name="line.752"></a>
<font color="green">753</font>                }<a name="line.753"></a>
<font color="green">754</font>                if (nestedBean == null) {<a name="line.754"></a>
<font color="green">755</font>                    throw new NestedNullException<a name="line.755"></a>
<font color="green">756</font>                            ("Null property value for '" + name +<a name="line.756"></a>
<font color="green">757</font>                            "' on bean class '" + bean.getClass() + "'");<a name="line.757"></a>
<font color="green">758</font>                }<a name="line.758"></a>
<font color="green">759</font>                bean = nestedBean;<a name="line.759"></a>
<font color="green">760</font>                name = resolver.remove(name);<a name="line.760"></a>
<font color="green">761</font>            }<a name="line.761"></a>
<font color="green">762</font>    <a name="line.762"></a>
<font color="green">763</font>            if (bean instanceof Map) {<a name="line.763"></a>
<font color="green">764</font>                bean = getPropertyOfMapBean((Map) bean, name);<a name="line.764"></a>
<font color="green">765</font>            } else if (resolver.isMapped(name)) {<a name="line.765"></a>
<font color="green">766</font>                bean = getMappedProperty(bean, name);<a name="line.766"></a>
<font color="green">767</font>            } else if (resolver.isIndexed(name)) {<a name="line.767"></a>
<font color="green">768</font>                bean = getIndexedProperty(bean, name);<a name="line.768"></a>
<font color="green">769</font>            } else {<a name="line.769"></a>
<font color="green">770</font>                bean = getSimpleProperty(bean, name);<a name="line.770"></a>
<font color="green">771</font>            }<a name="line.771"></a>
<font color="green">772</font>            return bean;<a name="line.772"></a>
<font color="green">773</font>    <a name="line.773"></a>
<font color="green">774</font>        }<a name="line.774"></a>
<font color="green">775</font>    <a name="line.775"></a>
<font color="green">776</font>        /**<a name="line.776"></a>
<font color="green">777</font>         * This method is called by getNestedProperty and setNestedProperty to<a name="line.777"></a>
<font color="green">778</font>         * define what it means to get a property from an object which implements<a name="line.778"></a>
<font color="green">779</font>         * Map. See setPropertyOfMapBean for more information.<a name="line.779"></a>
<font color="green">780</font>         *<a name="line.780"></a>
<font color="green">781</font>         * @param bean Map bean<a name="line.781"></a>
<font color="green">782</font>         * @param propertyName The property name<a name="line.782"></a>
<font color="green">783</font>         * @return the property value<a name="line.783"></a>
<font color="green">784</font>         * <a name="line.784"></a>
<font color="green">785</font>         * @throws IllegalArgumentException when the propertyName is regarded as<a name="line.785"></a>
<font color="green">786</font>         * being invalid.<a name="line.786"></a>
<font color="green">787</font>         * <a name="line.787"></a>
<font color="green">788</font>         * @throws IllegalAccessException just in case subclasses override this<a name="line.788"></a>
<font color="green">789</font>         * method to try to access real getter methods and find permission is denied.<a name="line.789"></a>
<font color="green">790</font>         * <a name="line.790"></a>
<font color="green">791</font>         * @throws InvocationTargetException just in case subclasses override this<a name="line.791"></a>
<font color="green">792</font>         * method to try to access real getter methods, and find it throws an<a name="line.792"></a>
<font color="green">793</font>         * exception when invoked.<a name="line.793"></a>
<font color="green">794</font>         * <a name="line.794"></a>
<font color="green">795</font>         * @throws NoSuchMethodException just in case subclasses override this<a name="line.795"></a>
<font color="green">796</font>         * method to try to access real getter methods, and want to fail if<a name="line.796"></a>
<font color="green">797</font>         * no simple method is available.<a name="line.797"></a>
<font color="green">798</font>         * @since 1.8.0<a name="line.798"></a>
<font color="green">799</font>         */<a name="line.799"></a>
<font color="green">800</font>        protected Object getPropertyOfMapBean(Map bean, String propertyName) <a name="line.800"></a>
<font color="green">801</font>            throws IllegalArgumentException, IllegalAccessException, <a name="line.801"></a>
<font color="green">802</font>            InvocationTargetException, NoSuchMethodException {<a name="line.802"></a>
<font color="green">803</font>    <a name="line.803"></a>
<font color="green">804</font>            if (resolver.isMapped(propertyName)) {<a name="line.804"></a>
<font color="green">805</font>                String name = resolver.getProperty(propertyName);<a name="line.805"></a>
<font color="green">806</font>                if (name == null || name.length() == 0) {<a name="line.806"></a>
<font color="green">807</font>                    propertyName = resolver.getKey(propertyName);<a name="line.807"></a>
<font color="green">808</font>                }<a name="line.808"></a>
<font color="green">809</font>            }<a name="line.809"></a>
<font color="green">810</font>    <a name="line.810"></a>
<font color="green">811</font>            if (resolver.isIndexed(propertyName) ||<a name="line.811"></a>
<font color="green">812</font>                resolver.isMapped(propertyName)) {<a name="line.812"></a>
<font color="green">813</font>                throw new IllegalArgumentException(<a name="line.813"></a>
<font color="green">814</font>                        "Indexed or mapped properties are not supported on"<a name="line.814"></a>
<font color="green">815</font>                        + " objects of type Map: " + propertyName);<a name="line.815"></a>
<font color="green">816</font>            }<a name="line.816"></a>
<font color="green">817</font>    <a name="line.817"></a>
<font color="green">818</font>            return bean.get(propertyName);<a name="line.818"></a>
<font color="green">819</font>        }<a name="line.819"></a>
<font color="green">820</font>    <a name="line.820"></a>
<font color="green">821</font>    <a name="line.821"></a>
<font color="green">822</font>    <a name="line.822"></a>
<font color="green">823</font>        /**<a name="line.823"></a>
<font color="green">824</font>         * Return the value of the specified property of the specified bean,<a name="line.824"></a>
<font color="green">825</font>         * no matter which property reference format is used, with no<a name="line.825"></a>
<font color="green">826</font>         * type conversions.<a name="line.826"></a>
<font color="green">827</font>         *<a name="line.827"></a>
<font color="green">828</font>         * @param bean Bean whose property is to be extracted<a name="line.828"></a>
<font color="green">829</font>         * @param name Possibly indexed and/or nested name of the property<a name="line.829"></a>
<font color="green">830</font>         *  to be extracted<a name="line.830"></a>
<font color="green">831</font>         * @return the property value<a name="line.831"></a>
<font color="green">832</font>         *<a name="line.832"></a>
<font color="green">833</font>         * @exception IllegalAccessException if the caller does not have<a name="line.833"></a>
<font color="green">834</font>         *  access to the property accessor method<a name="line.834"></a>
<font color="green">835</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.835"></a>
<font color="green">836</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.836"></a>
<font color="green">837</font>         * @exception InvocationTargetException if the property accessor method<a name="line.837"></a>
<font color="green">838</font>         *  throws an exception<a name="line.838"></a>
<font color="green">839</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.839"></a>
<font color="green">840</font>         *  propety cannot be found<a name="line.840"></a>
<font color="green">841</font>         */<a name="line.841"></a>
<font color="green">842</font>        public Object getProperty(Object bean, String name)<a name="line.842"></a>
<font color="green">843</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.843"></a>
<font color="green">844</font>                NoSuchMethodException {<a name="line.844"></a>
<font color="green">845</font>    <a name="line.845"></a>
<font color="green">846</font>            return (getNestedProperty(bean, name));<a name="line.846"></a>
<font color="green">847</font>    <a name="line.847"></a>
<font color="green">848</font>        }<a name="line.848"></a>
<font color="green">849</font>    <a name="line.849"></a>
<font color="green">850</font>    <a name="line.850"></a>
<font color="green">851</font>        /**<a name="line.851"></a>
<font color="green">852</font>         * &lt;p&gt;Retrieve the property descriptor for the specified property of the<a name="line.852"></a>
<font color="green">853</font>         * specified bean, or return &lt;code&gt;null&lt;/code&gt; if there is no such<a name="line.853"></a>
<font color="green">854</font>         * descriptor.  This method resolves indexed and nested property<a name="line.854"></a>
<font color="green">855</font>         * references in the same manner as other methods in this class, except<a name="line.855"></a>
<font color="green">856</font>         * that if the last (or only) name element is indexed, the descriptor<a name="line.856"></a>
<font color="green">857</font>         * for the last resolved property itself is returned.&lt;/p&gt;<a name="line.857"></a>
<font color="green">858</font>         *<a name="line.858"></a>
<font color="green">859</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.859"></a>
<font color="green">860</font>         *<a name="line.860"></a>
<font color="green">861</font>         * @param bean Bean for which a property descriptor is requested<a name="line.861"></a>
<font color="green">862</font>         * @param name Possibly indexed and/or nested name of the property for<a name="line.862"></a>
<font color="green">863</font>         *  which a property descriptor is requested<a name="line.863"></a>
<font color="green">864</font>         * @return the property descriptor<a name="line.864"></a>
<font color="green">865</font>         *<a name="line.865"></a>
<font color="green">866</font>         * @exception IllegalAccessException if the caller does not have<a name="line.866"></a>
<font color="green">867</font>         *  access to the property accessor method<a name="line.867"></a>
<font color="green">868</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.868"></a>
<font color="green">869</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.869"></a>
<font color="green">870</font>         * @exception IllegalArgumentException if a nested reference to a<a name="line.870"></a>
<font color="green">871</font>         *  property returns null<a name="line.871"></a>
<font color="green">872</font>         * @exception InvocationTargetException if the property accessor method<a name="line.872"></a>
<font color="green">873</font>         *  throws an exception<a name="line.873"></a>
<font color="green">874</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.874"></a>
<font color="green">875</font>         *  propety cannot be found<a name="line.875"></a>
<font color="green">876</font>         */<a name="line.876"></a>
<font color="green">877</font>        public PropertyDescriptor getPropertyDescriptor(Object bean,<a name="line.877"></a>
<font color="green">878</font>                                                               String name)<a name="line.878"></a>
<font color="green">879</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.879"></a>
<font color="green">880</font>                NoSuchMethodException {<a name="line.880"></a>
<font color="green">881</font>    <a name="line.881"></a>
<font color="green">882</font>            if (bean == null) {<a name="line.882"></a>
<font color="green">883</font>                throw new IllegalArgumentException("No bean specified");<a name="line.883"></a>
<font color="green">884</font>            }<a name="line.884"></a>
<font color="green">885</font>            if (name == null) {<a name="line.885"></a>
<font color="green">886</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.886"></a>
<font color="green">887</font>                        bean.getClass() + "'");<a name="line.887"></a>
<font color="green">888</font>            }<a name="line.888"></a>
<font color="green">889</font>    <a name="line.889"></a>
<font color="green">890</font>            // Resolve nested references<a name="line.890"></a>
<font color="green">891</font>            while (resolver.hasNested(name)) {<a name="line.891"></a>
<font color="green">892</font>                String next = resolver.next(name);<a name="line.892"></a>
<font color="green">893</font>                Object nestedBean = getProperty(bean, next);<a name="line.893"></a>
<font color="green">894</font>                if (nestedBean == null) {<a name="line.894"></a>
<font color="green">895</font>                    throw new NestedNullException<a name="line.895"></a>
<font color="green">896</font>                            ("Null property value for '" + next +<a name="line.896"></a>
<font color="green">897</font>                            "' on bean class '" + bean.getClass() + "'");<a name="line.897"></a>
<font color="green">898</font>                }<a name="line.898"></a>
<font color="green">899</font>                bean = nestedBean;<a name="line.899"></a>
<font color="green">900</font>                name = resolver.remove(name);<a name="line.900"></a>
<font color="green">901</font>            }<a name="line.901"></a>
<font color="green">902</font>    <a name="line.902"></a>
<font color="green">903</font>            // Remove any subscript from the final name value<a name="line.903"></a>
<font color="green">904</font>            name = resolver.getProperty(name);<a name="line.904"></a>
<font color="green">905</font>    <a name="line.905"></a>
<font color="green">906</font>            // Look up and return this property from our cache<a name="line.906"></a>
<font color="green">907</font>            // creating and adding it to the cache if not found.<a name="line.907"></a>
<font color="green">908</font>            if (name == null) {<a name="line.908"></a>
<font color="green">909</font>                return (null);<a name="line.909"></a>
<font color="green">910</font>            }<a name="line.910"></a>
<font color="green">911</font>            <a name="line.911"></a>
<font color="green">912</font>            PropertyDescriptor[] descriptors = getPropertyDescriptors(bean);<a name="line.912"></a>
<font color="green">913</font>            if (descriptors != null) {<a name="line.913"></a>
<font color="green">914</font>                <a name="line.914"></a>
<font color="green">915</font>                for (int i = 0; i &lt; descriptors.length; i++) {<a name="line.915"></a>
<font color="green">916</font>                    if (name.equals(descriptors[i].getName())) {<a name="line.916"></a>
<font color="green">917</font>                        return (descriptors[i]);<a name="line.917"></a>
<font color="green">918</font>                    }<a name="line.918"></a>
<font color="green">919</font>                }<a name="line.919"></a>
<font color="green">920</font>            }<a name="line.920"></a>
<font color="green">921</font>    <a name="line.921"></a>
<font color="green">922</font>            PropertyDescriptor result = null;<a name="line.922"></a>
<font color="green">923</font>            FastHashMap mappedDescriptors =<a name="line.923"></a>
<font color="green">924</font>                    getMappedPropertyDescriptors(bean);<a name="line.924"></a>
<font color="green">925</font>            if (mappedDescriptors == null) {<a name="line.925"></a>
<font color="green">926</font>                mappedDescriptors = new FastHashMap();<a name="line.926"></a>
<font color="green">927</font>                mappedDescriptors.setFast(true);<a name="line.927"></a>
<font color="green">928</font>                mappedDescriptorsCache.put(bean.getClass(), mappedDescriptors);<a name="line.928"></a>
<font color="green">929</font>            }<a name="line.929"></a>
<font color="green">930</font>            result = (PropertyDescriptor) mappedDescriptors.get(name);<a name="line.930"></a>
<font color="green">931</font>            if (result == null) {<a name="line.931"></a>
<font color="green">932</font>                // not found, try to create it<a name="line.932"></a>
<font color="green">933</font>                try {<a name="line.933"></a>
<font color="green">934</font>                    result = new MappedPropertyDescriptor(name, bean.getClass());<a name="line.934"></a>
<font color="green">935</font>                } catch (IntrospectionException ie) {<a name="line.935"></a>
<font color="green">936</font>                    /* Swallow IntrospectionException<a name="line.936"></a>
<font color="green">937</font>                     * TODO: Why?<a name="line.937"></a>
<font color="green">938</font>                     */<a name="line.938"></a>
<font color="green">939</font>                }<a name="line.939"></a>
<font color="green">940</font>                if (result != null) {<a name="line.940"></a>
<font color="green">941</font>                    mappedDescriptors.put(name, result);<a name="line.941"></a>
<font color="green">942</font>                }<a name="line.942"></a>
<font color="green">943</font>            }<a name="line.943"></a>
<font color="green">944</font>            <a name="line.944"></a>
<font color="green">945</font>            return result;<a name="line.945"></a>
<font color="green">946</font>    <a name="line.946"></a>
<font color="green">947</font>        }<a name="line.947"></a>
<font color="green">948</font>    <a name="line.948"></a>
<font color="green">949</font>    <a name="line.949"></a>
<font color="green">950</font>        /**<a name="line.950"></a>
<font color="green">951</font>         * &lt;p&gt;Retrieve the property descriptors for the specified class,<a name="line.951"></a>
<font color="green">952</font>         * introspecting and caching them the first time a particular bean class<a name="line.952"></a>
<font color="green">953</font>         * is encountered.&lt;/p&gt;<a name="line.953"></a>
<font color="green">954</font>         *<a name="line.954"></a>
<font color="green">955</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.955"></a>
<font color="green">956</font>         *<a name="line.956"></a>
<font color="green">957</font>         * @param beanClass Bean class for which property descriptors are requested<a name="line.957"></a>
<font color="green">958</font>         * @return the property descriptors<a name="line.958"></a>
<font color="green">959</font>         *<a name="line.959"></a>
<font color="green">960</font>         * @exception IllegalArgumentException if &lt;code&gt;beanClass&lt;/code&gt; is null<a name="line.960"></a>
<font color="green">961</font>         */<a name="line.961"></a>
<font color="green">962</font>        public PropertyDescriptor[]<a name="line.962"></a>
<font color="green">963</font>                getPropertyDescriptors(Class beanClass) {<a name="line.963"></a>
<font color="green">964</font>    <a name="line.964"></a>
<font color="green">965</font>            if (beanClass == null) {<a name="line.965"></a>
<font color="green">966</font>                throw new IllegalArgumentException("No bean class specified");<a name="line.966"></a>
<font color="green">967</font>            }<a name="line.967"></a>
<font color="green">968</font>    <a name="line.968"></a>
<font color="green">969</font>            // Look up any cached descriptors for this bean class<a name="line.969"></a>
<font color="green">970</font>            PropertyDescriptor[] descriptors = null;<a name="line.970"></a>
<font color="green">971</font>            descriptors =<a name="line.971"></a>
<font color="green">972</font>                    (PropertyDescriptor[]) descriptorsCache.get(beanClass);<a name="line.972"></a>
<font color="green">973</font>            if (descriptors != null) {<a name="line.973"></a>
<font color="green">974</font>                return (descriptors);<a name="line.974"></a>
<font color="green">975</font>            }<a name="line.975"></a>
<font color="green">976</font>    <a name="line.976"></a>
<font color="green">977</font>            // Introspect the bean and cache the generated descriptors<a name="line.977"></a>
<font color="green">978</font>            BeanInfo beanInfo = null;<a name="line.978"></a>
<font color="green">979</font>            try {<a name="line.979"></a>
<font color="green">980</font>                beanInfo = Introspector.getBeanInfo(beanClass);<a name="line.980"></a>
<font color="green">981</font>            } catch (IntrospectionException e) {<a name="line.981"></a>
<font color="green">982</font>                return (new PropertyDescriptor[0]);<a name="line.982"></a>
<font color="green">983</font>            }<a name="line.983"></a>
<font color="green">984</font>            descriptors = beanInfo.getPropertyDescriptors();<a name="line.984"></a>
<font color="green">985</font>            if (descriptors == null) {<a name="line.985"></a>
<font color="green">986</font>                descriptors = new PropertyDescriptor[0];<a name="line.986"></a>
<font color="green">987</font>            }<a name="line.987"></a>
<font color="green">988</font>    <a name="line.988"></a>
<font color="green">989</font>            // ----------------- Workaround for Bug 28358 --------- START ------------------<a name="line.989"></a>
<font color="green">990</font>            //<a name="line.990"></a>
<font color="green">991</font>            // The following code fixes an issue where IndexedPropertyDescriptor behaves<a name="line.991"></a>
<font color="green">992</font>            // Differently in different versions of the JDK for 'indexed' properties which<a name="line.992"></a>
<font color="green">993</font>            // use java.util.List (rather than an array).<a name="line.993"></a>
<font color="green">994</font>            //<a name="line.994"></a>
<font color="green">995</font>            // If you have a Bean with the following getters/setters for an indexed property:<a name="line.995"></a>
<font color="green">996</font>            //<a name="line.996"></a>
<font color="green">997</font>            //     public List getFoo()<a name="line.997"></a>
<font color="green">998</font>            //     public Object getFoo(int index)<a name="line.998"></a>
<font color="green">999</font>            //     public void setFoo(List foo)<a name="line.999"></a>
<font color="green">1000</font>            //     public void setFoo(int index, Object foo)<a name="line.1000"></a>
<font color="green">1001</font>            //<a name="line.1001"></a>
<font color="green">1002</font>            // then the IndexedPropertyDescriptor's getReadMethod() and getWriteMethod()<a name="line.1002"></a>
<font color="green">1003</font>            // behave as follows:<a name="line.1003"></a>
<font color="green">1004</font>            //<a name="line.1004"></a>
<font color="green">1005</font>            //     JDK 1.3.1_04: returns valid Method objects from these methods.<a name="line.1005"></a>
<font color="green">1006</font>            //     JDK 1.4.2_05: returns null from these methods.<a name="line.1006"></a>
<font color="green">1007</font>            //<a name="line.1007"></a>
<font color="green">1008</font>            for (int i = 0; i &lt; descriptors.length; i++) {<a name="line.1008"></a>
<font color="green">1009</font>                if (descriptors[i] instanceof IndexedPropertyDescriptor) {<a name="line.1009"></a>
<font color="green">1010</font>                    IndexedPropertyDescriptor descriptor =  (IndexedPropertyDescriptor)descriptors[i];<a name="line.1010"></a>
<font color="green">1011</font>                    String propName = descriptor.getName().substring(0, 1).toUpperCase() +<a name="line.1011"></a>
<font color="green">1012</font>                                      descriptor.getName().substring(1);<a name="line.1012"></a>
<font color="green">1013</font>    <a name="line.1013"></a>
<font color="green">1014</font>                    if (descriptor.getReadMethod() == null) {<a name="line.1014"></a>
<font color="green">1015</font>                        String methodName = descriptor.getIndexedReadMethod() != null<a name="line.1015"></a>
<font color="green">1016</font>                                            ? descriptor.getIndexedReadMethod().getName()<a name="line.1016"></a>
<font color="green">1017</font>                                            : "get" + propName;<a name="line.1017"></a>
<font color="green">1018</font>                        Method readMethod = MethodUtils.getMatchingAccessibleMethod(beanClass,<a name="line.1018"></a>
<font color="green">1019</font>                                                                methodName,<a name="line.1019"></a>
<font color="green">1020</font>                                                                EMPTY_CLASS_PARAMETERS);<a name="line.1020"></a>
<font color="green">1021</font>                        if (readMethod != null) {<a name="line.1021"></a>
<font color="green">1022</font>                            try {<a name="line.1022"></a>
<font color="green">1023</font>                                descriptor.setReadMethod(readMethod);<a name="line.1023"></a>
<font color="green">1024</font>                            } catch(Exception e) {<a name="line.1024"></a>
<font color="green">1025</font>                                log.error("Error setting indexed property read method", e);<a name="line.1025"></a>
<font color="green">1026</font>                            }<a name="line.1026"></a>
<font color="green">1027</font>                        }<a name="line.1027"></a>
<font color="green">1028</font>                    }<a name="line.1028"></a>
<font color="green">1029</font>                    if (descriptor.getWriteMethod() == null) {<a name="line.1029"></a>
<font color="green">1030</font>                        String methodName = descriptor.getIndexedWriteMethod() != null<a name="line.1030"></a>
<font color="green">1031</font>                                          ? descriptor.getIndexedWriteMethod().getName()<a name="line.1031"></a>
<font color="green">1032</font>                                          : "set" + propName;<a name="line.1032"></a>
<font color="green">1033</font>                        Method writeMethod = MethodUtils.getMatchingAccessibleMethod(beanClass,<a name="line.1033"></a>
<font color="green">1034</font>                                                                methodName,<a name="line.1034"></a>
<font color="green">1035</font>                                                                LIST_CLASS_PARAMETER);<a name="line.1035"></a>
<font color="green">1036</font>                        if (writeMethod == null) {<a name="line.1036"></a>
<font color="green">1037</font>                            Method[] methods = beanClass.getMethods();<a name="line.1037"></a>
<font color="green">1038</font>                            for (int j = 0; j &lt; methods.length; j++) {<a name="line.1038"></a>
<font color="green">1039</font>                                if (methods[j].getName().equals(methodName)) {<a name="line.1039"></a>
<font color="green">1040</font>                                    Class[] parameterTypes = methods[j].getParameterTypes();<a name="line.1040"></a>
<font color="green">1041</font>                                    if (parameterTypes.length == 1 &amp;&amp;<a name="line.1041"></a>
<font color="green">1042</font>                                        List.class.isAssignableFrom(parameterTypes[0])) {<a name="line.1042"></a>
<font color="green">1043</font>                                        writeMethod = methods[j];<a name="line.1043"></a>
<font color="green">1044</font>                                        break; <a name="line.1044"></a>
<font color="green">1045</font>                                    }<a name="line.1045"></a>
<font color="green">1046</font>                                }<a name="line.1046"></a>
<font color="green">1047</font>                            }<a name="line.1047"></a>
<font color="green">1048</font>                        }<a name="line.1048"></a>
<font color="green">1049</font>                        if (writeMethod != null) {<a name="line.1049"></a>
<font color="green">1050</font>                            try {<a name="line.1050"></a>
<font color="green">1051</font>                                descriptor.setWriteMethod(writeMethod);<a name="line.1051"></a>
<font color="green">1052</font>                            } catch(Exception e) {<a name="line.1052"></a>
<font color="green">1053</font>                                log.error("Error setting indexed property write method", e);<a name="line.1053"></a>
<font color="green">1054</font>                            }<a name="line.1054"></a>
<font color="green">1055</font>                        }<a name="line.1055"></a>
<font color="green">1056</font>                    }<a name="line.1056"></a>
<font color="green">1057</font>                }<a name="line.1057"></a>
<font color="green">1058</font>            }<a name="line.1058"></a>
<font color="green">1059</font>            // ----------------- Workaround for Bug 28358 ---------- END -------------------<a name="line.1059"></a>
<font color="green">1060</font>    <a name="line.1060"></a>
<font color="green">1061</font>            descriptorsCache.put(beanClass, descriptors);<a name="line.1061"></a>
<font color="green">1062</font>            return (descriptors);<a name="line.1062"></a>
<font color="green">1063</font>    <a name="line.1063"></a>
<font color="green">1064</font>        }<a name="line.1064"></a>
<font color="green">1065</font>    <a name="line.1065"></a>
<font color="green">1066</font>    <a name="line.1066"></a>
<font color="green">1067</font>        /**<a name="line.1067"></a>
<font color="green">1068</font>         * &lt;p&gt;Retrieve the property descriptors for the specified bean,<a name="line.1068"></a>
<font color="green">1069</font>         * introspecting and caching them the first time a particular bean class<a name="line.1069"></a>
<font color="green">1070</font>         * is encountered.&lt;/p&gt;<a name="line.1070"></a>
<font color="green">1071</font>         *<a name="line.1071"></a>
<font color="green">1072</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.1072"></a>
<font color="green">1073</font>         *<a name="line.1073"></a>
<font color="green">1074</font>         * @param bean Bean for which property descriptors are requested<a name="line.1074"></a>
<font color="green">1075</font>         * @return the property descriptors<a name="line.1075"></a>
<font color="green">1076</font>         *<a name="line.1076"></a>
<font color="green">1077</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; is null<a name="line.1077"></a>
<font color="green">1078</font>         */<a name="line.1078"></a>
<font color="green">1079</font>        public PropertyDescriptor[] getPropertyDescriptors(Object bean) {<a name="line.1079"></a>
<font color="green">1080</font>    <a name="line.1080"></a>
<font color="green">1081</font>            if (bean == null) {<a name="line.1081"></a>
<font color="green">1082</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1082"></a>
<font color="green">1083</font>            }<a name="line.1083"></a>
<font color="green">1084</font>            return (getPropertyDescriptors(bean.getClass()));<a name="line.1084"></a>
<font color="green">1085</font>    <a name="line.1085"></a>
<font color="green">1086</font>        }<a name="line.1086"></a>
<font color="green">1087</font>    <a name="line.1087"></a>
<font color="green">1088</font>    <a name="line.1088"></a>
<font color="green">1089</font>        /**<a name="line.1089"></a>
<font color="green">1090</font>         * &lt;p&gt;Return the Java Class repesenting the property editor class that has<a name="line.1090"></a>
<font color="green">1091</font>         * been registered for this property (if any).  This method follows the<a name="line.1091"></a>
<font color="green">1092</font>         * same name resolution rules used by &lt;code&gt;getPropertyDescriptor()&lt;/code&gt;,<a name="line.1092"></a>
<font color="green">1093</font>         * so if the last element of a name reference is indexed, the property<a name="line.1093"></a>
<font color="green">1094</font>         * editor for the underlying property's class is returned.&lt;/p&gt;<a name="line.1094"></a>
<font color="green">1095</font>         *<a name="line.1095"></a>
<font color="green">1096</font>         * &lt;p&gt;Note that &lt;code&gt;null&lt;/code&gt; will be returned if there is no property,<a name="line.1096"></a>
<font color="green">1097</font>         * or if there is no registered property editor class.  Because this<a name="line.1097"></a>
<font color="green">1098</font>         * return value is ambiguous, you should determine the existence of the<a name="line.1098"></a>
<font color="green">1099</font>         * property itself by other means.&lt;/p&gt;<a name="line.1099"></a>
<font color="green">1100</font>         *<a name="line.1100"></a>
<font color="green">1101</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.1101"></a>
<font color="green">1102</font>         *<a name="line.1102"></a>
<font color="green">1103</font>         * @param bean Bean for which a property descriptor is requested<a name="line.1103"></a>
<font color="green">1104</font>         * @param name Possibly indexed and/or nested name of the property for<a name="line.1104"></a>
<font color="green">1105</font>         *  which a property descriptor is requested<a name="line.1105"></a>
<font color="green">1106</font>         * @return the property editor class<a name="line.1106"></a>
<font color="green">1107</font>         *<a name="line.1107"></a>
<font color="green">1108</font>         * @exception IllegalAccessException if the caller does not have<a name="line.1108"></a>
<font color="green">1109</font>         *  access to the property accessor method<a name="line.1109"></a>
<font color="green">1110</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.1110"></a>
<font color="green">1111</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.1111"></a>
<font color="green">1112</font>         * @exception IllegalArgumentException if a nested reference to a<a name="line.1112"></a>
<font color="green">1113</font>         *  property returns null<a name="line.1113"></a>
<font color="green">1114</font>         * @exception InvocationTargetException if the property accessor method<a name="line.1114"></a>
<font color="green">1115</font>         *  throws an exception<a name="line.1115"></a>
<font color="green">1116</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.1116"></a>
<font color="green">1117</font>         *  propety cannot be found<a name="line.1117"></a>
<font color="green">1118</font>         */<a name="line.1118"></a>
<font color="green">1119</font>        public Class getPropertyEditorClass(Object bean, String name)<a name="line.1119"></a>
<font color="green">1120</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.1120"></a>
<font color="green">1121</font>                NoSuchMethodException {<a name="line.1121"></a>
<font color="green">1122</font>    <a name="line.1122"></a>
<font color="green">1123</font>            if (bean == null) {<a name="line.1123"></a>
<font color="green">1124</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1124"></a>
<font color="green">1125</font>            }<a name="line.1125"></a>
<font color="green">1126</font>            if (name == null) {<a name="line.1126"></a>
<font color="green">1127</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1127"></a>
<font color="green">1128</font>                        bean.getClass() + "'");<a name="line.1128"></a>
<font color="green">1129</font>            }<a name="line.1129"></a>
<font color="green">1130</font>    <a name="line.1130"></a>
<font color="green">1131</font>            PropertyDescriptor descriptor =<a name="line.1131"></a>
<font color="green">1132</font>                    getPropertyDescriptor(bean, name);<a name="line.1132"></a>
<font color="green">1133</font>            if (descriptor != null) {<a name="line.1133"></a>
<font color="green">1134</font>                return (descriptor.getPropertyEditorClass());<a name="line.1134"></a>
<font color="green">1135</font>            } else {<a name="line.1135"></a>
<font color="green">1136</font>                return (null);<a name="line.1136"></a>
<font color="green">1137</font>            }<a name="line.1137"></a>
<font color="green">1138</font>    <a name="line.1138"></a>
<font color="green">1139</font>        }<a name="line.1139"></a>
<font color="green">1140</font>    <a name="line.1140"></a>
<font color="green">1141</font>    <a name="line.1141"></a>
<font color="green">1142</font>        /**<a name="line.1142"></a>
<font color="green">1143</font>         * Return the Java Class representing the property type of the specified<a name="line.1143"></a>
<font color="green">1144</font>         * property, or &lt;code&gt;null&lt;/code&gt; if there is no such property for the<a name="line.1144"></a>
<font color="green">1145</font>         * specified bean.  This method follows the same name resolution rules<a name="line.1145"></a>
<font color="green">1146</font>         * used by &lt;code&gt;getPropertyDescriptor()&lt;/code&gt;, so if the last element<a name="line.1146"></a>
<font color="green">1147</font>         * of a name reference is indexed, the type of the property itself will<a name="line.1147"></a>
<font color="green">1148</font>         * be returned.  If the last (or only) element has no property with the<a name="line.1148"></a>
<font color="green">1149</font>         * specified name, &lt;code&gt;null&lt;/code&gt; is returned.<a name="line.1149"></a>
<font color="green">1150</font>         *<a name="line.1150"></a>
<font color="green">1151</font>         * @param bean Bean for which a property descriptor is requested<a name="line.1151"></a>
<font color="green">1152</font>         * @param name Possibly indexed and/or nested name of the property for<a name="line.1152"></a>
<font color="green">1153</font>         *  which a property descriptor is requested<a name="line.1153"></a>
<font color="green">1154</font>         * @return The property type<a name="line.1154"></a>
<font color="green">1155</font>         *<a name="line.1155"></a>
<font color="green">1156</font>         * @exception IllegalAccessException if the caller does not have<a name="line.1156"></a>
<font color="green">1157</font>         *  access to the property accessor method<a name="line.1157"></a>
<font color="green">1158</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.1158"></a>
<font color="green">1159</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.1159"></a>
<font color="green">1160</font>         * @exception IllegalArgumentException if a nested reference to a<a name="line.1160"></a>
<font color="green">1161</font>         *  property returns null<a name="line.1161"></a>
<font color="green">1162</font>         * @exception InvocationTargetException if the property accessor method<a name="line.1162"></a>
<font color="green">1163</font>         *  throws an exception<a name="line.1163"></a>
<font color="green">1164</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.1164"></a>
<font color="green">1165</font>         *  propety cannot be found<a name="line.1165"></a>
<font color="green">1166</font>         */<a name="line.1166"></a>
<font color="green">1167</font>        public Class getPropertyType(Object bean, String name)<a name="line.1167"></a>
<font color="green">1168</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.1168"></a>
<font color="green">1169</font>                NoSuchMethodException {<a name="line.1169"></a>
<font color="green">1170</font>    <a name="line.1170"></a>
<font color="green">1171</font>            if (bean == null) {<a name="line.1171"></a>
<font color="green">1172</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1172"></a>
<font color="green">1173</font>            }<a name="line.1173"></a>
<font color="green">1174</font>            if (name == null) {<a name="line.1174"></a>
<font color="green">1175</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1175"></a>
<font color="green">1176</font>                        bean.getClass() + "'");<a name="line.1176"></a>
<font color="green">1177</font>            }<a name="line.1177"></a>
<font color="green">1178</font>    <a name="line.1178"></a>
<font color="green">1179</font>            // Resolve nested references<a name="line.1179"></a>
<font color="green">1180</font>            while (resolver.hasNested(name)) {<a name="line.1180"></a>
<font color="green">1181</font>                String next = resolver.next(name);<a name="line.1181"></a>
<font color="green">1182</font>                Object nestedBean = getProperty(bean, next);<a name="line.1182"></a>
<font color="green">1183</font>                if (nestedBean == null) {<a name="line.1183"></a>
<font color="green">1184</font>                    throw new NestedNullException<a name="line.1184"></a>
<font color="green">1185</font>                            ("Null property value for '" + next +<a name="line.1185"></a>
<font color="green">1186</font>                            "' on bean class '" + bean.getClass() + "'");<a name="line.1186"></a>
<font color="green">1187</font>                }<a name="line.1187"></a>
<font color="green">1188</font>                bean = nestedBean;<a name="line.1188"></a>
<font color="green">1189</font>                name = resolver.remove(name);<a name="line.1189"></a>
<font color="green">1190</font>            }<a name="line.1190"></a>
<font color="green">1191</font>    <a name="line.1191"></a>
<font color="green">1192</font>            // Remove any subscript from the final name value<a name="line.1192"></a>
<font color="green">1193</font>            name = resolver.getProperty(name);<a name="line.1193"></a>
<font color="green">1194</font>    <a name="line.1194"></a>
<font color="green">1195</font>            // Special handling for DynaBeans<a name="line.1195"></a>
<font color="green">1196</font>            if (bean instanceof DynaBean) {<a name="line.1196"></a>
<font color="green">1197</font>                DynaProperty descriptor =<a name="line.1197"></a>
<font color="green">1198</font>                        ((DynaBean) bean).getDynaClass().getDynaProperty(name);<a name="line.1198"></a>
<font color="green">1199</font>                if (descriptor == null) {<a name="line.1199"></a>
<font color="green">1200</font>                    return (null);<a name="line.1200"></a>
<font color="green">1201</font>                }<a name="line.1201"></a>
<font color="green">1202</font>                Class type = descriptor.getType();<a name="line.1202"></a>
<font color="green">1203</font>                if (type == null) {<a name="line.1203"></a>
<font color="green">1204</font>                    return (null);<a name="line.1204"></a>
<font color="green">1205</font>                } else if (type.isArray()) {<a name="line.1205"></a>
<font color="green">1206</font>                    return (type.getComponentType());<a name="line.1206"></a>
<font color="green">1207</font>                } else {<a name="line.1207"></a>
<font color="green">1208</font>                    return (type);<a name="line.1208"></a>
<font color="green">1209</font>                }<a name="line.1209"></a>
<font color="green">1210</font>            }<a name="line.1210"></a>
<font color="green">1211</font>    <a name="line.1211"></a>
<font color="green">1212</font>            PropertyDescriptor descriptor =<a name="line.1212"></a>
<font color="green">1213</font>                    getPropertyDescriptor(bean, name);<a name="line.1213"></a>
<font color="green">1214</font>            if (descriptor == null) {<a name="line.1214"></a>
<font color="green">1215</font>                return (null);<a name="line.1215"></a>
<font color="green">1216</font>            } else if (descriptor instanceof IndexedPropertyDescriptor) {<a name="line.1216"></a>
<font color="green">1217</font>                return (((IndexedPropertyDescriptor) descriptor).<a name="line.1217"></a>
<font color="green">1218</font>                        getIndexedPropertyType());<a name="line.1218"></a>
<font color="green">1219</font>            } else if (descriptor instanceof MappedPropertyDescriptor) {<a name="line.1219"></a>
<font color="green">1220</font>                return (((MappedPropertyDescriptor) descriptor).<a name="line.1220"></a>
<font color="green">1221</font>                        getMappedPropertyType());<a name="line.1221"></a>
<font color="green">1222</font>            } else {<a name="line.1222"></a>
<font color="green">1223</font>                return (descriptor.getPropertyType());<a name="line.1223"></a>
<font color="green">1224</font>            }<a name="line.1224"></a>
<font color="green">1225</font>    <a name="line.1225"></a>
<font color="green">1226</font>        }<a name="line.1226"></a>
<font color="green">1227</font>    <a name="line.1227"></a>
<font color="green">1228</font>    <a name="line.1228"></a>
<font color="green">1229</font>        /**<a name="line.1229"></a>
<font color="green">1230</font>         * &lt;p&gt;Return an accessible property getter method for this property,<a name="line.1230"></a>
<font color="green">1231</font>         * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.1231"></a>
<font color="green">1232</font>         *<a name="line.1232"></a>
<font color="green">1233</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.1233"></a>
<font color="green">1234</font>         *<a name="line.1234"></a>
<font color="green">1235</font>         * @param descriptor Property descriptor to return a getter for<a name="line.1235"></a>
<font color="green">1236</font>         * @return The read method<a name="line.1236"></a>
<font color="green">1237</font>         */<a name="line.1237"></a>
<font color="green">1238</font>        public Method getReadMethod(PropertyDescriptor descriptor) {<a name="line.1238"></a>
<font color="green">1239</font>    <a name="line.1239"></a>
<font color="green">1240</font>            return (MethodUtils.getAccessibleMethod(descriptor.getReadMethod()));<a name="line.1240"></a>
<font color="green">1241</font>    <a name="line.1241"></a>
<font color="green">1242</font>        }<a name="line.1242"></a>
<font color="green">1243</font>    <a name="line.1243"></a>
<font color="green">1244</font>    <a name="line.1244"></a>
<font color="green">1245</font>        /**<a name="line.1245"></a>
<font color="green">1246</font>         * &lt;p&gt;Return an accessible property getter method for this property,<a name="line.1246"></a>
<font color="green">1247</font>         * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.1247"></a>
<font color="green">1248</font>         *<a name="line.1248"></a>
<font color="green">1249</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.1249"></a>
<font color="green">1250</font>         *<a name="line.1250"></a>
<font color="green">1251</font>         * @param clazz The class of the read method will be invoked on<a name="line.1251"></a>
<font color="green">1252</font>         * @param descriptor Property descriptor to return a getter for<a name="line.1252"></a>
<font color="green">1253</font>         * @return The read method<a name="line.1253"></a>
<font color="green">1254</font>         */<a name="line.1254"></a>
<font color="green">1255</font>        Method getReadMethod(Class clazz, PropertyDescriptor descriptor) {<a name="line.1255"></a>
<font color="green">1256</font>            return (MethodUtils.getAccessibleMethod(clazz, descriptor.getReadMethod()));<a name="line.1256"></a>
<font color="green">1257</font>        }<a name="line.1257"></a>
<font color="green">1258</font>    <a name="line.1258"></a>
<font color="green">1259</font>    <a name="line.1259"></a>
<font color="green">1260</font>        /**<a name="line.1260"></a>
<font color="green">1261</font>         * Return the value of the specified simple property of the specified<a name="line.1261"></a>
<font color="green">1262</font>         * bean, with no type conversions.<a name="line.1262"></a>
<font color="green">1263</font>         *<a name="line.1263"></a>
<font color="green">1264</font>         * @param bean Bean whose property is to be extracted<a name="line.1264"></a>
<font color="green">1265</font>         * @param name Name of the property to be extracted<a name="line.1265"></a>
<font color="green">1266</font>         * @return The property value<a name="line.1266"></a>
<font color="green">1267</font>         *<a name="line.1267"></a>
<font color="green">1268</font>         * @exception IllegalAccessException if the caller does not have<a name="line.1268"></a>
<font color="green">1269</font>         *  access to the property accessor method<a name="line.1269"></a>
<font color="green">1270</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.1270"></a>
<font color="green">1271</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.1271"></a>
<font color="green">1272</font>         * @exception IllegalArgumentException if the property name<a name="line.1272"></a>
<font color="green">1273</font>         *  is nested or indexed<a name="line.1273"></a>
<font color="green">1274</font>         * @exception InvocationTargetException if the property accessor method<a name="line.1274"></a>
<font color="green">1275</font>         *  throws an exception<a name="line.1275"></a>
<font color="green">1276</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.1276"></a>
<font color="green">1277</font>         *  propety cannot be found<a name="line.1277"></a>
<font color="green">1278</font>         */<a name="line.1278"></a>
<font color="green">1279</font>        public Object getSimpleProperty(Object bean, String name)<a name="line.1279"></a>
<font color="green">1280</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.1280"></a>
<font color="green">1281</font>                NoSuchMethodException {<a name="line.1281"></a>
<font color="green">1282</font>    <a name="line.1282"></a>
<font color="green">1283</font>            if (bean == null) {<a name="line.1283"></a>
<font color="green">1284</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1284"></a>
<font color="green">1285</font>            }<a name="line.1285"></a>
<font color="green">1286</font>            if (name == null) {<a name="line.1286"></a>
<font color="green">1287</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1287"></a>
<font color="green">1288</font>                        bean.getClass() + "'");<a name="line.1288"></a>
<font color="green">1289</font>            }<a name="line.1289"></a>
<font color="green">1290</font>    <a name="line.1290"></a>
<font color="green">1291</font>            // Validate the syntax of the property name<a name="line.1291"></a>
<font color="green">1292</font>            if (resolver.hasNested(name)) {<a name="line.1292"></a>
<font color="green">1293</font>                throw new IllegalArgumentException<a name="line.1293"></a>
<font color="green">1294</font>                        ("Nested property names are not allowed: Property '" +<a name="line.1294"></a>
<font color="green">1295</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.1295"></a>
<font color="green">1296</font>            } else if (resolver.isIndexed(name)) {<a name="line.1296"></a>
<font color="green">1297</font>                throw new IllegalArgumentException<a name="line.1297"></a>
<font color="green">1298</font>                        ("Indexed property names are not allowed: Property '" +<a name="line.1298"></a>
<font color="green">1299</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.1299"></a>
<font color="green">1300</font>            } else if (resolver.isMapped(name)) {<a name="line.1300"></a>
<font color="green">1301</font>                throw new IllegalArgumentException<a name="line.1301"></a>
<font color="green">1302</font>                        ("Mapped property names are not allowed: Property '" +<a name="line.1302"></a>
<font color="green">1303</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.1303"></a>
<font color="green">1304</font>            }<a name="line.1304"></a>
<font color="green">1305</font>    <a name="line.1305"></a>
<font color="green">1306</font>            // Handle DynaBean instances specially<a name="line.1306"></a>
<font color="green">1307</font>            if (bean instanceof DynaBean) {<a name="line.1307"></a>
<font color="green">1308</font>                DynaProperty descriptor =<a name="line.1308"></a>
<font color="green">1309</font>                        ((DynaBean) bean).getDynaClass().getDynaProperty(name);<a name="line.1309"></a>
<font color="green">1310</font>                if (descriptor == null) {<a name="line.1310"></a>
<font color="green">1311</font>                    throw new NoSuchMethodException("Unknown property '" +<a name="line.1311"></a>
<font color="green">1312</font>                            name + "' on dynaclass '" + <a name="line.1312"></a>
<font color="green">1313</font>                            ((DynaBean) bean).getDynaClass() + "'" );<a name="line.1313"></a>
<font color="green">1314</font>                }<a name="line.1314"></a>
<font color="green">1315</font>                return (((DynaBean) bean).get(name));<a name="line.1315"></a>
<font color="green">1316</font>            }<a name="line.1316"></a>
<font color="green">1317</font>    <a name="line.1317"></a>
<font color="green">1318</font>            // Retrieve the property getter method for the specified property<a name="line.1318"></a>
<font color="green">1319</font>            PropertyDescriptor descriptor =<a name="line.1319"></a>
<font color="green">1320</font>                    getPropertyDescriptor(bean, name);<a name="line.1320"></a>
<font color="green">1321</font>            if (descriptor == null) {<a name="line.1321"></a>
<font color="green">1322</font>                throw new NoSuchMethodException("Unknown property '" +<a name="line.1322"></a>
<font color="green">1323</font>                        name + "' on class '" + bean.getClass() + "'" );<a name="line.1323"></a>
<font color="green">1324</font>            }<a name="line.1324"></a>
<font color="green">1325</font>            Method readMethod = getReadMethod(bean.getClass(), descriptor);<a name="line.1325"></a>
<font color="green">1326</font>            if (readMethod == null) {<a name="line.1326"></a>
<font color="green">1327</font>                throw new NoSuchMethodException("Property '" + name +<a name="line.1327"></a>
<font color="green">1328</font>                        "' has no getter method in class '" + bean.getClass() + "'");<a name="line.1328"></a>
<font color="green">1329</font>            }<a name="line.1329"></a>
<font color="green">1330</font>    <a name="line.1330"></a>
<font color="green">1331</font>            // Call the property getter and return the value<a name="line.1331"></a>
<font color="green">1332</font>            Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);<a name="line.1332"></a>
<font color="green">1333</font>            return (value);<a name="line.1333"></a>
<font color="green">1334</font>    <a name="line.1334"></a>
<font color="green">1335</font>        }<a name="line.1335"></a>
<font color="green">1336</font>    <a name="line.1336"></a>
<font color="green">1337</font>    <a name="line.1337"></a>
<font color="green">1338</font>        /**<a name="line.1338"></a>
<font color="green">1339</font>         * &lt;p&gt;Return an accessible property setter method for this property,<a name="line.1339"></a>
<font color="green">1340</font>         * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.1340"></a>
<font color="green">1341</font>         *<a name="line.1341"></a>
<font color="green">1342</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.1342"></a>
<font color="green">1343</font>         *<a name="line.1343"></a>
<font color="green">1344</font>         * @param descriptor Property descriptor to return a setter for<a name="line.1344"></a>
<font color="green">1345</font>         * @return The write method<a name="line.1345"></a>
<font color="green">1346</font>         */<a name="line.1346"></a>
<font color="green">1347</font>        public Method getWriteMethod(PropertyDescriptor descriptor) {<a name="line.1347"></a>
<font color="green">1348</font>    <a name="line.1348"></a>
<font color="green">1349</font>            return (MethodUtils.getAccessibleMethod(descriptor.getWriteMethod()));<a name="line.1349"></a>
<font color="green">1350</font>    <a name="line.1350"></a>
<font color="green">1351</font>        }<a name="line.1351"></a>
<font color="green">1352</font>    <a name="line.1352"></a>
<font color="green">1353</font>    <a name="line.1353"></a>
<font color="green">1354</font>        /**<a name="line.1354"></a>
<font color="green">1355</font>         * &lt;p&gt;Return an accessible property setter method for this property,<a name="line.1355"></a>
<font color="green">1356</font>         * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.1356"></a>
<font color="green">1357</font>         *<a name="line.1357"></a>
<font color="green">1358</font>         * &lt;p&gt;&lt;strong&gt;FIXME&lt;/strong&gt; - Does not work with DynaBeans.&lt;/p&gt;<a name="line.1358"></a>
<font color="green">1359</font>         *<a name="line.1359"></a>
<font color="green">1360</font>         * @param clazz The class of the read method will be invoked on<a name="line.1360"></a>
<font color="green">1361</font>         * @param descriptor Property descriptor to return a setter for<a name="line.1361"></a>
<font color="green">1362</font>         * @return The write method<a name="line.1362"></a>
<font color="green">1363</font>         */<a name="line.1363"></a>
<font color="green">1364</font>        Method getWriteMethod(Class clazz, PropertyDescriptor descriptor) {<a name="line.1364"></a>
<font color="green">1365</font>            return (MethodUtils.getAccessibleMethod(clazz, descriptor.getWriteMethod()));<a name="line.1365"></a>
<font color="green">1366</font>        }<a name="line.1366"></a>
<font color="green">1367</font>    <a name="line.1367"></a>
<font color="green">1368</font>    <a name="line.1368"></a>
<font color="green">1369</font>        /**<a name="line.1369"></a>
<font color="green">1370</font>         * &lt;p&gt;Return &lt;code&gt;true&lt;/code&gt; if the specified property name identifies<a name="line.1370"></a>
<font color="green">1371</font>         * a readable property on the specified bean; otherwise, return<a name="line.1371"></a>
<font color="green">1372</font>         * &lt;code&gt;false&lt;/code&gt;.<a name="line.1372"></a>
<font color="green">1373</font>         *<a name="line.1373"></a>
<font color="green">1374</font>         * @param bean Bean to be examined (may be a {@link DynaBean}<a name="line.1374"></a>
<font color="green">1375</font>         * @param name Property name to be evaluated<a name="line.1375"></a>
<font color="green">1376</font>         * @return &lt;code&gt;true&lt;/code&gt; if the property is readable,<a name="line.1376"></a>
<font color="green">1377</font>         * otherwise &lt;code&gt;false&lt;/code&gt;<a name="line.1377"></a>
<font color="green">1378</font>         *<a name="line.1378"></a>
<font color="green">1379</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt;<a name="line.1379"></a>
<font color="green">1380</font>         *  or &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;<a name="line.1380"></a>
<font color="green">1381</font>         *<a name="line.1381"></a>
<font color="green">1382</font>         * @since BeanUtils 1.6<a name="line.1382"></a>
<font color="green">1383</font>         */<a name="line.1383"></a>
<font color="green">1384</font>        public boolean isReadable(Object bean, String name) {<a name="line.1384"></a>
<font color="green">1385</font>    <a name="line.1385"></a>
<font color="green">1386</font>            // Validate method parameters<a name="line.1386"></a>
<font color="green">1387</font>            if (bean == null) {<a name="line.1387"></a>
<font color="green">1388</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1388"></a>
<font color="green">1389</font>            }<a name="line.1389"></a>
<font color="green">1390</font>            if (name == null) {<a name="line.1390"></a>
<font color="green">1391</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1391"></a>
<font color="green">1392</font>                        bean.getClass() + "'");<a name="line.1392"></a>
<font color="green">1393</font>            }<a name="line.1393"></a>
<font color="green">1394</font>    <a name="line.1394"></a>
<font color="green">1395</font>            // Resolve nested references<a name="line.1395"></a>
<font color="green">1396</font>            while (resolver.hasNested(name)) {<a name="line.1396"></a>
<font color="green">1397</font>                String next = resolver.next(name);<a name="line.1397"></a>
<font color="green">1398</font>                Object nestedBean = null; <a name="line.1398"></a>
<font color="green">1399</font>                try {<a name="line.1399"></a>
<font color="green">1400</font>                    nestedBean = getProperty(bean, next);<a name="line.1400"></a>
<font color="green">1401</font>                } catch (IllegalAccessException e) {<a name="line.1401"></a>
<font color="green">1402</font>                    return false;<a name="line.1402"></a>
<font color="green">1403</font>                } catch (InvocationTargetException e) {<a name="line.1403"></a>
<font color="green">1404</font>                    return false;<a name="line.1404"></a>
<font color="green">1405</font>                } catch (NoSuchMethodException e) {<a name="line.1405"></a>
<font color="green">1406</font>                    return false;<a name="line.1406"></a>
<font color="green">1407</font>                }<a name="line.1407"></a>
<font color="green">1408</font>                if (nestedBean == null) {<a name="line.1408"></a>
<font color="green">1409</font>                    throw new NestedNullException<a name="line.1409"></a>
<font color="green">1410</font>                            ("Null property value for '" + next +<a name="line.1410"></a>
<font color="green">1411</font>                            "' on bean class '" + bean.getClass() + "'");<a name="line.1411"></a>
<font color="green">1412</font>                }<a name="line.1412"></a>
<font color="green">1413</font>                bean = nestedBean;<a name="line.1413"></a>
<font color="green">1414</font>                name = resolver.remove(name);<a name="line.1414"></a>
<font color="green">1415</font>            }<a name="line.1415"></a>
<font color="green">1416</font>    <a name="line.1416"></a>
<font color="green">1417</font>            // Remove any subscript from the final name value<a name="line.1417"></a>
<font color="green">1418</font>            name = resolver.getProperty(name);<a name="line.1418"></a>
<font color="green">1419</font>    <a name="line.1419"></a>
<font color="green">1420</font>            // Treat WrapDynaBean as special case - may be a write-only property<a name="line.1420"></a>
<font color="green">1421</font>            // (see Jira issue# BEANUTILS-61)<a name="line.1421"></a>
<font color="green">1422</font>            if (bean instanceof WrapDynaBean) {<a name="line.1422"></a>
<font color="green">1423</font>                bean = ((WrapDynaBean)bean).getInstance();<a name="line.1423"></a>
<font color="green">1424</font>            }<a name="line.1424"></a>
<font color="green">1425</font>    <a name="line.1425"></a>
<font color="green">1426</font>            // Return the requested result<a name="line.1426"></a>
<font color="green">1427</font>            if (bean instanceof DynaBean) {<a name="line.1427"></a>
<font color="green">1428</font>                // All DynaBean properties are readable<a name="line.1428"></a>
<font color="green">1429</font>                return (((DynaBean) bean).getDynaClass().getDynaProperty(name) != null);<a name="line.1429"></a>
<font color="green">1430</font>            } else {<a name="line.1430"></a>
<font color="green">1431</font>                try {<a name="line.1431"></a>
<font color="green">1432</font>                    PropertyDescriptor desc =<a name="line.1432"></a>
<font color="green">1433</font>                        getPropertyDescriptor(bean, name);<a name="line.1433"></a>
<font color="green">1434</font>                    if (desc != null) {<a name="line.1434"></a>
<font color="green">1435</font>                        Method readMethod = getReadMethod(bean.getClass(), desc);<a name="line.1435"></a>
<font color="green">1436</font>                        if (readMethod == null) {<a name="line.1436"></a>
<font color="green">1437</font>                            if (desc instanceof IndexedPropertyDescriptor) {<a name="line.1437"></a>
<font color="green">1438</font>                                readMethod = ((IndexedPropertyDescriptor) desc).getIndexedReadMethod();<a name="line.1438"></a>
<font color="green">1439</font>                            } else if (desc instanceof MappedPropertyDescriptor) {<a name="line.1439"></a>
<font color="green">1440</font>                                readMethod = ((MappedPropertyDescriptor) desc).getMappedReadMethod();<a name="line.1440"></a>
<font color="green">1441</font>                            }<a name="line.1441"></a>
<font color="green">1442</font>                            readMethod = MethodUtils.getAccessibleMethod(bean.getClass(), readMethod);<a name="line.1442"></a>
<font color="green">1443</font>                        }<a name="line.1443"></a>
<font color="green">1444</font>                        return (readMethod != null);<a name="line.1444"></a>
<font color="green">1445</font>                    } else {<a name="line.1445"></a>
<font color="green">1446</font>                        return (false);<a name="line.1446"></a>
<font color="green">1447</font>                    }<a name="line.1447"></a>
<font color="green">1448</font>                } catch (IllegalAccessException e) {<a name="line.1448"></a>
<font color="green">1449</font>                    return (false);<a name="line.1449"></a>
<font color="green">1450</font>                } catch (InvocationTargetException e) {<a name="line.1450"></a>
<font color="green">1451</font>                    return (false);<a name="line.1451"></a>
<font color="green">1452</font>                } catch (NoSuchMethodException e) {<a name="line.1452"></a>
<font color="green">1453</font>                    return (false);<a name="line.1453"></a>
<font color="green">1454</font>                }<a name="line.1454"></a>
<font color="green">1455</font>            }<a name="line.1455"></a>
<font color="green">1456</font>    <a name="line.1456"></a>
<font color="green">1457</font>        }<a name="line.1457"></a>
<font color="green">1458</font>    <a name="line.1458"></a>
<font color="green">1459</font>    <a name="line.1459"></a>
<font color="green">1460</font>        /**<a name="line.1460"></a>
<font color="green">1461</font>         * &lt;p&gt;Return &lt;code&gt;true&lt;/code&gt; if the specified property name identifies<a name="line.1461"></a>
<font color="green">1462</font>         * a writeable property on the specified bean; otherwise, return<a name="line.1462"></a>
<font color="green">1463</font>         * &lt;code&gt;false&lt;/code&gt;.<a name="line.1463"></a>
<font color="green">1464</font>         *<a name="line.1464"></a>
<font color="green">1465</font>         * @param bean Bean to be examined (may be a {@link DynaBean}<a name="line.1465"></a>
<font color="green">1466</font>         * @param name Property name to be evaluated<a name="line.1466"></a>
<font color="green">1467</font>         * @return &lt;code&gt;true&lt;/code&gt; if the property is writeable,<a name="line.1467"></a>
<font color="green">1468</font>         * otherwise &lt;code&gt;false&lt;/code&gt;<a name="line.1468"></a>
<font color="green">1469</font>         *<a name="line.1469"></a>
<font color="green">1470</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt;<a name="line.1470"></a>
<font color="green">1471</font>         *  or &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;<a name="line.1471"></a>
<font color="green">1472</font>         *<a name="line.1472"></a>
<font color="green">1473</font>         * @since BeanUtils 1.6<a name="line.1473"></a>
<font color="green">1474</font>         */<a name="line.1474"></a>
<font color="green">1475</font>        public boolean isWriteable(Object bean, String name) {<a name="line.1475"></a>
<font color="green">1476</font>    <a name="line.1476"></a>
<font color="green">1477</font>            // Validate method parameters<a name="line.1477"></a>
<font color="green">1478</font>            if (bean == null) {<a name="line.1478"></a>
<font color="green">1479</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1479"></a>
<font color="green">1480</font>            }<a name="line.1480"></a>
<font color="green">1481</font>            if (name == null) {<a name="line.1481"></a>
<font color="green">1482</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1482"></a>
<font color="green">1483</font>                        bean.getClass() + "'");<a name="line.1483"></a>
<font color="green">1484</font>            }<a name="line.1484"></a>
<font color="green">1485</font>    <a name="line.1485"></a>
<font color="green">1486</font>            // Resolve nested references<a name="line.1486"></a>
<font color="green">1487</font>            while (resolver.hasNested(name)) {<a name="line.1487"></a>
<font color="green">1488</font>                String next = resolver.next(name);<a name="line.1488"></a>
<font color="green">1489</font>                Object nestedBean = null; <a name="line.1489"></a>
<font color="green">1490</font>                try {<a name="line.1490"></a>
<font color="green">1491</font>                    nestedBean = getProperty(bean, next);<a name="line.1491"></a>
<font color="green">1492</font>                } catch (IllegalAccessException e) {<a name="line.1492"></a>
<font color="green">1493</font>                    return false;<a name="line.1493"></a>
<font color="green">1494</font>                } catch (InvocationTargetException e) {<a name="line.1494"></a>
<font color="green">1495</font>                    return false;<a name="line.1495"></a>
<font color="green">1496</font>                } catch (NoSuchMethodException e) {<a name="line.1496"></a>
<font color="green">1497</font>                    return false;<a name="line.1497"></a>
<font color="green">1498</font>                }<a name="line.1498"></a>
<font color="green">1499</font>                if (nestedBean == null) {<a name="line.1499"></a>
<font color="green">1500</font>                    throw new NestedNullException<a name="line.1500"></a>
<font color="green">1501</font>                            ("Null property value for '" + next +<a name="line.1501"></a>
<font color="green">1502</font>                            "' on bean class '" + bean.getClass() + "'");<a name="line.1502"></a>
<font color="green">1503</font>                }<a name="line.1503"></a>
<font color="green">1504</font>                bean = nestedBean;<a name="line.1504"></a>
<font color="green">1505</font>                name = resolver.remove(name);<a name="line.1505"></a>
<font color="green">1506</font>            }<a name="line.1506"></a>
<font color="green">1507</font>    <a name="line.1507"></a>
<font color="green">1508</font>            // Remove any subscript from the final name value<a name="line.1508"></a>
<font color="green">1509</font>            name = resolver.getProperty(name);<a name="line.1509"></a>
<font color="green">1510</font>    <a name="line.1510"></a>
<font color="green">1511</font>            // Treat WrapDynaBean as special case - may be a read-only property<a name="line.1511"></a>
<font color="green">1512</font>            // (see Jira issue# BEANUTILS-61)<a name="line.1512"></a>
<font color="green">1513</font>            if (bean instanceof WrapDynaBean) {<a name="line.1513"></a>
<font color="green">1514</font>                bean = ((WrapDynaBean)bean).getInstance();<a name="line.1514"></a>
<font color="green">1515</font>            }<a name="line.1515"></a>
<font color="green">1516</font>    <a name="line.1516"></a>
<font color="green">1517</font>            // Return the requested result<a name="line.1517"></a>
<font color="green">1518</font>            if (bean instanceof DynaBean) {<a name="line.1518"></a>
<font color="green">1519</font>                // All DynaBean properties are writeable<a name="line.1519"></a>
<font color="green">1520</font>                return (((DynaBean) bean).getDynaClass().getDynaProperty(name) != null);<a name="line.1520"></a>
<font color="green">1521</font>            } else {<a name="line.1521"></a>
<font color="green">1522</font>                try {<a name="line.1522"></a>
<font color="green">1523</font>                    PropertyDescriptor desc =<a name="line.1523"></a>
<font color="green">1524</font>                        getPropertyDescriptor(bean, name);<a name="line.1524"></a>
<font color="green">1525</font>                    if (desc != null) {<a name="line.1525"></a>
<font color="green">1526</font>                        Method writeMethod = getWriteMethod(bean.getClass(), desc);<a name="line.1526"></a>
<font color="green">1527</font>                        if (writeMethod == null) {<a name="line.1527"></a>
<font color="green">1528</font>                            if (desc instanceof IndexedPropertyDescriptor) {<a name="line.1528"></a>
<font color="green">1529</font>                                writeMethod = ((IndexedPropertyDescriptor) desc).getIndexedWriteMethod();<a name="line.1529"></a>
<font color="green">1530</font>                            } else if (desc instanceof MappedPropertyDescriptor) {<a name="line.1530"></a>
<font color="green">1531</font>                                writeMethod = ((MappedPropertyDescriptor) desc).getMappedWriteMethod();<a name="line.1531"></a>
<font color="green">1532</font>                            }<a name="line.1532"></a>
<font color="green">1533</font>                            writeMethod = MethodUtils.getAccessibleMethod(bean.getClass(), writeMethod);<a name="line.1533"></a>
<font color="green">1534</font>                        }<a name="line.1534"></a>
<font color="green">1535</font>                        return (writeMethod != null);<a name="line.1535"></a>
<font color="green">1536</font>                    } else {<a name="line.1536"></a>
<font color="green">1537</font>                        return (false);<a name="line.1537"></a>
<font color="green">1538</font>                    }<a name="line.1538"></a>
<font color="green">1539</font>                } catch (IllegalAccessException e) {<a name="line.1539"></a>
<font color="green">1540</font>                    return (false);<a name="line.1540"></a>
<font color="green">1541</font>                } catch (InvocationTargetException e) {<a name="line.1541"></a>
<font color="green">1542</font>                    return (false);<a name="line.1542"></a>
<font color="green">1543</font>                } catch (NoSuchMethodException e) {<a name="line.1543"></a>
<font color="green">1544</font>                    return (false);<a name="line.1544"></a>
<font color="green">1545</font>                }<a name="line.1545"></a>
<font color="green">1546</font>            }<a name="line.1546"></a>
<font color="green">1547</font>    <a name="line.1547"></a>
<font color="green">1548</font>        }<a name="line.1548"></a>
<font color="green">1549</font>    <a name="line.1549"></a>
<font color="green">1550</font>    <a name="line.1550"></a>
<font color="green">1551</font>        /**<a name="line.1551"></a>
<font color="green">1552</font>         * Set the value of the specified indexed property of the specified<a name="line.1552"></a>
<font color="green">1553</font>         * bean, with no type conversions.  The zero-relative index of the<a name="line.1553"></a>
<font color="green">1554</font>         * required value must be included (in square brackets) as a suffix to<a name="line.1554"></a>
<font color="green">1555</font>         * the property name, or &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be<a name="line.1555"></a>
<font color="green">1556</font>         * thrown.  In addition to supporting the JavaBeans specification, this<a name="line.1556"></a>
<font color="green">1557</font>         * method has been extended to support &lt;code&gt;List&lt;/code&gt; objects as well.<a name="line.1557"></a>
<font color="green">1558</font>         *<a name="line.1558"></a>
<font color="green">1559</font>         * @param bean Bean whose property is to be modified<a name="line.1559"></a>
<font color="green">1560</font>         * @param name &lt;code&gt;propertyname[index]&lt;/code&gt; of the property value<a name="line.1560"></a>
<font color="green">1561</font>         *  to be modified<a name="line.1561"></a>
<font color="green">1562</font>         * @param value Value to which the specified property element<a name="line.1562"></a>
<font color="green">1563</font>         *  should be set<a name="line.1563"></a>
<font color="green">1564</font>         *<a name="line.1564"></a>
<font color="green">1565</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.1565"></a>
<font color="green">1566</font>         *  is outside the valid range for the underlying property<a name="line.1566"></a>
<font color="green">1567</font>         * @exception IllegalAccessException if the caller does not have<a name="line.1567"></a>
<font color="green">1568</font>         *  access to the property accessor method<a name="line.1568"></a>
<font color="green">1569</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.1569"></a>
<font color="green">1570</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.1570"></a>
<font color="green">1571</font>         * @exception InvocationTargetException if the property accessor method<a name="line.1571"></a>
<font color="green">1572</font>         *  throws an exception<a name="line.1572"></a>
<font color="green">1573</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.1573"></a>
<font color="green">1574</font>         *  propety cannot be found<a name="line.1574"></a>
<font color="green">1575</font>         */<a name="line.1575"></a>
<font color="green">1576</font>        public void setIndexedProperty(Object bean, String name,<a name="line.1576"></a>
<font color="green">1577</font>                                              Object value)<a name="line.1577"></a>
<font color="green">1578</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.1578"></a>
<font color="green">1579</font>                NoSuchMethodException {<a name="line.1579"></a>
<font color="green">1580</font>    <a name="line.1580"></a>
<font color="green">1581</font>            if (bean == null) {<a name="line.1581"></a>
<font color="green">1582</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1582"></a>
<font color="green">1583</font>            }<a name="line.1583"></a>
<font color="green">1584</font>            if (name == null) {<a name="line.1584"></a>
<font color="green">1585</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1585"></a>
<font color="green">1586</font>                        bean.getClass() + "'");<a name="line.1586"></a>
<font color="green">1587</font>            }<a name="line.1587"></a>
<font color="green">1588</font>    <a name="line.1588"></a>
<font color="green">1589</font>            // Identify the index of the requested individual property<a name="line.1589"></a>
<font color="green">1590</font>            int index = -1;<a name="line.1590"></a>
<font color="green">1591</font>            try {<a name="line.1591"></a>
<font color="green">1592</font>                index = resolver.getIndex(name);<a name="line.1592"></a>
<font color="green">1593</font>            } catch (IllegalArgumentException e) {<a name="line.1593"></a>
<font color="green">1594</font>                throw new IllegalArgumentException("Invalid indexed property '" +<a name="line.1594"></a>
<font color="green">1595</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.1595"></a>
<font color="green">1596</font>            }<a name="line.1596"></a>
<font color="green">1597</font>            if (index &lt; 0) {<a name="line.1597"></a>
<font color="green">1598</font>                throw new IllegalArgumentException("Invalid indexed property '" +<a name="line.1598"></a>
<font color="green">1599</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.1599"></a>
<font color="green">1600</font>            }<a name="line.1600"></a>
<font color="green">1601</font>    <a name="line.1601"></a>
<font color="green">1602</font>            // Isolate the name<a name="line.1602"></a>
<font color="green">1603</font>            name = resolver.getProperty(name);<a name="line.1603"></a>
<font color="green">1604</font>    <a name="line.1604"></a>
<font color="green">1605</font>            // Set the specified indexed property value<a name="line.1605"></a>
<font color="green">1606</font>            setIndexedProperty(bean, name, index, value);<a name="line.1606"></a>
<font color="green">1607</font>    <a name="line.1607"></a>
<font color="green">1608</font>        }<a name="line.1608"></a>
<font color="green">1609</font>    <a name="line.1609"></a>
<font color="green">1610</font>    <a name="line.1610"></a>
<font color="green">1611</font>        /**<a name="line.1611"></a>
<font color="green">1612</font>         * Set the value of the specified indexed property of the specified<a name="line.1612"></a>
<font color="green">1613</font>         * bean, with no type conversions.  In addition to supporting the JavaBeans<a name="line.1613"></a>
<font color="green">1614</font>         * specification, this method has been extended to support<a name="line.1614"></a>
<font color="green">1615</font>         * &lt;code&gt;List&lt;/code&gt; objects as well.<a name="line.1615"></a>
<font color="green">1616</font>         *<a name="line.1616"></a>
<font color="green">1617</font>         * @param bean Bean whose property is to be set<a name="line.1617"></a>
<font color="green">1618</font>         * @param name Simple property name of the property value to be set<a name="line.1618"></a>
<font color="green">1619</font>         * @param index Index of the property value to be set<a name="line.1619"></a>
<font color="green">1620</font>         * @param value Value to which the indexed property element is to be set<a name="line.1620"></a>
<font color="green">1621</font>         *<a name="line.1621"></a>
<font color="green">1622</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.1622"></a>
<font color="green">1623</font>         *  is outside the valid range for the underlying property<a name="line.1623"></a>
<font color="green">1624</font>         * @exception IllegalAccessException if the caller does not have<a name="line.1624"></a>
<font color="green">1625</font>         *  access to the property accessor method<a name="line.1625"></a>
<font color="green">1626</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.1626"></a>
<font color="green">1627</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.1627"></a>
<font color="green">1628</font>         * @exception InvocationTargetException if the property accessor method<a name="line.1628"></a>
<font color="green">1629</font>         *  throws an exception<a name="line.1629"></a>
<font color="green">1630</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.1630"></a>
<font color="green">1631</font>         *  propety cannot be found<a name="line.1631"></a>
<font color="green">1632</font>         */<a name="line.1632"></a>
<font color="green">1633</font>        public void setIndexedProperty(Object bean, String name,<a name="line.1633"></a>
<font color="green">1634</font>                                              int index, Object value)<a name="line.1634"></a>
<font color="green">1635</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.1635"></a>
<font color="green">1636</font>                NoSuchMethodException {<a name="line.1636"></a>
<font color="green">1637</font>    <a name="line.1637"></a>
<font color="green">1638</font>            if (bean == null) {<a name="line.1638"></a>
<font color="green">1639</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1639"></a>
<font color="green">1640</font>            }<a name="line.1640"></a>
<font color="green">1641</font>            if (name == null || name.length() == 0) {<a name="line.1641"></a>
<font color="green">1642</font>                if (bean.getClass().isArray()) {<a name="line.1642"></a>
<font color="green">1643</font>                    Array.set(bean, index, value);<a name="line.1643"></a>
<font color="green">1644</font>                    return;<a name="line.1644"></a>
<font color="green">1645</font>                } else if (bean instanceof List) {<a name="line.1645"></a>
<font color="green">1646</font>                    ((List)bean).set(index, value);   <a name="line.1646"></a>
<font color="green">1647</font>                    return;<a name="line.1647"></a>
<font color="green">1648</font>                }<a name="line.1648"></a>
<font color="green">1649</font>            }<a name="line.1649"></a>
<font color="green">1650</font>            if (name == null) {<a name="line.1650"></a>
<font color="green">1651</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1651"></a>
<font color="green">1652</font>                        bean.getClass() + "'");<a name="line.1652"></a>
<font color="green">1653</font>            }<a name="line.1653"></a>
<font color="green">1654</font>    <a name="line.1654"></a>
<font color="green">1655</font>            // Handle DynaBean instances specially<a name="line.1655"></a>
<font color="green">1656</font>            if (bean instanceof DynaBean) {<a name="line.1656"></a>
<font color="green">1657</font>                DynaProperty descriptor =<a name="line.1657"></a>
<font color="green">1658</font>                        ((DynaBean) bean).getDynaClass().getDynaProperty(name);<a name="line.1658"></a>
<font color="green">1659</font>                if (descriptor == null) {<a name="line.1659"></a>
<font color="green">1660</font>                    throw new NoSuchMethodException("Unknown property '" +<a name="line.1660"></a>
<font color="green">1661</font>                            name + "' on bean class '" + bean.getClass() + "'");<a name="line.1661"></a>
<font color="green">1662</font>                }<a name="line.1662"></a>
<font color="green">1663</font>                ((DynaBean) bean).set(name, index, value);<a name="line.1663"></a>
<font color="green">1664</font>                return;<a name="line.1664"></a>
<font color="green">1665</font>            }<a name="line.1665"></a>
<font color="green">1666</font>    <a name="line.1666"></a>
<font color="green">1667</font>            // Retrieve the property descriptor for the specified property<a name="line.1667"></a>
<font color="green">1668</font>            PropertyDescriptor descriptor =<a name="line.1668"></a>
<font color="green">1669</font>                    getPropertyDescriptor(bean, name);<a name="line.1669"></a>
<font color="green">1670</font>            if (descriptor == null) {<a name="line.1670"></a>
<font color="green">1671</font>                throw new NoSuchMethodException("Unknown property '" +<a name="line.1671"></a>
<font color="green">1672</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.1672"></a>
<font color="green">1673</font>            }<a name="line.1673"></a>
<font color="green">1674</font>    <a name="line.1674"></a>
<font color="green">1675</font>            // Call the indexed setter method if there is one<a name="line.1675"></a>
<font color="green">1676</font>            if (descriptor instanceof IndexedPropertyDescriptor) {<a name="line.1676"></a>
<font color="green">1677</font>                Method writeMethod = ((IndexedPropertyDescriptor) descriptor).<a name="line.1677"></a>
<font color="green">1678</font>                        getIndexedWriteMethod();<a name="line.1678"></a>
<font color="green">1679</font>                writeMethod = MethodUtils.getAccessibleMethod(bean.getClass(), writeMethod);<a name="line.1679"></a>
<font color="green">1680</font>                if (writeMethod != null) {<a name="line.1680"></a>
<font color="green">1681</font>                    Object[] subscript = new Object[2];<a name="line.1681"></a>
<font color="green">1682</font>                    subscript[0] = new Integer(index);<a name="line.1682"></a>
<font color="green">1683</font>                    subscript[1] = value;<a name="line.1683"></a>
<font color="green">1684</font>                    try {<a name="line.1684"></a>
<font color="green">1685</font>                        if (log.isTraceEnabled()) {<a name="line.1685"></a>
<font color="green">1686</font>                            String valueClassName =<a name="line.1686"></a>
<font color="green">1687</font>                                value == null ? "&lt;null&gt;" <a name="line.1687"></a>
<font color="green">1688</font>                                              : value.getClass().getName();<a name="line.1688"></a>
<font color="green">1689</font>                            log.trace("setSimpleProperty: Invoking method "<a name="line.1689"></a>
<font color="green">1690</font>                                      + writeMethod +" with index=" + index<a name="line.1690"></a>
<font color="green">1691</font>                                      + ", value=" + value<a name="line.1691"></a>
<font color="green">1692</font>                                      + " (class " + valueClassName+ ")");<a name="line.1692"></a>
<font color="green">1693</font>                        }<a name="line.1693"></a>
<font color="green">1694</font>                        invokeMethod(writeMethod, bean, subscript);<a name="line.1694"></a>
<font color="green">1695</font>                    } catch (InvocationTargetException e) {<a name="line.1695"></a>
<font color="green">1696</font>                        if (e.getTargetException() instanceof<a name="line.1696"></a>
<font color="green">1697</font>                                IndexOutOfBoundsException) {<a name="line.1697"></a>
<font color="green">1698</font>                            throw (IndexOutOfBoundsException)<a name="line.1698"></a>
<font color="green">1699</font>                                    e.getTargetException();<a name="line.1699"></a>
<font color="green">1700</font>                        } else {<a name="line.1700"></a>
<font color="green">1701</font>                            throw e;<a name="line.1701"></a>
<font color="green">1702</font>                        }<a name="line.1702"></a>
<font color="green">1703</font>                    }<a name="line.1703"></a>
<font color="green">1704</font>                    return;<a name="line.1704"></a>
<font color="green">1705</font>                }<a name="line.1705"></a>
<font color="green">1706</font>            }<a name="line.1706"></a>
<font color="green">1707</font>    <a name="line.1707"></a>
<font color="green">1708</font>            // Otherwise, the underlying property must be an array or a list<a name="line.1708"></a>
<font color="green">1709</font>            Method readMethod = getReadMethod(bean.getClass(), descriptor);<a name="line.1709"></a>
<font color="green">1710</font>            if (readMethod == null) {<a name="line.1710"></a>
<font color="green">1711</font>                throw new NoSuchMethodException("Property '" + name +<a name="line.1711"></a>
<font color="green">1712</font>                        "' has no getter method on bean class '" + bean.getClass() + "'");<a name="line.1712"></a>
<font color="green">1713</font>            }<a name="line.1713"></a>
<font color="green">1714</font>    <a name="line.1714"></a>
<font color="green">1715</font>            // Call the property getter to get the array or list<a name="line.1715"></a>
<font color="green">1716</font>            Object array = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);<a name="line.1716"></a>
<font color="green">1717</font>            if (!array.getClass().isArray()) {<a name="line.1717"></a>
<font color="green">1718</font>                if (array instanceof List) {<a name="line.1718"></a>
<font color="green">1719</font>                    // Modify the specified value in the List<a name="line.1719"></a>
<font color="green">1720</font>                    ((List) array).set(index, value);<a name="line.1720"></a>
<font color="green">1721</font>                } else {<a name="line.1721"></a>
<font color="green">1722</font>                    throw new IllegalArgumentException("Property '" + name +<a name="line.1722"></a>
<font color="green">1723</font>                            "' is not indexed on bean class '" + bean.getClass() + "'");<a name="line.1723"></a>
<font color="green">1724</font>                }<a name="line.1724"></a>
<font color="green">1725</font>            } else {<a name="line.1725"></a>
<font color="green">1726</font>                // Modify the specified value in the array<a name="line.1726"></a>
<font color="green">1727</font>                Array.set(array, index, value);<a name="line.1727"></a>
<font color="green">1728</font>            }<a name="line.1728"></a>
<font color="green">1729</font>    <a name="line.1729"></a>
<font color="green">1730</font>        }<a name="line.1730"></a>
<font color="green">1731</font>    <a name="line.1731"></a>
<font color="green">1732</font>    <a name="line.1732"></a>
<font color="green">1733</font>        /**<a name="line.1733"></a>
<font color="green">1734</font>         * Set the value of the specified mapped property of the<a name="line.1734"></a>
<font color="green">1735</font>         * specified bean, with no type conversions.  The key of the<a name="line.1735"></a>
<font color="green">1736</font>         * value to set must be included (in brackets) as a suffix to<a name="line.1736"></a>
<font color="green">1737</font>         * the property name, or &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be<a name="line.1737"></a>
<font color="green">1738</font>         * thrown.<a name="line.1738"></a>
<font color="green">1739</font>         *<a name="line.1739"></a>
<font color="green">1740</font>         * @param bean Bean whose property is to be set<a name="line.1740"></a>
<font color="green">1741</font>         * @param name &lt;code&gt;propertyname(key)&lt;/code&gt; of the property value<a name="line.1741"></a>
<font color="green">1742</font>         *  to be set<a name="line.1742"></a>
<font color="green">1743</font>         * @param value The property value to be set<a name="line.1743"></a>
<font color="green">1744</font>         *<a name="line.1744"></a>
<font color="green">1745</font>         * @exception IllegalAccessException if the caller does not have<a name="line.1745"></a>
<font color="green">1746</font>         *  access to the property accessor method<a name="line.1746"></a>
<font color="green">1747</font>         * @exception InvocationTargetException if the property accessor method<a name="line.1747"></a>
<font color="green">1748</font>         *  throws an exception<a name="line.1748"></a>
<font color="green">1749</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.1749"></a>
<font color="green">1750</font>         *  propety cannot be found<a name="line.1750"></a>
<font color="green">1751</font>         */<a name="line.1751"></a>
<font color="green">1752</font>        public void setMappedProperty(Object bean, String name,<a name="line.1752"></a>
<font color="green">1753</font>                                             Object value)<a name="line.1753"></a>
<font color="green">1754</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.1754"></a>
<font color="green">1755</font>                NoSuchMethodException {<a name="line.1755"></a>
<font color="green">1756</font>    <a name="line.1756"></a>
<font color="green">1757</font>            if (bean == null) {<a name="line.1757"></a>
<font color="green">1758</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1758"></a>
<font color="green">1759</font>            }<a name="line.1759"></a>
<font color="green">1760</font>            if (name == null) {<a name="line.1760"></a>
<font color="green">1761</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1761"></a>
<font color="green">1762</font>                        bean.getClass() + "'");<a name="line.1762"></a>
<font color="green">1763</font>            }<a name="line.1763"></a>
<font color="green">1764</font>    <a name="line.1764"></a>
<font color="green">1765</font>            // Identify the key of the requested individual property<a name="line.1765"></a>
<font color="green">1766</font>            String key  = null;<a name="line.1766"></a>
<font color="green">1767</font>            try {<a name="line.1767"></a>
<font color="green">1768</font>                key = resolver.getKey(name);<a name="line.1768"></a>
<font color="green">1769</font>            } catch (IllegalArgumentException e) {<a name="line.1769"></a>
<font color="green">1770</font>                throw new IllegalArgumentException<a name="line.1770"></a>
<font color="green">1771</font>                        ("Invalid mapped property '" + name + <a name="line.1771"></a>
<font color="green">1772</font>                        "' on bean class '" + bean.getClass() + "'");<a name="line.1772"></a>
<font color="green">1773</font>            }<a name="line.1773"></a>
<font color="green">1774</font>            if (key == null) {<a name="line.1774"></a>
<font color="green">1775</font>                throw new IllegalArgumentException<a name="line.1775"></a>
<font color="green">1776</font>                        ("Invalid mapped property '" + name + <a name="line.1776"></a>
<font color="green">1777</font>                        "' on bean class '" + bean.getClass() + "'");<a name="line.1777"></a>
<font color="green">1778</font>            }<a name="line.1778"></a>
<font color="green">1779</font>    <a name="line.1779"></a>
<font color="green">1780</font>            // Isolate the name<a name="line.1780"></a>
<font color="green">1781</font>            name = resolver.getProperty(name);<a name="line.1781"></a>
<font color="green">1782</font>    <a name="line.1782"></a>
<font color="green">1783</font>            // Request the specified indexed property value<a name="line.1783"></a>
<font color="green">1784</font>            setMappedProperty(bean, name, key, value);<a name="line.1784"></a>
<font color="green">1785</font>    <a name="line.1785"></a>
<font color="green">1786</font>        }<a name="line.1786"></a>
<font color="green">1787</font>    <a name="line.1787"></a>
<font color="green">1788</font>    <a name="line.1788"></a>
<font color="green">1789</font>        /**<a name="line.1789"></a>
<font color="green">1790</font>         * Set the value of the specified mapped property of the specified<a name="line.1790"></a>
<font color="green">1791</font>         * bean, with no type conversions.<a name="line.1791"></a>
<font color="green">1792</font>         *<a name="line.1792"></a>
<font color="green">1793</font>         * @param bean Bean whose property is to be set<a name="line.1793"></a>
<font color="green">1794</font>         * @param name Mapped property name of the property value to be set<a name="line.1794"></a>
<font color="green">1795</font>         * @param key Key of the property value to be set<a name="line.1795"></a>
<font color="green">1796</font>         * @param value The property value to be set<a name="line.1796"></a>
<font color="green">1797</font>         *<a name="line.1797"></a>
<font color="green">1798</font>         * @exception IllegalAccessException if the caller does not have<a name="line.1798"></a>
<font color="green">1799</font>         *  access to the property accessor method<a name="line.1799"></a>
<font color="green">1800</font>         * @exception InvocationTargetException if the property accessor method<a name="line.1800"></a>
<font color="green">1801</font>         *  throws an exception<a name="line.1801"></a>
<font color="green">1802</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.1802"></a>
<font color="green">1803</font>         *  propety cannot be found<a name="line.1803"></a>
<font color="green">1804</font>         */<a name="line.1804"></a>
<font color="green">1805</font>        public void setMappedProperty(Object bean, String name,<a name="line.1805"></a>
<font color="green">1806</font>                                             String key, Object value)<a name="line.1806"></a>
<font color="green">1807</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.1807"></a>
<font color="green">1808</font>                NoSuchMethodException {<a name="line.1808"></a>
<font color="green">1809</font>    <a name="line.1809"></a>
<font color="green">1810</font>            if (bean == null) {<a name="line.1810"></a>
<font color="green">1811</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1811"></a>
<font color="green">1812</font>            }<a name="line.1812"></a>
<font color="green">1813</font>            if (name == null) {<a name="line.1813"></a>
<font color="green">1814</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1814"></a>
<font color="green">1815</font>                        bean.getClass() + "'");<a name="line.1815"></a>
<font color="green">1816</font>            }<a name="line.1816"></a>
<font color="green">1817</font>            if (key == null) {<a name="line.1817"></a>
<font color="green">1818</font>                throw new IllegalArgumentException("No key specified for property '" +<a name="line.1818"></a>
<font color="green">1819</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.1819"></a>
<font color="green">1820</font>            }<a name="line.1820"></a>
<font color="green">1821</font>    <a name="line.1821"></a>
<font color="green">1822</font>            // Handle DynaBean instances specially<a name="line.1822"></a>
<font color="green">1823</font>            if (bean instanceof DynaBean) {<a name="line.1823"></a>
<font color="green">1824</font>                DynaProperty descriptor =<a name="line.1824"></a>
<font color="green">1825</font>                        ((DynaBean) bean).getDynaClass().getDynaProperty(name);<a name="line.1825"></a>
<font color="green">1826</font>                if (descriptor == null) {<a name="line.1826"></a>
<font color="green">1827</font>                    throw new NoSuchMethodException("Unknown property '" +<a name="line.1827"></a>
<font color="green">1828</font>                            name + "' on bean class '" + bean.getClass() + "'");<a name="line.1828"></a>
<font color="green">1829</font>                }<a name="line.1829"></a>
<font color="green">1830</font>                ((DynaBean) bean).set(name, key, value);<a name="line.1830"></a>
<font color="green">1831</font>                return;<a name="line.1831"></a>
<font color="green">1832</font>            }<a name="line.1832"></a>
<font color="green">1833</font>    <a name="line.1833"></a>
<font color="green">1834</font>            // Retrieve the property descriptor for the specified property<a name="line.1834"></a>
<font color="green">1835</font>            PropertyDescriptor descriptor =<a name="line.1835"></a>
<font color="green">1836</font>                    getPropertyDescriptor(bean, name);<a name="line.1836"></a>
<font color="green">1837</font>            if (descriptor == null) {<a name="line.1837"></a>
<font color="green">1838</font>                throw new NoSuchMethodException("Unknown property '" +<a name="line.1838"></a>
<font color="green">1839</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.1839"></a>
<font color="green">1840</font>            }<a name="line.1840"></a>
<font color="green">1841</font>    <a name="line.1841"></a>
<font color="green">1842</font>            if (descriptor instanceof MappedPropertyDescriptor) {<a name="line.1842"></a>
<font color="green">1843</font>                // Call the keyed setter method if there is one<a name="line.1843"></a>
<font color="green">1844</font>                Method mappedWriteMethod =<a name="line.1844"></a>
<font color="green">1845</font>                        ((MappedPropertyDescriptor) descriptor).<a name="line.1845"></a>
<font color="green">1846</font>                        getMappedWriteMethod();<a name="line.1846"></a>
<font color="green">1847</font>                mappedWriteMethod = MethodUtils.getAccessibleMethod(bean.getClass(), mappedWriteMethod);<a name="line.1847"></a>
<font color="green">1848</font>                if (mappedWriteMethod != null) {<a name="line.1848"></a>
<font color="green">1849</font>                    Object[] params = new Object[2];<a name="line.1849"></a>
<font color="green">1850</font>                    params[0] = key;<a name="line.1850"></a>
<font color="green">1851</font>                    params[1] = value;<a name="line.1851"></a>
<font color="green">1852</font>                    if (log.isTraceEnabled()) {<a name="line.1852"></a>
<font color="green">1853</font>                        String valueClassName =<a name="line.1853"></a>
<font color="green">1854</font>                            value == null ? "&lt;null&gt;" : value.getClass().getName();<a name="line.1854"></a>
<font color="green">1855</font>                        log.trace("setSimpleProperty: Invoking method "<a name="line.1855"></a>
<font color="green">1856</font>                                  + mappedWriteMethod + " with key=" + key<a name="line.1856"></a>
<font color="green">1857</font>                                  + ", value=" + value<a name="line.1857"></a>
<font color="green">1858</font>                                  + " (class " + valueClassName +")");<a name="line.1858"></a>
<font color="green">1859</font>                    }<a name="line.1859"></a>
<font color="green">1860</font>                    invokeMethod(mappedWriteMethod, bean, params);<a name="line.1860"></a>
<font color="green">1861</font>                } else {<a name="line.1861"></a>
<font color="green">1862</font>                    throw new NoSuchMethodException<a name="line.1862"></a>
<font color="green">1863</font>                        ("Property '" + name + "' has no mapped setter method" +<a name="line.1863"></a>
<font color="green">1864</font>                         "on bean class '" + bean.getClass() + "'");<a name="line.1864"></a>
<font color="green">1865</font>                }<a name="line.1865"></a>
<font color="green">1866</font>            } else {<a name="line.1866"></a>
<font color="green">1867</font>              /* means that the result has to be retrieved from a map */<a name="line.1867"></a>
<font color="green">1868</font>              Method readMethod = getReadMethod(bean.getClass(), descriptor);<a name="line.1868"></a>
<font color="green">1869</font>              if (readMethod != null) {<a name="line.1869"></a>
<font color="green">1870</font>                Object invokeResult = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);<a name="line.1870"></a>
<font color="green">1871</font>                /* test and fetch from the map */<a name="line.1871"></a>
<font color="green">1872</font>                if (invokeResult instanceof java.util.Map) {<a name="line.1872"></a>
<font color="green">1873</font>                  ((java.util.Map)invokeResult).put(key, value);<a name="line.1873"></a>
<font color="green">1874</font>                }<a name="line.1874"></a>
<font color="green">1875</font>              } else {<a name="line.1875"></a>
<font color="green">1876</font>                throw new NoSuchMethodException("Property '" + name +<a name="line.1876"></a>
<font color="green">1877</font>                        "' has no mapped getter method on bean class '" +<a name="line.1877"></a>
<font color="green">1878</font>                        bean.getClass() + "'");<a name="line.1878"></a>
<font color="green">1879</font>              }<a name="line.1879"></a>
<font color="green">1880</font>            }<a name="line.1880"></a>
<font color="green">1881</font>    <a name="line.1881"></a>
<font color="green">1882</font>        }<a name="line.1882"></a>
<font color="green">1883</font>    <a name="line.1883"></a>
<font color="green">1884</font>    <a name="line.1884"></a>
<font color="green">1885</font>        /**<a name="line.1885"></a>
<font color="green">1886</font>         * Set the value of the (possibly nested) property of the specified<a name="line.1886"></a>
<font color="green">1887</font>         * name, for the specified bean, with no type conversions.<a name="line.1887"></a>
<font color="green">1888</font>         * &lt;p&gt;<a name="line.1888"></a>
<font color="green">1889</font>         * Example values for parameter "name" are:<a name="line.1889"></a>
<font color="green">1890</font>         * &lt;ul&gt;<a name="line.1890"></a>
<font color="green">1891</font>         * &lt;li&gt; "a" -- sets the value of property a of the specified bean &lt;/li&gt;<a name="line.1891"></a>
<font color="green">1892</font>         * &lt;li&gt; "a.b" -- gets the value of property a of the specified bean,<a name="line.1892"></a>
<font color="green">1893</font>         * then on that object sets the value of property b.&lt;/li&gt;<a name="line.1893"></a>
<font color="green">1894</font>         * &lt;li&gt; "a(key)" -- sets a value of mapped-property a on the specified<a name="line.1894"></a>
<font color="green">1895</font>         * bean. This effectively means bean.setA("key").&lt;/li&gt;<a name="line.1895"></a>
<font color="green">1896</font>         * &lt;li&gt; "a[3]" -- sets a value of indexed-property a on the specified<a name="line.1896"></a>
<font color="green">1897</font>         * bean. This effectively means bean.setA(3).&lt;/li&gt;<a name="line.1897"></a>
<font color="green">1898</font>         * &lt;/ul&gt;<a name="line.1898"></a>
<font color="green">1899</font>         *<a name="line.1899"></a>
<font color="green">1900</font>         * @param bean Bean whose property is to be modified<a name="line.1900"></a>
<font color="green">1901</font>         * @param name Possibly nested name of the property to be modified<a name="line.1901"></a>
<font color="green">1902</font>         * @param value Value to which the property is to be set<a name="line.1902"></a>
<font color="green">1903</font>         *<a name="line.1903"></a>
<font color="green">1904</font>         * @exception IllegalAccessException if the caller does not have<a name="line.1904"></a>
<font color="green">1905</font>         *  access to the property accessor method<a name="line.1905"></a>
<font color="green">1906</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.1906"></a>
<font color="green">1907</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.1907"></a>
<font color="green">1908</font>         * @exception IllegalArgumentException if a nested reference to a<a name="line.1908"></a>
<font color="green">1909</font>         *  property returns null<a name="line.1909"></a>
<font color="green">1910</font>         * @exception InvocationTargetException if the property accessor method<a name="line.1910"></a>
<font color="green">1911</font>         *  throws an exception<a name="line.1911"></a>
<font color="green">1912</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.1912"></a>
<font color="green">1913</font>         *  propety cannot be found<a name="line.1913"></a>
<font color="green">1914</font>         */<a name="line.1914"></a>
<font color="green">1915</font>        public void setNestedProperty(Object bean,<a name="line.1915"></a>
<font color="green">1916</font>                                             String name, Object value)<a name="line.1916"></a>
<font color="green">1917</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.1917"></a>
<font color="green">1918</font>                NoSuchMethodException {<a name="line.1918"></a>
<font color="green">1919</font>    <a name="line.1919"></a>
<font color="green">1920</font>            if (bean == null) {<a name="line.1920"></a>
<font color="green">1921</font>                throw new IllegalArgumentException("No bean specified");<a name="line.1921"></a>
<font color="green">1922</font>            }<a name="line.1922"></a>
<font color="green">1923</font>            if (name == null) {<a name="line.1923"></a>
<font color="green">1924</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.1924"></a>
<font color="green">1925</font>                        bean.getClass() + "'");<a name="line.1925"></a>
<font color="green">1926</font>            }<a name="line.1926"></a>
<font color="green">1927</font>    <a name="line.1927"></a>
<font color="green">1928</font>            // Resolve nested references<a name="line.1928"></a>
<font color="green">1929</font>            while (resolver.hasNested(name)) {<a name="line.1929"></a>
<font color="green">1930</font>                String next = resolver.next(name);<a name="line.1930"></a>
<font color="green">1931</font>                Object nestedBean = null;<a name="line.1931"></a>
<font color="green">1932</font>                if (bean instanceof Map) {<a name="line.1932"></a>
<font color="green">1933</font>                    nestedBean = getPropertyOfMapBean((Map)bean, next);<a name="line.1933"></a>
<font color="green">1934</font>                } else if (resolver.isMapped(next)) {<a name="line.1934"></a>
<font color="green">1935</font>                    nestedBean = getMappedProperty(bean, next);<a name="line.1935"></a>
<font color="green">1936</font>                } else if (resolver.isIndexed(next)) {<a name="line.1936"></a>
<font color="green">1937</font>                    nestedBean = getIndexedProperty(bean, next);<a name="line.1937"></a>
<font color="green">1938</font>                } else {<a name="line.1938"></a>
<font color="green">1939</font>                    nestedBean = getSimpleProperty(bean, next);<a name="line.1939"></a>
<font color="green">1940</font>                }<a name="line.1940"></a>
<font color="green">1941</font>                if (nestedBean == null) {<a name="line.1941"></a>
<font color="green">1942</font>                    throw new NestedNullException<a name="line.1942"></a>
<font color="green">1943</font>                            ("Null property value for '" + name +<a name="line.1943"></a>
<font color="green">1944</font>                             "' on bean class '" + bean.getClass() + "'");<a name="line.1944"></a>
<font color="green">1945</font>                }<a name="line.1945"></a>
<font color="green">1946</font>                bean = nestedBean;<a name="line.1946"></a>
<font color="green">1947</font>                name = resolver.remove(name);<a name="line.1947"></a>
<font color="green">1948</font>            }<a name="line.1948"></a>
<font color="green">1949</font>    <a name="line.1949"></a>
<font color="green">1950</font>            if (bean instanceof Map) {<a name="line.1950"></a>
<font color="green">1951</font>                setPropertyOfMapBean((Map) bean, name, value);<a name="line.1951"></a>
<font color="green">1952</font>            } else if (resolver.isMapped(name)) {<a name="line.1952"></a>
<font color="green">1953</font>                setMappedProperty(bean, name, value);<a name="line.1953"></a>
<font color="green">1954</font>            } else if (resolver.isIndexed(name)) {<a name="line.1954"></a>
<font color="green">1955</font>                setIndexedProperty(bean, name, value);<a name="line.1955"></a>
<font color="green">1956</font>            } else {<a name="line.1956"></a>
<font color="green">1957</font>                setSimpleProperty(bean, name, value);<a name="line.1957"></a>
<font color="green">1958</font>            }<a name="line.1958"></a>
<font color="green">1959</font>    <a name="line.1959"></a>
<font color="green">1960</font>        }<a name="line.1960"></a>
<font color="green">1961</font>    <a name="line.1961"></a>
<font color="green">1962</font>        /**<a name="line.1962"></a>
<font color="green">1963</font>         * This method is called by method setNestedProperty when the current bean<a name="line.1963"></a>
<font color="green">1964</font>         * is found to be a Map object, and defines how to deal with setting<a name="line.1964"></a>
<font color="green">1965</font>         * a property on a Map.<a name="line.1965"></a>
<font color="green">1966</font>         * &lt;p&gt;<a name="line.1966"></a>
<font color="green">1967</font>         * The standard implementation here is to:<a name="line.1967"></a>
<font color="green">1968</font>         * &lt;ul&gt;<a name="line.1968"></a>
<font color="green">1969</font>         * &lt;li&gt;call bean.set(propertyName) for all propertyName values.&lt;/li&gt;<a name="line.1969"></a>
<font color="green">1970</font>         * &lt;li&gt;throw an IllegalArgumentException if the property specifier<a name="line.1970"></a>
<font color="green">1971</font>         * contains MAPPED_DELIM or INDEXED_DELIM, as Map entries are essentially<a name="line.1971"></a>
<font color="green">1972</font>         * simple properties; mapping and indexing operations do not make sense<a name="line.1972"></a>
<font color="green">1973</font>         * when accessing a map (even thought the returned object may be a Map<a name="line.1973"></a>
<font color="green">1974</font>         * or an Array).&lt;/li&gt;<a name="line.1974"></a>
<font color="green">1975</font>         * &lt;/ul&gt;<a name="line.1975"></a>
<font color="green">1976</font>         * &lt;p&gt;<a name="line.1976"></a>
<font color="green">1977</font>         * The default behaviour of beanutils 1.7.1 or later is for assigning to<a name="line.1977"></a>
<font color="green">1978</font>         * "a.b" to mean a.put(b, obj) always. However the behaviour of beanutils <a name="line.1978"></a>
<font color="green">1979</font>         * version 1.6.0, 1.6.1, 1.7.0 was for "a.b" to mean a.setB(obj) if such<a name="line.1979"></a>
<font color="green">1980</font>         * a method existed, and a.put(b, obj) otherwise. In version 1.5 it meant<a name="line.1980"></a>
<font color="green">1981</font>         * a.put(b, obj) always (ie the same as the behaviour in the current version).<a name="line.1981"></a>
<font color="green">1982</font>         * In versions prior to 1.5 it meant a.setB(obj) always. [yes, this is <a name="line.1982"></a>
<font color="green">1983</font>         * all &lt;i&gt;very&lt;/i&gt; unfortunate]<a name="line.1983"></a>
<font color="green">1984</font>         * &lt;p&gt;<a name="line.1984"></a>
<font color="green">1985</font>         * Users who would like to customise the meaning of "a.b" in method <a name="line.1985"></a>
<font color="green">1986</font>         * setNestedProperty when a is a Map can create a custom subclass of<a name="line.1986"></a>
<font color="green">1987</font>         * this class and override this method to implement the behaviour of <a name="line.1987"></a>
<font color="green">1988</font>         * their choice, such as restoring the pre-1.4 behaviour of this class<a name="line.1988"></a>
<font color="green">1989</font>         * if they wish. When overriding this method, do not forget to deal <a name="line.1989"></a>
<font color="green">1990</font>         * with MAPPED_DELIM and INDEXED_DELIM characters in the propertyName.<a name="line.1990"></a>
<font color="green">1991</font>         * &lt;p&gt;<a name="line.1991"></a>
<font color="green">1992</font>         * Note, however, that the recommended solution for objects that<a name="line.1992"></a>
<font color="green">1993</font>         * implement Map but want their simple properties to come first is<a name="line.1993"></a>
<font color="green">1994</font>         * for &lt;i&gt;those&lt;/i&gt; objects to override their get/put methods to implement<a name="line.1994"></a>
<font color="green">1995</font>         * that behaviour, and &lt;i&gt;not&lt;/i&gt; to solve the problem by modifying the<a name="line.1995"></a>
<font color="green">1996</font>         * default behaviour of the PropertyUtilsBean class by overriding this<a name="line.1996"></a>
<font color="green">1997</font>         * method.<a name="line.1997"></a>
<font color="green">1998</font>         *<a name="line.1998"></a>
<font color="green">1999</font>         * @param bean Map bean<a name="line.1999"></a>
<font color="green">2000</font>         * @param propertyName The property name<a name="line.2000"></a>
<font color="green">2001</font>         * @param value the property value<a name="line.2001"></a>
<font color="green">2002</font>         * <a name="line.2002"></a>
<font color="green">2003</font>         * @throws IllegalArgumentException when the propertyName is regarded as<a name="line.2003"></a>
<font color="green">2004</font>         * being invalid.<a name="line.2004"></a>
<font color="green">2005</font>         * <a name="line.2005"></a>
<font color="green">2006</font>         * @throws IllegalAccessException just in case subclasses override this<a name="line.2006"></a>
<font color="green">2007</font>         * method to try to access real setter methods and find permission is denied.<a name="line.2007"></a>
<font color="green">2008</font>         * <a name="line.2008"></a>
<font color="green">2009</font>         * @throws InvocationTargetException just in case subclasses override this<a name="line.2009"></a>
<font color="green">2010</font>         * method to try to access real setter methods, and find it throws an<a name="line.2010"></a>
<font color="green">2011</font>         * exception when invoked.<a name="line.2011"></a>
<font color="green">2012</font>         * <a name="line.2012"></a>
<font color="green">2013</font>         * @throws NoSuchMethodException just in case subclasses override this<a name="line.2013"></a>
<font color="green">2014</font>         * method to try to access real setter methods, and want to fail if<a name="line.2014"></a>
<font color="green">2015</font>         * no simple method is available.<a name="line.2015"></a>
<font color="green">2016</font>         * @since 1.8.0<a name="line.2016"></a>
<font color="green">2017</font>         */<a name="line.2017"></a>
<font color="green">2018</font>        protected void setPropertyOfMapBean(Map bean, String propertyName, Object value)<a name="line.2018"></a>
<font color="green">2019</font>            throws IllegalArgumentException, IllegalAccessException, <a name="line.2019"></a>
<font color="green">2020</font>            InvocationTargetException, NoSuchMethodException {<a name="line.2020"></a>
<font color="green">2021</font>    <a name="line.2021"></a>
<font color="green">2022</font>            if (resolver.isMapped(propertyName)) {<a name="line.2022"></a>
<font color="green">2023</font>                String name = resolver.getProperty(propertyName);<a name="line.2023"></a>
<font color="green">2024</font>                if (name == null || name.length() == 0) {<a name="line.2024"></a>
<font color="green">2025</font>                    propertyName = resolver.getKey(propertyName);<a name="line.2025"></a>
<font color="green">2026</font>                }<a name="line.2026"></a>
<font color="green">2027</font>            }<a name="line.2027"></a>
<font color="green">2028</font>    <a name="line.2028"></a>
<font color="green">2029</font>            if (resolver.isIndexed(propertyName) ||<a name="line.2029"></a>
<font color="green">2030</font>                resolver.isMapped(propertyName)) {<a name="line.2030"></a>
<font color="green">2031</font>                throw new IllegalArgumentException(<a name="line.2031"></a>
<font color="green">2032</font>                        "Indexed or mapped properties are not supported on"<a name="line.2032"></a>
<font color="green">2033</font>                        + " objects of type Map: " + propertyName);<a name="line.2033"></a>
<font color="green">2034</font>            }<a name="line.2034"></a>
<font color="green">2035</font>    <a name="line.2035"></a>
<font color="green">2036</font>            bean.put(propertyName, value);<a name="line.2036"></a>
<font color="green">2037</font>        }<a name="line.2037"></a>
<font color="green">2038</font>    <a name="line.2038"></a>
<font color="green">2039</font>    <a name="line.2039"></a>
<font color="green">2040</font>    <a name="line.2040"></a>
<font color="green">2041</font>        /**<a name="line.2041"></a>
<font color="green">2042</font>         * Set the value of the specified property of the specified bean,<a name="line.2042"></a>
<font color="green">2043</font>         * no matter which property reference format is used, with no<a name="line.2043"></a>
<font color="green">2044</font>         * type conversions.<a name="line.2044"></a>
<font color="green">2045</font>         *<a name="line.2045"></a>
<font color="green">2046</font>         * @param bean Bean whose property is to be modified<a name="line.2046"></a>
<font color="green">2047</font>         * @param name Possibly indexed and/or nested name of the property<a name="line.2047"></a>
<font color="green">2048</font>         *  to be modified<a name="line.2048"></a>
<font color="green">2049</font>         * @param value Value to which this property is to be set<a name="line.2049"></a>
<font color="green">2050</font>         *<a name="line.2050"></a>
<font color="green">2051</font>         * @exception IllegalAccessException if the caller does not have<a name="line.2051"></a>
<font color="green">2052</font>         *  access to the property accessor method<a name="line.2052"></a>
<font color="green">2053</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.2053"></a>
<font color="green">2054</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.2054"></a>
<font color="green">2055</font>         * @exception InvocationTargetException if the property accessor method<a name="line.2055"></a>
<font color="green">2056</font>         *  throws an exception<a name="line.2056"></a>
<font color="green">2057</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.2057"></a>
<font color="green">2058</font>         *  propety cannot be found<a name="line.2058"></a>
<font color="green">2059</font>         */<a name="line.2059"></a>
<font color="green">2060</font>        public void setProperty(Object bean, String name, Object value)<a name="line.2060"></a>
<font color="green">2061</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.2061"></a>
<font color="green">2062</font>                NoSuchMethodException {<a name="line.2062"></a>
<font color="green">2063</font>    <a name="line.2063"></a>
<font color="green">2064</font>            setNestedProperty(bean, name, value);<a name="line.2064"></a>
<font color="green">2065</font>    <a name="line.2065"></a>
<font color="green">2066</font>        }<a name="line.2066"></a>
<font color="green">2067</font>    <a name="line.2067"></a>
<font color="green">2068</font>    <a name="line.2068"></a>
<font color="green">2069</font>        /**<a name="line.2069"></a>
<font color="green">2070</font>         * Set the value of the specified simple property of the specified bean,<a name="line.2070"></a>
<font color="green">2071</font>         * with no type conversions.<a name="line.2071"></a>
<font color="green">2072</font>         *<a name="line.2072"></a>
<font color="green">2073</font>         * @param bean Bean whose property is to be modified<a name="line.2073"></a>
<font color="green">2074</font>         * @param name Name of the property to be modified<a name="line.2074"></a>
<font color="green">2075</font>         * @param value Value to which the property should be set<a name="line.2075"></a>
<font color="green">2076</font>         *<a name="line.2076"></a>
<font color="green">2077</font>         * @exception IllegalAccessException if the caller does not have<a name="line.2077"></a>
<font color="green">2078</font>         *  access to the property accessor method<a name="line.2078"></a>
<font color="green">2079</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.2079"></a>
<font color="green">2080</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.2080"></a>
<font color="green">2081</font>         * @exception IllegalArgumentException if the property name is<a name="line.2081"></a>
<font color="green">2082</font>         *  nested or indexed<a name="line.2082"></a>
<font color="green">2083</font>         * @exception InvocationTargetException if the property accessor method<a name="line.2083"></a>
<font color="green">2084</font>         *  throws an exception<a name="line.2084"></a>
<font color="green">2085</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.2085"></a>
<font color="green">2086</font>         *  propety cannot be found<a name="line.2086"></a>
<font color="green">2087</font>         */<a name="line.2087"></a>
<font color="green">2088</font>        public void setSimpleProperty(Object bean,<a name="line.2088"></a>
<font color="green">2089</font>                                             String name, Object value)<a name="line.2089"></a>
<font color="green">2090</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.2090"></a>
<font color="green">2091</font>                NoSuchMethodException {<a name="line.2091"></a>
<font color="green">2092</font>    <a name="line.2092"></a>
<font color="green">2093</font>            if (bean == null) {<a name="line.2093"></a>
<font color="green">2094</font>                throw new IllegalArgumentException("No bean specified");<a name="line.2094"></a>
<font color="green">2095</font>            }<a name="line.2095"></a>
<font color="green">2096</font>            if (name == null) {<a name="line.2096"></a>
<font color="green">2097</font>                throw new IllegalArgumentException("No name specified for bean class '" +<a name="line.2097"></a>
<font color="green">2098</font>                        bean.getClass() + "'");<a name="line.2098"></a>
<font color="green">2099</font>            }<a name="line.2099"></a>
<font color="green">2100</font>    <a name="line.2100"></a>
<font color="green">2101</font>            // Validate the syntax of the property name<a name="line.2101"></a>
<font color="green">2102</font>            if (resolver.hasNested(name)) {<a name="line.2102"></a>
<font color="green">2103</font>                throw new IllegalArgumentException<a name="line.2103"></a>
<font color="green">2104</font>                        ("Nested property names are not allowed: Property '" +<a name="line.2104"></a>
<font color="green">2105</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.2105"></a>
<font color="green">2106</font>            } else if (resolver.isIndexed(name)) {<a name="line.2106"></a>
<font color="green">2107</font>                throw new IllegalArgumentException<a name="line.2107"></a>
<font color="green">2108</font>                        ("Indexed property names are not allowed: Property '" +<a name="line.2108"></a>
<font color="green">2109</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.2109"></a>
<font color="green">2110</font>            } else if (resolver.isMapped(name)) {<a name="line.2110"></a>
<font color="green">2111</font>                throw new IllegalArgumentException<a name="line.2111"></a>
<font color="green">2112</font>                        ("Mapped property names are not allowed: Property '" +<a name="line.2112"></a>
<font color="green">2113</font>                        name + "' on bean class '" + bean.getClass() + "'");<a name="line.2113"></a>
<font color="green">2114</font>            }<a name="line.2114"></a>
<font color="green">2115</font>    <a name="line.2115"></a>
<font color="green">2116</font>            // Handle DynaBean instances specially<a name="line.2116"></a>
<font color="green">2117</font>            if (bean instanceof DynaBean) {<a name="line.2117"></a>
<font color="green">2118</font>                DynaProperty descriptor =<a name="line.2118"></a>
<font color="green">2119</font>                        ((DynaBean) bean).getDynaClass().getDynaProperty(name);<a name="line.2119"></a>
<font color="green">2120</font>                if (descriptor == null) {<a name="line.2120"></a>
<font color="green">2121</font>                    throw new NoSuchMethodException("Unknown property '" +<a name="line.2121"></a>
<font color="green">2122</font>                            name + "' on dynaclass '" + <a name="line.2122"></a>
<font color="green">2123</font>                            ((DynaBean) bean).getDynaClass() + "'" );<a name="line.2123"></a>
<font color="green">2124</font>                }<a name="line.2124"></a>
<font color="green">2125</font>                ((DynaBean) bean).set(name, value);<a name="line.2125"></a>
<font color="green">2126</font>                return;<a name="line.2126"></a>
<font color="green">2127</font>            }<a name="line.2127"></a>
<font color="green">2128</font>    <a name="line.2128"></a>
<font color="green">2129</font>            // Retrieve the property setter method for the specified property<a name="line.2129"></a>
<font color="green">2130</font>            PropertyDescriptor descriptor =<a name="line.2130"></a>
<font color="green">2131</font>                    getPropertyDescriptor(bean, name);<a name="line.2131"></a>
<font color="green">2132</font>            if (descriptor == null) {<a name="line.2132"></a>
<font color="green">2133</font>                throw new NoSuchMethodException("Unknown property '" +<a name="line.2133"></a>
<font color="green">2134</font>                        name + "' on class '" + bean.getClass() + "'" );<a name="line.2134"></a>
<font color="green">2135</font>            }<a name="line.2135"></a>
<font color="green">2136</font>            Method writeMethod = getWriteMethod(bean.getClass(), descriptor);<a name="line.2136"></a>
<font color="green">2137</font>            if (writeMethod == null) {<a name="line.2137"></a>
<font color="green">2138</font>                throw new NoSuchMethodException("Property '" + name +<a name="line.2138"></a>
<font color="green">2139</font>                        "' has no setter method in class '" + bean.getClass() + "'");<a name="line.2139"></a>
<font color="green">2140</font>            }<a name="line.2140"></a>
<font color="green">2141</font>    <a name="line.2141"></a>
<font color="green">2142</font>            // Call the property setter method<a name="line.2142"></a>
<font color="green">2143</font>            Object[] values = new Object[1];<a name="line.2143"></a>
<font color="green">2144</font>            values[0] = value;<a name="line.2144"></a>
<font color="green">2145</font>            if (log.isTraceEnabled()) {<a name="line.2145"></a>
<font color="green">2146</font>                String valueClassName =<a name="line.2146"></a>
<font color="green">2147</font>                    value == null ? "&lt;null&gt;" : value.getClass().getName();<a name="line.2147"></a>
<font color="green">2148</font>                log.trace("setSimpleProperty: Invoking method " + writeMethod<a name="line.2148"></a>
<font color="green">2149</font>                          + " with value " + value + " (class " + valueClassName + ")");<a name="line.2149"></a>
<font color="green">2150</font>            }<a name="line.2150"></a>
<font color="green">2151</font>            invokeMethod(writeMethod, bean, values);<a name="line.2151"></a>
<font color="green">2152</font>    <a name="line.2152"></a>
<font color="green">2153</font>        }<a name="line.2153"></a>
<font color="green">2154</font>        <a name="line.2154"></a>
<font color="green">2155</font>        /** This just catches and wraps IllegalArgumentException. */<a name="line.2155"></a>
<font color="green">2156</font>        private Object invokeMethod(<a name="line.2156"></a>
<font color="green">2157</font>                            Method method, <a name="line.2157"></a>
<font color="green">2158</font>                            Object bean, <a name="line.2158"></a>
<font color="green">2159</font>                            Object[] values) <a name="line.2159"></a>
<font color="green">2160</font>                                throws<a name="line.2160"></a>
<font color="green">2161</font>                                    IllegalAccessException,<a name="line.2161"></a>
<font color="green">2162</font>                                    InvocationTargetException {<a name="line.2162"></a>
<font color="green">2163</font>            if(bean == null) {<a name="line.2163"></a>
<font color="green">2164</font>                throw new IllegalArgumentException("No bean specified " +<a name="line.2164"></a>
<font color="green">2165</font>                    "- this should have been checked before reaching this method");<a name="line.2165"></a>
<font color="green">2166</font>            }<a name="line.2166"></a>
<font color="green">2167</font>    <a name="line.2167"></a>
<font color="green">2168</font>            try {<a name="line.2168"></a>
<font color="green">2169</font>                <a name="line.2169"></a>
<font color="green">2170</font>                return method.invoke(bean, values);<a name="line.2170"></a>
<font color="green">2171</font>            <a name="line.2171"></a>
<font color="green">2172</font>            } catch (NullPointerException cause) {<a name="line.2172"></a>
<font color="green">2173</font>                // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is<a name="line.2173"></a>
<font color="green">2174</font>                // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)<a name="line.2174"></a>
<font color="green">2175</font>                String valueString = "";<a name="line.2175"></a>
<font color="green">2176</font>                if (values != null) {<a name="line.2176"></a>
<font color="green">2177</font>                    for (int i = 0; i &lt; values.length; i++) {<a name="line.2177"></a>
<font color="green">2178</font>                        if (i&gt;0) {<a name="line.2178"></a>
<font color="green">2179</font>                            valueString += ", " ;<a name="line.2179"></a>
<font color="green">2180</font>                        }<a name="line.2180"></a>
<font color="green">2181</font>                        if (values[i] == null) {<a name="line.2181"></a>
<font color="green">2182</font>                            valueString += "&lt;null&gt;";<a name="line.2182"></a>
<font color="green">2183</font>                        } else {<a name="line.2183"></a>
<font color="green">2184</font>                            valueString += (values[i]).getClass().getName();<a name="line.2184"></a>
<font color="green">2185</font>                        }<a name="line.2185"></a>
<font color="green">2186</font>                    }<a name="line.2186"></a>
<font color="green">2187</font>                }<a name="line.2187"></a>
<font color="green">2188</font>                String expectedString = "";<a name="line.2188"></a>
<font color="green">2189</font>                Class[] parTypes = method.getParameterTypes();<a name="line.2189"></a>
<font color="green">2190</font>                if (parTypes != null) {<a name="line.2190"></a>
<font color="green">2191</font>                    for (int i = 0; i &lt; parTypes.length; i++) {<a name="line.2191"></a>
<font color="green">2192</font>                        if (i &gt; 0) {<a name="line.2192"></a>
<font color="green">2193</font>                            expectedString += ", ";<a name="line.2193"></a>
<font color="green">2194</font>                        }<a name="line.2194"></a>
<font color="green">2195</font>                        expectedString += parTypes[i].getName();<a name="line.2195"></a>
<font color="green">2196</font>                    }<a name="line.2196"></a>
<font color="green">2197</font>                }<a name="line.2197"></a>
<font color="green">2198</font>                IllegalArgumentException e = new IllegalArgumentException(<a name="line.2198"></a>
<font color="green">2199</font>                    "Cannot invoke " + method.getDeclaringClass().getName() + "." <a name="line.2199"></a>
<font color="green">2200</font>                    + method.getName() + " on bean class '" + bean.getClass() +<a name="line.2200"></a>
<font color="green">2201</font>                    "' - " + cause.getMessage()<a name="line.2201"></a>
<font color="green">2202</font>                    // as per https://issues.apache.org/jira/browse/BEANUTILS-224<a name="line.2202"></a>
<font color="green">2203</font>                    + " - had objects of type \"" + valueString<a name="line.2203"></a>
<font color="green">2204</font>                    + "\" but expected signature \""<a name="line.2204"></a>
<font color="green">2205</font>                    +   expectedString + "\""<a name="line.2205"></a>
<font color="green">2206</font>                    );<a name="line.2206"></a>
<font color="green">2207</font>                if (!BeanUtils.initCause(e, cause)) {<a name="line.2207"></a>
<font color="green">2208</font>                    log.error("Method invocation failed", cause);<a name="line.2208"></a>
<font color="green">2209</font>                }<a name="line.2209"></a>
<font color="green">2210</font>                throw e;<a name="line.2210"></a>
<font color="green">2211</font>            } catch (IllegalArgumentException cause) {<a name="line.2211"></a>
<font color="green">2212</font>                String valueString = "";<a name="line.2212"></a>
<font color="green">2213</font>                if (values != null) {<a name="line.2213"></a>
<font color="green">2214</font>                    for (int i = 0; i &lt; values.length; i++) {<a name="line.2214"></a>
<font color="green">2215</font>                        if (i&gt;0) {<a name="line.2215"></a>
<font color="green">2216</font>                            valueString += ", " ;<a name="line.2216"></a>
<font color="green">2217</font>                        }<a name="line.2217"></a>
<font color="green">2218</font>                        if (values[i] == null) {<a name="line.2218"></a>
<font color="green">2219</font>                            valueString += "&lt;null&gt;";<a name="line.2219"></a>
<font color="green">2220</font>                        } else {<a name="line.2220"></a>
<font color="green">2221</font>                            valueString += (values[i]).getClass().getName();<a name="line.2221"></a>
<font color="green">2222</font>                        }<a name="line.2222"></a>
<font color="green">2223</font>                    }<a name="line.2223"></a>
<font color="green">2224</font>                }<a name="line.2224"></a>
<font color="green">2225</font>                String expectedString = "";<a name="line.2225"></a>
<font color="green">2226</font>                Class[] parTypes = method.getParameterTypes();<a name="line.2226"></a>
<font color="green">2227</font>                if (parTypes != null) {<a name="line.2227"></a>
<font color="green">2228</font>                    for (int i = 0; i &lt; parTypes.length; i++) {<a name="line.2228"></a>
<font color="green">2229</font>                        if (i &gt; 0) {<a name="line.2229"></a>
<font color="green">2230</font>                            expectedString += ", ";<a name="line.2230"></a>
<font color="green">2231</font>                        }<a name="line.2231"></a>
<font color="green">2232</font>                        expectedString += parTypes[i].getName();<a name="line.2232"></a>
<font color="green">2233</font>                    }<a name="line.2233"></a>
<font color="green">2234</font>                }<a name="line.2234"></a>
<font color="green">2235</font>                IllegalArgumentException e = new IllegalArgumentException(<a name="line.2235"></a>
<font color="green">2236</font>                    "Cannot invoke " + method.getDeclaringClass().getName() + "." <a name="line.2236"></a>
<font color="green">2237</font>                    + method.getName() + " on bean class '" + bean.getClass() +<a name="line.2237"></a>
<font color="green">2238</font>                    "' - " + cause.getMessage()<a name="line.2238"></a>
<font color="green">2239</font>                    // as per https://issues.apache.org/jira/browse/BEANUTILS-224<a name="line.2239"></a>
<font color="green">2240</font>                    + " - had objects of type \"" + valueString<a name="line.2240"></a>
<font color="green">2241</font>                    + "\" but expected signature \""<a name="line.2241"></a>
<font color="green">2242</font>                    +   expectedString + "\""<a name="line.2242"></a>
<font color="green">2243</font>                    );<a name="line.2243"></a>
<font color="green">2244</font>                if (!BeanUtils.initCause(e, cause)) {<a name="line.2244"></a>
<font color="green">2245</font>                    log.error("Method invocation failed", cause);<a name="line.2245"></a>
<font color="green">2246</font>                }<a name="line.2246"></a>
<font color="green">2247</font>                throw e;<a name="line.2247"></a>
<font color="green">2248</font>                <a name="line.2248"></a>
<font color="green">2249</font>            }<a name="line.2249"></a>
<font color="green">2250</font>        }<a name="line.2250"></a>
<font color="green">2251</font>    }<a name="line.2251"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/PropertyUtils/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/PropertyUtils/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:14:01" itemprop="dateModified" datetime="2010-03-24T17:14:01+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>    <a name="line.17"></a>
<font color="green">018</font>    <a name="line.18"></a>
<font color="green">019</font>    package org.apache.commons.beanutils;<a name="line.19"></a>
<font color="green">020</font>    <a name="line.20"></a>
<font color="green">021</font>    import java.beans.PropertyDescriptor;<a name="line.21"></a>
<font color="green">022</font>    import java.lang.reflect.InvocationTargetException;<a name="line.22"></a>
<font color="green">023</font>    import java.lang.reflect.Method;<a name="line.23"></a>
<font color="green">024</font>    import java.util.Map;<a name="line.24"></a>
<font color="green">025</font>    <a name="line.25"></a>
<font color="green">026</font>    import org.apache.commons.collections.FastHashMap;<a name="line.26"></a>
<font color="green">027</font>    <a name="line.27"></a>
<font color="green">028</font>    <a name="line.28"></a>
<font color="green">029</font>    /**<a name="line.29"></a>
<font color="green">030</font>     * &lt;p&gt;Utility methods for using Java Reflection APIs to facilitate generic<a name="line.30"></a>
<font color="green">031</font>     * property getter and setter operations on Java objects.&lt;/p&gt;<a name="line.31"></a>
<font color="green">032</font>     *<a name="line.32"></a>
<font color="green">033</font>     * &lt;p&gt;The implementations for these methods are provided by &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.<a name="line.33"></a>
<font color="green">034</font>     * For more details see {@link PropertyUtilsBean}.&lt;/p&gt;<a name="line.34"></a>
<font color="green">035</font>     *<a name="line.35"></a>
<font color="green">036</font>     * @author Craig R. McClanahan<a name="line.36"></a>
<font color="green">037</font>     * @author Ralph Schaer<a name="line.37"></a>
<font color="green">038</font>     * @author Chris Audley<a name="line.38"></a>
<font color="green">039</font>     * @author Rey Francois<a name="line.39"></a>
<font color="green">040</font>     * @author Gregor Rayman<a name="line.40"></a>
<font color="green">041</font>     * @author Jan Sorensen<a name="line.41"></a>
<font color="green">042</font>     * @author Scott Sanders<a name="line.42"></a>
<font color="green">043</font>     * @version $Revision: 644137 $ $Date: 2008-04-03 03:30:23 +0100 (Thu, 03 Apr 2008) $<a name="line.43"></a>
<font color="green">044</font>     * @see PropertyUtilsBean<a name="line.44"></a>
<font color="green">045</font>     * @see org.apache.commons.beanutils.expression.Resolver<a name="line.45"></a>
<font color="green">046</font>     */<a name="line.46"></a>
<font color="green">047</font>    <a name="line.47"></a>
<font color="green">048</font>    public class PropertyUtils {<a name="line.48"></a>
<font color="green">049</font>    <a name="line.49"></a>
<font color="green">050</font>    <a name="line.50"></a>
<font color="green">051</font>        // ----------------------------------------------------- Manifest Constants<a name="line.51"></a>
<font color="green">052</font>    <a name="line.52"></a>
<font color="green">053</font>    <a name="line.53"></a>
<font color="green">054</font>        /**<a name="line.54"></a>
<font color="green">055</font>         * The delimiter that preceeds the zero-relative subscript for an<a name="line.55"></a>
<font color="green">056</font>         * indexed reference.<a name="line.56"></a>
<font color="green">057</font>         *<a name="line.57"></a>
<font color="green">058</font>         * @deprecated The notation used for property name expressions is now<a name="line.58"></a>
<font color="green">059</font>         * dependant on the {@link org.apache.commons.beanutils.expression.Resolver}<a name="line.59"></a>
<font color="green">060</font>         * implementation being used.<a name="line.60"></a>
<font color="green">061</font>         */<a name="line.61"></a>
<font color="green">062</font>        public static final char INDEXED_DELIM = '[';<a name="line.62"></a>
<font color="green">063</font>    <a name="line.63"></a>
<font color="green">064</font>    <a name="line.64"></a>
<font color="green">065</font>        /**<a name="line.65"></a>
<font color="green">066</font>         * The delimiter that follows the zero-relative subscript for an<a name="line.66"></a>
<font color="green">067</font>         * indexed reference.<a name="line.67"></a>
<font color="green">068</font>         *<a name="line.68"></a>
<font color="green">069</font>         * @deprecated The notation used for property name expressions is now<a name="line.69"></a>
<font color="green">070</font>         * dependant on the {@link org.apache.commons.beanutils.expression.Resolver}<a name="line.70"></a>
<font color="green">071</font>         * implementation being used.<a name="line.71"></a>
<font color="green">072</font>         */<a name="line.72"></a>
<font color="green">073</font>        public static final char INDEXED_DELIM2 = ']';<a name="line.73"></a>
<font color="green">074</font>    <a name="line.74"></a>
<font color="green">075</font>    <a name="line.75"></a>
<font color="green">076</font>        /**<a name="line.76"></a>
<font color="green">077</font>         * The delimiter that preceeds the key of a mapped property.<a name="line.77"></a>
<font color="green">078</font>         *<a name="line.78"></a>
<font color="green">079</font>         * @deprecated The notation used for property name expressions is now<a name="line.79"></a>
<font color="green">080</font>         * dependant on the {@link org.apache.commons.beanutils.expression.Resolver}<a name="line.80"></a>
<font color="green">081</font>         * implementation being used.<a name="line.81"></a>
<font color="green">082</font>         */<a name="line.82"></a>
<font color="green">083</font>        public static final char MAPPED_DELIM = '(';<a name="line.83"></a>
<font color="green">084</font>    <a name="line.84"></a>
<font color="green">085</font>    <a name="line.85"></a>
<font color="green">086</font>        /**<a name="line.86"></a>
<font color="green">087</font>         * The delimiter that follows the key of a mapped property.<a name="line.87"></a>
<font color="green">088</font>         *<a name="line.88"></a>
<font color="green">089</font>         * @deprecated The notation used for property name expressions is now<a name="line.89"></a>
<font color="green">090</font>         * dependant on the {@link org.apache.commons.beanutils.expression.Resolver}<a name="line.90"></a>
<font color="green">091</font>         * implementation being used.<a name="line.91"></a>
<font color="green">092</font>         */<a name="line.92"></a>
<font color="green">093</font>        public static final char MAPPED_DELIM2 = ')';<a name="line.93"></a>
<font color="green">094</font>    <a name="line.94"></a>
<font color="green">095</font>    <a name="line.95"></a>
<font color="green">096</font>        /**<a name="line.96"></a>
<font color="green">097</font>         * The delimiter that separates the components of a nested reference.<a name="line.97"></a>
<font color="green">098</font>         *<a name="line.98"></a>
<font color="green">099</font>         * @deprecated The notation used for property name expressions is now<a name="line.99"></a>
<font color="green">100</font>         * dependant on the {@link org.apache.commons.beanutils.expression.Resolver}<a name="line.100"></a>
<font color="green">101</font>         * implementation being used.<a name="line.101"></a>
<font color="green">102</font>         */<a name="line.102"></a>
<font color="green">103</font>        public static final char NESTED_DELIM = '.';<a name="line.103"></a>
<font color="green">104</font>    <a name="line.104"></a>
<font color="green">105</font>    <a name="line.105"></a>
<font color="green">106</font>        // ------------------------------------------------------- Static Variables<a name="line.106"></a>
<font color="green">107</font>    <a name="line.107"></a>
<font color="green">108</font>    <a name="line.108"></a>
<font color="green">109</font>        /**<a name="line.109"></a>
<font color="green">110</font>         * The debugging detail level for this component.<a name="line.110"></a>
<font color="green">111</font>         * <a name="line.111"></a>
<font color="green">112</font>         * Note that this static variable will have unexpected side-effects if<a name="line.112"></a>
<font color="green">113</font>         * this class is deployed in a shared classloader within a container.<a name="line.113"></a>
<font color="green">114</font>         * However as it is actually completely ignored by this class due to its<a name="line.114"></a>
<font color="green">115</font>         * deprecated status, it doesn't do any actual harm.<a name="line.115"></a>
<font color="green">116</font>         *<a name="line.116"></a>
<font color="green">117</font>         * @deprecated The &lt;code&gt;debug&lt;/code&gt; static property is no longer used<a name="line.117"></a>
<font color="green">118</font>         */<a name="line.118"></a>
<font color="green">119</font>        private static int debug = 0;<a name="line.119"></a>
<font color="green">120</font>    <a name="line.120"></a>
<font color="green">121</font>        /**<a name="line.121"></a>
<font color="green">122</font>         * The &lt;code&gt;debug&lt;/code&gt; static property is no longer used<a name="line.122"></a>
<font color="green">123</font>         * @return debug property<a name="line.123"></a>
<font color="green">124</font>         * @deprecated The &lt;code&gt;debug&lt;/code&gt; static property is no longer used<a name="line.124"></a>
<font color="green">125</font>         */<a name="line.125"></a>
<font color="green">126</font>        public static int getDebug() {<a name="line.126"></a>
<font color="green">127</font>            return (debug);<a name="line.127"></a>
<font color="green">128</font>        }<a name="line.128"></a>
<font color="green">129</font>    <a name="line.129"></a>
<font color="green">130</font>        /**<a name="line.130"></a>
<font color="green">131</font>         * The &lt;code&gt;debug&lt;/code&gt; static property is no longer used<a name="line.131"></a>
<font color="green">132</font>         * @param newDebug debug property<a name="line.132"></a>
<font color="green">133</font>         * @deprecated The &lt;code&gt;debug&lt;/code&gt; static property is no longer used<a name="line.133"></a>
<font color="green">134</font>         */<a name="line.134"></a>
<font color="green">135</font>        public static void setDebug(int newDebug) {<a name="line.135"></a>
<font color="green">136</font>            debug = newDebug;<a name="line.136"></a>
<font color="green">137</font>        }<a name="line.137"></a>
<font color="green">138</font>    <a name="line.138"></a>
<font color="green">139</font>        // --------------------------------------------------------- Public Methods<a name="line.139"></a>
<font color="green">140</font>    <a name="line.140"></a>
<font color="green">141</font>    <a name="line.141"></a>
<font color="green">142</font>        /**<a name="line.142"></a>
<font color="green">143</font>         * Clear any cached property descriptors information for all classes<a name="line.143"></a>
<font color="green">144</font>         * loaded by any class loaders.  This is useful in cases where class<a name="line.144"></a>
<font color="green">145</font>         * loaders are thrown away to implement class reloading.<a name="line.145"></a>
<font color="green">146</font>         *<a name="line.146"></a>
<font color="green">147</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.147"></a>
<font color="green">148</font>         *<a name="line.148"></a>
<font color="green">149</font>         * @see PropertyUtilsBean#clearDescriptors  <a name="line.149"></a>
<font color="green">150</font>         */<a name="line.150"></a>
<font color="green">151</font>        public static void clearDescriptors() {<a name="line.151"></a>
<font color="green">152</font>    <a name="line.152"></a>
<font color="green">153</font>            PropertyUtilsBean.getInstance().clearDescriptors();<a name="line.153"></a>
<font color="green">154</font>    <a name="line.154"></a>
<font color="green">155</font>        }<a name="line.155"></a>
<font color="green">156</font>    <a name="line.156"></a>
<font color="green">157</font>    <a name="line.157"></a>
<font color="green">158</font>        /**<a name="line.158"></a>
<font color="green">159</font>         * &lt;p&gt;Copy property values from the "origin" bean to the "destination" bean<a name="line.159"></a>
<font color="green">160</font>         * for all cases where the property names are the same (even though the<a name="line.160"></a>
<font color="green">161</font>         * actual getter and setter methods might have been customized via<a name="line.161"></a>
<font color="green">162</font>         * &lt;code&gt;BeanInfo&lt;/code&gt; classes).&lt;/p&gt;<a name="line.162"></a>
<font color="green">163</font>         *<a name="line.163"></a>
<font color="green">164</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.164"></a>
<font color="green">165</font>         *<a name="line.165"></a>
<font color="green">166</font>         * @param dest Destination bean whose properties are modified<a name="line.166"></a>
<font color="green">167</font>         * @param orig Origin bean whose properties are retrieved<a name="line.167"></a>
<font color="green">168</font>         *<a name="line.168"></a>
<font color="green">169</font>         * @exception IllegalAccessException if the caller does not have<a name="line.169"></a>
<font color="green">170</font>         *  access to the property accessor method<a name="line.170"></a>
<font color="green">171</font>         * @exception IllegalArgumentException if the &lt;code&gt;dest&lt;/code&gt; or<a name="line.171"></a>
<font color="green">172</font>         *  &lt;code&gt;orig&lt;/code&gt; argument is null<a name="line.172"></a>
<font color="green">173</font>         * @exception InvocationTargetException if the property accessor method<a name="line.173"></a>
<font color="green">174</font>         *  throws an exception<a name="line.174"></a>
<font color="green">175</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.175"></a>
<font color="green">176</font>         *  propety cannot be found<a name="line.176"></a>
<font color="green">177</font>         * @see PropertyUtilsBean#copyProperties  <a name="line.177"></a>
<font color="green">178</font>         */<a name="line.178"></a>
<font color="green">179</font>        public static void copyProperties(Object dest, Object orig)<a name="line.179"></a>
<font color="green">180</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.180"></a>
<font color="green">181</font>                NoSuchMethodException {<a name="line.181"></a>
<font color="green">182</font>    <a name="line.182"></a>
<font color="green">183</font>            PropertyUtilsBean.getInstance().copyProperties(dest, orig);<a name="line.183"></a>
<font color="green">184</font>        }<a name="line.184"></a>
<font color="green">185</font>    <a name="line.185"></a>
<font color="green">186</font>    <a name="line.186"></a>
<font color="green">187</font>        /**<a name="line.187"></a>
<font color="green">188</font>         * &lt;p&gt;Return the entire set of properties for which the specified bean<a name="line.188"></a>
<font color="green">189</font>         * provides a read method.&lt;/p&gt;<a name="line.189"></a>
<font color="green">190</font>         *<a name="line.190"></a>
<font color="green">191</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.191"></a>
<font color="green">192</font>         *<a name="line.192"></a>
<font color="green">193</font>         * @param bean Bean whose properties are to be extracted<a name="line.193"></a>
<font color="green">194</font>         * @return The set of properties for the bean<a name="line.194"></a>
<font color="green">195</font>         *<a name="line.195"></a>
<font color="green">196</font>         * @exception IllegalAccessException if the caller does not have<a name="line.196"></a>
<font color="green">197</font>         *  access to the property accessor method<a name="line.197"></a>
<font color="green">198</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; is null<a name="line.198"></a>
<font color="green">199</font>         * @exception InvocationTargetException if the property accessor method<a name="line.199"></a>
<font color="green">200</font>         *  throws an exception<a name="line.200"></a>
<font color="green">201</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.201"></a>
<font color="green">202</font>         *  propety cannot be found<a name="line.202"></a>
<font color="green">203</font>         * @see PropertyUtilsBean#describe  <a name="line.203"></a>
<font color="green">204</font>         */<a name="line.204"></a>
<font color="green">205</font>        public static Map describe(Object bean)<a name="line.205"></a>
<font color="green">206</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.206"></a>
<font color="green">207</font>                NoSuchMethodException {<a name="line.207"></a>
<font color="green">208</font>    <a name="line.208"></a>
<font color="green">209</font>            return (PropertyUtilsBean.getInstance().describe(bean));<a name="line.209"></a>
<font color="green">210</font>    <a name="line.210"></a>
<font color="green">211</font>        }<a name="line.211"></a>
<font color="green">212</font>    <a name="line.212"></a>
<font color="green">213</font>    <a name="line.213"></a>
<font color="green">214</font>        /**<a name="line.214"></a>
<font color="green">215</font>         * &lt;p&gt;Return the value of the specified indexed property of the specified<a name="line.215"></a>
<font color="green">216</font>         * bean, with no type conversions.&lt;/p&gt;<a name="line.216"></a>
<font color="green">217</font>         *<a name="line.217"></a>
<font color="green">218</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.218"></a>
<font color="green">219</font>         *<a name="line.219"></a>
<font color="green">220</font>         * @param bean Bean whose property is to be extracted<a name="line.220"></a>
<font color="green">221</font>         * @param name &lt;code&gt;propertyname[index]&lt;/code&gt; of the property value<a name="line.221"></a>
<font color="green">222</font>         *  to be extracted<a name="line.222"></a>
<font color="green">223</font>         * @return the indexed property value<a name="line.223"></a>
<font color="green">224</font>         *<a name="line.224"></a>
<font color="green">225</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.225"></a>
<font color="green">226</font>         *  is outside the valid range for the underlying property<a name="line.226"></a>
<font color="green">227</font>         * @exception IllegalAccessException if the caller does not have<a name="line.227"></a>
<font color="green">228</font>         *  access to the property accessor method<a name="line.228"></a>
<font color="green">229</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.229"></a>
<font color="green">230</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.230"></a>
<font color="green">231</font>         * @exception InvocationTargetException if the property accessor method<a name="line.231"></a>
<font color="green">232</font>         *  throws an exception<a name="line.232"></a>
<font color="green">233</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.233"></a>
<font color="green">234</font>         *  propety cannot be found<a name="line.234"></a>
<font color="green">235</font>         * @see PropertyUtilsBean#getIndexedProperty(Object,String)  <a name="line.235"></a>
<font color="green">236</font>         */<a name="line.236"></a>
<font color="green">237</font>        public static Object getIndexedProperty(Object bean, String name)<a name="line.237"></a>
<font color="green">238</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.238"></a>
<font color="green">239</font>                NoSuchMethodException {<a name="line.239"></a>
<font color="green">240</font>    <a name="line.240"></a>
<font color="green">241</font>            return (PropertyUtilsBean.getInstance().getIndexedProperty(bean, name));<a name="line.241"></a>
<font color="green">242</font>    <a name="line.242"></a>
<font color="green">243</font>        }<a name="line.243"></a>
<font color="green">244</font>    <a name="line.244"></a>
<font color="green">245</font>    <a name="line.245"></a>
<font color="green">246</font>        /**<a name="line.246"></a>
<font color="green">247</font>         * &lt;p&gt;Return the value of the specified indexed property of the specified<a name="line.247"></a>
<font color="green">248</font>         * bean, with no type conversions.&lt;/p&gt;<a name="line.248"></a>
<font color="green">249</font>         *<a name="line.249"></a>
<font color="green">250</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.250"></a>
<font color="green">251</font>         *<a name="line.251"></a>
<font color="green">252</font>         * @param bean Bean whose property is to be extracted<a name="line.252"></a>
<font color="green">253</font>         * @param name Simple property name of the property value to be extracted<a name="line.253"></a>
<font color="green">254</font>         * @param index Index of the property value to be extracted<a name="line.254"></a>
<font color="green">255</font>         * @return the indexed property value<a name="line.255"></a>
<font color="green">256</font>         *<a name="line.256"></a>
<font color="green">257</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.257"></a>
<font color="green">258</font>         *  is outside the valid range for the underlying property<a name="line.258"></a>
<font color="green">259</font>         * @exception IllegalAccessException if the caller does not have<a name="line.259"></a>
<font color="green">260</font>         *  access to the property accessor method<a name="line.260"></a>
<font color="green">261</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.261"></a>
<font color="green">262</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.262"></a>
<font color="green">263</font>         * @exception InvocationTargetException if the property accessor method<a name="line.263"></a>
<font color="green">264</font>         *  throws an exception<a name="line.264"></a>
<font color="green">265</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.265"></a>
<font color="green">266</font>         *  propety cannot be found<a name="line.266"></a>
<font color="green">267</font>         * @see PropertyUtilsBean#getIndexedProperty(Object,String, int)  <a name="line.267"></a>
<font color="green">268</font>         */<a name="line.268"></a>
<font color="green">269</font>        public static Object getIndexedProperty(Object bean,<a name="line.269"></a>
<font color="green">270</font>                                                String name, int index)<a name="line.270"></a>
<font color="green">271</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.271"></a>
<font color="green">272</font>                NoSuchMethodException {<a name="line.272"></a>
<font color="green">273</font>    <a name="line.273"></a>
<font color="green">274</font>            return (PropertyUtilsBean.getInstance().getIndexedProperty(bean, name, index));<a name="line.274"></a>
<font color="green">275</font>        }<a name="line.275"></a>
<font color="green">276</font>    <a name="line.276"></a>
<font color="green">277</font>    <a name="line.277"></a>
<font color="green">278</font>        /**<a name="line.278"></a>
<font color="green">279</font>         * &lt;p&gt;Return the value of the specified mapped property of the<a name="line.279"></a>
<font color="green">280</font>         * specified bean, with no type conversions.&lt;/p&gt;<a name="line.280"></a>
<font color="green">281</font>         *<a name="line.281"></a>
<font color="green">282</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.282"></a>
<font color="green">283</font>         *<a name="line.283"></a>
<font color="green">284</font>         * @param bean Bean whose property is to be extracted<a name="line.284"></a>
<font color="green">285</font>         * @param name &lt;code&gt;propertyname(key)&lt;/code&gt; of the property value<a name="line.285"></a>
<font color="green">286</font>         *  to be extracted<a name="line.286"></a>
<font color="green">287</font>         * @return the mapped property value<a name="line.287"></a>
<font color="green">288</font>         *<a name="line.288"></a>
<font color="green">289</font>         * @exception IllegalAccessException if the caller does not have<a name="line.289"></a>
<font color="green">290</font>         *  access to the property accessor method<a name="line.290"></a>
<font color="green">291</font>         * @exception InvocationTargetException if the property accessor method<a name="line.291"></a>
<font color="green">292</font>         *  throws an exception<a name="line.292"></a>
<font color="green">293</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.293"></a>
<font color="green">294</font>         *  propety cannot be found<a name="line.294"></a>
<font color="green">295</font>         * @see PropertyUtilsBean#getMappedProperty(Object,String)  <a name="line.295"></a>
<font color="green">296</font>         */<a name="line.296"></a>
<font color="green">297</font>        public static Object getMappedProperty(Object bean, String name)<a name="line.297"></a>
<font color="green">298</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.298"></a>
<font color="green">299</font>                NoSuchMethodException {<a name="line.299"></a>
<font color="green">300</font>    <a name="line.300"></a>
<font color="green">301</font>            return (PropertyUtilsBean.getInstance().getMappedProperty(bean, name));<a name="line.301"></a>
<font color="green">302</font>    <a name="line.302"></a>
<font color="green">303</font>        }<a name="line.303"></a>
<font color="green">304</font>    <a name="line.304"></a>
<font color="green">305</font>    <a name="line.305"></a>
<font color="green">306</font>        /**<a name="line.306"></a>
<font color="green">307</font>         * &lt;p&gt;Return the value of the specified mapped property of the specified<a name="line.307"></a>
<font color="green">308</font>         * bean, with no type conversions.&lt;/p&gt;<a name="line.308"></a>
<font color="green">309</font>         *<a name="line.309"></a>
<font color="green">310</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.310"></a>
<font color="green">311</font>         *<a name="line.311"></a>
<font color="green">312</font>         * @param bean Bean whose property is to be extracted<a name="line.312"></a>
<font color="green">313</font>         * @param name Mapped property name of the property value to be extracted<a name="line.313"></a>
<font color="green">314</font>         * @param key Key of the property value to be extracted<a name="line.314"></a>
<font color="green">315</font>         * @return the mapped property value<a name="line.315"></a>
<font color="green">316</font>         *<a name="line.316"></a>
<font color="green">317</font>         * @exception IllegalAccessException if the caller does not have<a name="line.317"></a>
<font color="green">318</font>         *  access to the property accessor method<a name="line.318"></a>
<font color="green">319</font>         * @exception InvocationTargetException if the property accessor method<a name="line.319"></a>
<font color="green">320</font>         *  throws an exception<a name="line.320"></a>
<font color="green">321</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.321"></a>
<font color="green">322</font>         *  propety cannot be found<a name="line.322"></a>
<font color="green">323</font>         * @see PropertyUtilsBean#getMappedProperty(Object,String, String)  <a name="line.323"></a>
<font color="green">324</font>         */<a name="line.324"></a>
<font color="green">325</font>        public static Object getMappedProperty(Object bean,<a name="line.325"></a>
<font color="green">326</font>                                               String name, String key)<a name="line.326"></a>
<font color="green">327</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.327"></a>
<font color="green">328</font>                NoSuchMethodException {<a name="line.328"></a>
<font color="green">329</font>    <a name="line.329"></a>
<font color="green">330</font>            return PropertyUtilsBean.getInstance().getMappedProperty(bean, name, key);<a name="line.330"></a>
<font color="green">331</font>    <a name="line.331"></a>
<font color="green">332</font>        }<a name="line.332"></a>
<font color="green">333</font>    <a name="line.333"></a>
<font color="green">334</font>    <a name="line.334"></a>
<font color="green">335</font>        /**<a name="line.335"></a>
<font color="green">336</font>         * &lt;p&gt;Return the mapped property descriptors for this bean class.&lt;/p&gt;<a name="line.336"></a>
<font color="green">337</font>         *<a name="line.337"></a>
<font color="green">338</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.338"></a>
<font color="green">339</font>         *<a name="line.339"></a>
<font color="green">340</font>         * @param beanClass Bean class to be introspected<a name="line.340"></a>
<font color="green">341</font>         * @return the mapped property descriptors<a name="line.341"></a>
<font color="green">342</font>         * @see PropertyUtilsBean#getMappedPropertyDescriptors(Class)<a name="line.342"></a>
<font color="green">343</font>         * @deprecated This method should not be exposed<a name="line.343"></a>
<font color="green">344</font>         */<a name="line.344"></a>
<font color="green">345</font>        public static FastHashMap getMappedPropertyDescriptors(Class beanClass) {<a name="line.345"></a>
<font color="green">346</font>    <a name="line.346"></a>
<font color="green">347</font>            return PropertyUtilsBean.getInstance().getMappedPropertyDescriptors(beanClass);<a name="line.347"></a>
<font color="green">348</font>    <a name="line.348"></a>
<font color="green">349</font>        }<a name="line.349"></a>
<font color="green">350</font>    <a name="line.350"></a>
<font color="green">351</font>    <a name="line.351"></a>
<font color="green">352</font>        /**<a name="line.352"></a>
<font color="green">353</font>         * &lt;p&gt;Return the mapped property descriptors for this bean.&lt;/p&gt;<a name="line.353"></a>
<font color="green">354</font>         *<a name="line.354"></a>
<font color="green">355</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.355"></a>
<font color="green">356</font>         *<a name="line.356"></a>
<font color="green">357</font>         * @param bean Bean to be introspected<a name="line.357"></a>
<font color="green">358</font>         * @return the mapped property descriptors<a name="line.358"></a>
<font color="green">359</font>         * @see PropertyUtilsBean#getMappedPropertyDescriptors(Object)<a name="line.359"></a>
<font color="green">360</font>         * @deprecated This method should not be exposed<a name="line.360"></a>
<font color="green">361</font>         */<a name="line.361"></a>
<font color="green">362</font>        public static FastHashMap getMappedPropertyDescriptors(Object bean) {<a name="line.362"></a>
<font color="green">363</font>    <a name="line.363"></a>
<font color="green">364</font>            return PropertyUtilsBean.getInstance().getMappedPropertyDescriptors(bean);<a name="line.364"></a>
<font color="green">365</font>    <a name="line.365"></a>
<font color="green">366</font>        }<a name="line.366"></a>
<font color="green">367</font>    <a name="line.367"></a>
<font color="green">368</font>    <a name="line.368"></a>
<font color="green">369</font>        /**<a name="line.369"></a>
<font color="green">370</font>         * &lt;p&gt;Return the value of the (possibly nested) property of the specified<a name="line.370"></a>
<font color="green">371</font>         * name, for the specified bean, with no type conversions.&lt;/p&gt;<a name="line.371"></a>
<font color="green">372</font>         *<a name="line.372"></a>
<font color="green">373</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.373"></a>
<font color="green">374</font>         *<a name="line.374"></a>
<font color="green">375</font>         * @param bean Bean whose property is to be extracted<a name="line.375"></a>
<font color="green">376</font>         * @param name Possibly nested name of the property to be extracted<a name="line.376"></a>
<font color="green">377</font>         * @return the nested property value<a name="line.377"></a>
<font color="green">378</font>         *<a name="line.378"></a>
<font color="green">379</font>         * @exception IllegalAccessException if the caller does not have<a name="line.379"></a>
<font color="green">380</font>         *  access to the property accessor method<a name="line.380"></a>
<font color="green">381</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.381"></a>
<font color="green">382</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.382"></a>
<font color="green">383</font>         * @exception NestedNullException if a nested reference to a<a name="line.383"></a>
<font color="green">384</font>         *  property returns null<a name="line.384"></a>
<font color="green">385</font>         * @exception InvocationTargetException <a name="line.385"></a>
<font color="green">386</font>         * if the property accessor method throws an exception<a name="line.386"></a>
<font color="green">387</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.387"></a>
<font color="green">388</font>         *  propety cannot be found<a name="line.388"></a>
<font color="green">389</font>         * @see PropertyUtilsBean#getNestedProperty<a name="line.389"></a>
<font color="green">390</font>         */<a name="line.390"></a>
<font color="green">391</font>        public static Object getNestedProperty(Object bean, String name)<a name="line.391"></a>
<font color="green">392</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.392"></a>
<font color="green">393</font>                NoSuchMethodException {<a name="line.393"></a>
<font color="green">394</font>    <a name="line.394"></a>
<font color="green">395</font>            return PropertyUtilsBean.getInstance().getNestedProperty(bean, name);<a name="line.395"></a>
<font color="green">396</font>            <a name="line.396"></a>
<font color="green">397</font>        }<a name="line.397"></a>
<font color="green">398</font>    <a name="line.398"></a>
<font color="green">399</font>    <a name="line.399"></a>
<font color="green">400</font>        /**<a name="line.400"></a>
<font color="green">401</font>         * &lt;p&gt;Return the value of the specified property of the specified bean,<a name="line.401"></a>
<font color="green">402</font>         * no matter which property reference format is used, with no<a name="line.402"></a>
<font color="green">403</font>         * type conversions.&lt;/p&gt;<a name="line.403"></a>
<font color="green">404</font>         *<a name="line.404"></a>
<font color="green">405</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.405"></a>
<font color="green">406</font>         *<a name="line.406"></a>
<font color="green">407</font>         * @param bean Bean whose property is to be extracted<a name="line.407"></a>
<font color="green">408</font>         * @param name Possibly indexed and/or nested name of the property<a name="line.408"></a>
<font color="green">409</font>         *  to be extracted<a name="line.409"></a>
<font color="green">410</font>         * @return the property value<a name="line.410"></a>
<font color="green">411</font>         *<a name="line.411"></a>
<font color="green">412</font>         * @exception IllegalAccessException if the caller does not have<a name="line.412"></a>
<font color="green">413</font>         *  access to the property accessor method<a name="line.413"></a>
<font color="green">414</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.414"></a>
<font color="green">415</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.415"></a>
<font color="green">416</font>         * @exception InvocationTargetException if the property accessor method<a name="line.416"></a>
<font color="green">417</font>         *  throws an exception<a name="line.417"></a>
<font color="green">418</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.418"></a>
<font color="green">419</font>         *  propety cannot be found<a name="line.419"></a>
<font color="green">420</font>         * @see PropertyUtilsBean#getProperty<a name="line.420"></a>
<font color="green">421</font>         */<a name="line.421"></a>
<font color="green">422</font>        public static Object getProperty(Object bean, String name)<a name="line.422"></a>
<font color="green">423</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.423"></a>
<font color="green">424</font>                NoSuchMethodException {<a name="line.424"></a>
<font color="green">425</font>    <a name="line.425"></a>
<font color="green">426</font>            return (PropertyUtilsBean.getInstance().getProperty(bean, name));<a name="line.426"></a>
<font color="green">427</font>    <a name="line.427"></a>
<font color="green">428</font>        }<a name="line.428"></a>
<font color="green">429</font>    <a name="line.429"></a>
<font color="green">430</font>    <a name="line.430"></a>
<font color="green">431</font>        /**<a name="line.431"></a>
<font color="green">432</font>         * &lt;p&gt;Retrieve the property descriptor for the specified property of the<a name="line.432"></a>
<font color="green">433</font>         * specified bean, or return &lt;code&gt;null&lt;/code&gt; if there is no such<a name="line.433"></a>
<font color="green">434</font>         * descriptor.&lt;/p&gt;<a name="line.434"></a>
<font color="green">435</font>         *<a name="line.435"></a>
<font color="green">436</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.436"></a>
<font color="green">437</font>         *<a name="line.437"></a>
<font color="green">438</font>         * @param bean Bean for which a property descriptor is requested<a name="line.438"></a>
<font color="green">439</font>         * @param name Possibly indexed and/or nested name of the property for<a name="line.439"></a>
<font color="green">440</font>         *  which a property descriptor is requested<a name="line.440"></a>
<font color="green">441</font>         * @return the property descriptor<a name="line.441"></a>
<font color="green">442</font>         *<a name="line.442"></a>
<font color="green">443</font>         * @exception IllegalAccessException if the caller does not have<a name="line.443"></a>
<font color="green">444</font>         *  access to the property accessor method<a name="line.444"></a>
<font color="green">445</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.445"></a>
<font color="green">446</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.446"></a>
<font color="green">447</font>         * @exception IllegalArgumentException if a nested reference to a<a name="line.447"></a>
<font color="green">448</font>         *  property returns null<a name="line.448"></a>
<font color="green">449</font>         * @exception InvocationTargetException if the property accessor method<a name="line.449"></a>
<font color="green">450</font>         *  throws an exception<a name="line.450"></a>
<font color="green">451</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.451"></a>
<font color="green">452</font>         *  propety cannot be found<a name="line.452"></a>
<font color="green">453</font>         * @see PropertyUtilsBean#getPropertyDescriptor<a name="line.453"></a>
<font color="green">454</font>         */<a name="line.454"></a>
<font color="green">455</font>        public static PropertyDescriptor getPropertyDescriptor(Object bean,<a name="line.455"></a>
<font color="green">456</font>                                                               String name)<a name="line.456"></a>
<font color="green">457</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.457"></a>
<font color="green">458</font>                NoSuchMethodException {<a name="line.458"></a>
<font color="green">459</font>    <a name="line.459"></a>
<font color="green">460</font>            return PropertyUtilsBean.getInstance().getPropertyDescriptor(bean, name);<a name="line.460"></a>
<font color="green">461</font>    <a name="line.461"></a>
<font color="green">462</font>        }<a name="line.462"></a>
<font color="green">463</font>    <a name="line.463"></a>
<font color="green">464</font>    <a name="line.464"></a>
<font color="green">465</font>        /**<a name="line.465"></a>
<font color="green">466</font>         * &lt;p&gt;Retrieve the property descriptors for the specified class,<a name="line.466"></a>
<font color="green">467</font>         * introspecting and caching them the first time a particular bean class<a name="line.467"></a>
<font color="green">468</font>         * is encountered.&lt;/p&gt;<a name="line.468"></a>
<font color="green">469</font>         *<a name="line.469"></a>
<font color="green">470</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.470"></a>
<font color="green">471</font>         *<a name="line.471"></a>
<font color="green">472</font>         * @param beanClass Bean class for which property descriptors are requested<a name="line.472"></a>
<font color="green">473</font>         * @return the property descriptors<a name="line.473"></a>
<font color="green">474</font>         * @exception IllegalArgumentException if &lt;code&gt;beanClass&lt;/code&gt; is null<a name="line.474"></a>
<font color="green">475</font>         * @see PropertyUtilsBean#getPropertyDescriptors(Class)<a name="line.475"></a>
<font color="green">476</font>         */<a name="line.476"></a>
<font color="green">477</font>        public static PropertyDescriptor[]<a name="line.477"></a>
<font color="green">478</font>                getPropertyDescriptors(Class beanClass) {<a name="line.478"></a>
<font color="green">479</font>    <a name="line.479"></a>
<font color="green">480</font>            return PropertyUtilsBean.getInstance().getPropertyDescriptors(beanClass);<a name="line.480"></a>
<font color="green">481</font>    <a name="line.481"></a>
<font color="green">482</font>        }<a name="line.482"></a>
<font color="green">483</font>    <a name="line.483"></a>
<font color="green">484</font>    <a name="line.484"></a>
<font color="green">485</font>        /**<a name="line.485"></a>
<font color="green">486</font>         * &lt;p&gt;Retrieve the property descriptors for the specified bean,<a name="line.486"></a>
<font color="green">487</font>         * introspecting and caching them the first time a particular bean class<a name="line.487"></a>
<font color="green">488</font>         * is encountered.&lt;/p&gt;<a name="line.488"></a>
<font color="green">489</font>         *<a name="line.489"></a>
<font color="green">490</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.490"></a>
<font color="green">491</font>         *<a name="line.491"></a>
<font color="green">492</font>         * @param bean Bean for which property descriptors are requested<a name="line.492"></a>
<font color="green">493</font>         * @return the property descriptors<a name="line.493"></a>
<font color="green">494</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; is null<a name="line.494"></a>
<font color="green">495</font>         * @see PropertyUtilsBean#getPropertyDescriptors(Object)<a name="line.495"></a>
<font color="green">496</font>         */<a name="line.496"></a>
<font color="green">497</font>        public static PropertyDescriptor[] getPropertyDescriptors(Object bean) {<a name="line.497"></a>
<font color="green">498</font>    <a name="line.498"></a>
<font color="green">499</font>            return PropertyUtilsBean.getInstance().getPropertyDescriptors(bean);<a name="line.499"></a>
<font color="green">500</font>    <a name="line.500"></a>
<font color="green">501</font>        }<a name="line.501"></a>
<font color="green">502</font>    <a name="line.502"></a>
<font color="green">503</font>    <a name="line.503"></a>
<font color="green">504</font>        /**<a name="line.504"></a>
<font color="green">505</font>         * &lt;p&gt;Return the Java Class repesenting the property editor class that has<a name="line.505"></a>
<font color="green">506</font>         * been registered for this property (if any).&lt;/p&gt;<a name="line.506"></a>
<font color="green">507</font>         *<a name="line.507"></a>
<font color="green">508</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.508"></a>
<font color="green">509</font>         *<a name="line.509"></a>
<font color="green">510</font>         * @param bean Bean for which a property descriptor is requested<a name="line.510"></a>
<font color="green">511</font>         * @param name Possibly indexed and/or nested name of the property for<a name="line.511"></a>
<font color="green">512</font>         *  which a property descriptor is requested<a name="line.512"></a>
<font color="green">513</font>         * @return the property editor class<a name="line.513"></a>
<font color="green">514</font>         *<a name="line.514"></a>
<font color="green">515</font>         * @exception IllegalAccessException if the caller does not have<a name="line.515"></a>
<font color="green">516</font>         *  access to the property accessor method<a name="line.516"></a>
<font color="green">517</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.517"></a>
<font color="green">518</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.518"></a>
<font color="green">519</font>         * @exception IllegalArgumentException if a nested reference to a<a name="line.519"></a>
<font color="green">520</font>         *  property returns null<a name="line.520"></a>
<font color="green">521</font>         * @exception InvocationTargetException if the property accessor method<a name="line.521"></a>
<font color="green">522</font>         *  throws an exception<a name="line.522"></a>
<font color="green">523</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.523"></a>
<font color="green">524</font>         *  propety cannot be found<a name="line.524"></a>
<font color="green">525</font>         * @see PropertyUtilsBean#getPropertyEditorClass(Object,String)<a name="line.525"></a>
<font color="green">526</font>         */<a name="line.526"></a>
<font color="green">527</font>        public static Class getPropertyEditorClass(Object bean, String name)<a name="line.527"></a>
<font color="green">528</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.528"></a>
<font color="green">529</font>                NoSuchMethodException {<a name="line.529"></a>
<font color="green">530</font>    <a name="line.530"></a>
<font color="green">531</font>            return PropertyUtilsBean.getInstance().getPropertyEditorClass(bean, name);<a name="line.531"></a>
<font color="green">532</font>    <a name="line.532"></a>
<font color="green">533</font>        }<a name="line.533"></a>
<font color="green">534</font>    <a name="line.534"></a>
<font color="green">535</font>    <a name="line.535"></a>
<font color="green">536</font>        /**<a name="line.536"></a>
<font color="green">537</font>         * &lt;p&gt;Return the Java Class representing the property type of the specified<a name="line.537"></a>
<font color="green">538</font>         * property, or &lt;code&gt;null&lt;/code&gt; if there is no such property for the<a name="line.538"></a>
<font color="green">539</font>         * specified bean.&lt;/p&gt;<a name="line.539"></a>
<font color="green">540</font>         *<a name="line.540"></a>
<font color="green">541</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.541"></a>
<font color="green">542</font>         *<a name="line.542"></a>
<font color="green">543</font>         * @param bean Bean for which a property descriptor is requested<a name="line.543"></a>
<font color="green">544</font>         * @param name Possibly indexed and/or nested name of the property for<a name="line.544"></a>
<font color="green">545</font>         *  which a property descriptor is requested<a name="line.545"></a>
<font color="green">546</font>         * @return The property type<a name="line.546"></a>
<font color="green">547</font>         *<a name="line.547"></a>
<font color="green">548</font>         * @exception IllegalAccessException if the caller does not have<a name="line.548"></a>
<font color="green">549</font>         *  access to the property accessor method<a name="line.549"></a>
<font color="green">550</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.550"></a>
<font color="green">551</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.551"></a>
<font color="green">552</font>         * @exception IllegalArgumentException if a nested reference to a<a name="line.552"></a>
<font color="green">553</font>         *  property returns null<a name="line.553"></a>
<font color="green">554</font>         * @exception InvocationTargetException if the property accessor method<a name="line.554"></a>
<font color="green">555</font>         *  throws an exception<a name="line.555"></a>
<font color="green">556</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.556"></a>
<font color="green">557</font>         *  propety cannot be found<a name="line.557"></a>
<font color="green">558</font>         * @see PropertyUtilsBean#getPropertyType(Object, String)<a name="line.558"></a>
<font color="green">559</font>         */<a name="line.559"></a>
<font color="green">560</font>        public static Class getPropertyType(Object bean, String name)<a name="line.560"></a>
<font color="green">561</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.561"></a>
<font color="green">562</font>                NoSuchMethodException {<a name="line.562"></a>
<font color="green">563</font>    <a name="line.563"></a>
<font color="green">564</font>            return PropertyUtilsBean.getInstance().getPropertyType(bean, name);<a name="line.564"></a>
<font color="green">565</font>        }<a name="line.565"></a>
<font color="green">566</font>    <a name="line.566"></a>
<font color="green">567</font>    <a name="line.567"></a>
<font color="green">568</font>        /**<a name="line.568"></a>
<font color="green">569</font>         * &lt;p&gt;Return an accessible property getter method for this property,<a name="line.569"></a>
<font color="green">570</font>         * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.570"></a>
<font color="green">571</font>         *<a name="line.571"></a>
<font color="green">572</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.572"></a>
<font color="green">573</font>         *<a name="line.573"></a>
<font color="green">574</font>         * @param descriptor Property descriptor to return a getter for<a name="line.574"></a>
<font color="green">575</font>         * @return The read method<a name="line.575"></a>
<font color="green">576</font>         * @see PropertyUtilsBean#getReadMethod(PropertyDescriptor)<a name="line.576"></a>
<font color="green">577</font>         */<a name="line.577"></a>
<font color="green">578</font>        public static Method getReadMethod(PropertyDescriptor descriptor) {<a name="line.578"></a>
<font color="green">579</font>    <a name="line.579"></a>
<font color="green">580</font>            return (PropertyUtilsBean.getInstance().getReadMethod(descriptor));<a name="line.580"></a>
<font color="green">581</font>    <a name="line.581"></a>
<font color="green">582</font>        }<a name="line.582"></a>
<font color="green">583</font>    <a name="line.583"></a>
<font color="green">584</font>    <a name="line.584"></a>
<font color="green">585</font>        /**<a name="line.585"></a>
<font color="green">586</font>         * &lt;p&gt;Return the value of the specified simple property of the specified<a name="line.586"></a>
<font color="green">587</font>         * bean, with no type conversions.&lt;/p&gt;<a name="line.587"></a>
<font color="green">588</font>         *<a name="line.588"></a>
<font color="green">589</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.589"></a>
<font color="green">590</font>         *<a name="line.590"></a>
<font color="green">591</font>         * @param bean Bean whose property is to be extracted<a name="line.591"></a>
<font color="green">592</font>         * @param name Name of the property to be extracted<a name="line.592"></a>
<font color="green">593</font>         * @return The property value<a name="line.593"></a>
<font color="green">594</font>         *<a name="line.594"></a>
<font color="green">595</font>         * @exception IllegalAccessException if the caller does not have<a name="line.595"></a>
<font color="green">596</font>         *  access to the property accessor method<a name="line.596"></a>
<font color="green">597</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.597"></a>
<font color="green">598</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.598"></a>
<font color="green">599</font>         * @exception IllegalArgumentException if the property name<a name="line.599"></a>
<font color="green">600</font>         *  is nested or indexed<a name="line.600"></a>
<font color="green">601</font>         * @exception InvocationTargetException if the property accessor method<a name="line.601"></a>
<font color="green">602</font>         *  throws an exception<a name="line.602"></a>
<font color="green">603</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.603"></a>
<font color="green">604</font>         *  propety cannot be found<a name="line.604"></a>
<font color="green">605</font>         * @see PropertyUtilsBean#getSimpleProperty<a name="line.605"></a>
<font color="green">606</font>         */<a name="line.606"></a>
<font color="green">607</font>        public static Object getSimpleProperty(Object bean, String name)<a name="line.607"></a>
<font color="green">608</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.608"></a>
<font color="green">609</font>                NoSuchMethodException {<a name="line.609"></a>
<font color="green">610</font>    <a name="line.610"></a>
<font color="green">611</font>            return PropertyUtilsBean.getInstance().getSimpleProperty(bean, name);<a name="line.611"></a>
<font color="green">612</font>            <a name="line.612"></a>
<font color="green">613</font>        }<a name="line.613"></a>
<font color="green">614</font>    <a name="line.614"></a>
<font color="green">615</font>    <a name="line.615"></a>
<font color="green">616</font>        /**<a name="line.616"></a>
<font color="green">617</font>         * &lt;p&gt;Return an accessible property setter method for this property,<a name="line.617"></a>
<font color="green">618</font>         * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.618"></a>
<font color="green">619</font>         *<a name="line.619"></a>
<font color="green">620</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.620"></a>
<font color="green">621</font>         *<a name="line.621"></a>
<font color="green">622</font>         * @param descriptor Property descriptor to return a setter for<a name="line.622"></a>
<font color="green">623</font>         * @return The write method<a name="line.623"></a>
<font color="green">624</font>         * @see PropertyUtilsBean#getWriteMethod(PropertyDescriptor)<a name="line.624"></a>
<font color="green">625</font>         */<a name="line.625"></a>
<font color="green">626</font>        public static Method getWriteMethod(PropertyDescriptor descriptor) {<a name="line.626"></a>
<font color="green">627</font>    <a name="line.627"></a>
<font color="green">628</font>            return PropertyUtilsBean.getInstance().getWriteMethod(descriptor);<a name="line.628"></a>
<font color="green">629</font>    <a name="line.629"></a>
<font color="green">630</font>        }<a name="line.630"></a>
<font color="green">631</font>    <a name="line.631"></a>
<font color="green">632</font>    <a name="line.632"></a>
<font color="green">633</font>        /**<a name="line.633"></a>
<font color="green">634</font>         * &lt;p&gt;Return &lt;code&gt;true&lt;/code&gt; if the specified property name identifies<a name="line.634"></a>
<font color="green">635</font>         * a readable property on the specified bean; otherwise, return<a name="line.635"></a>
<font color="green">636</font>         * &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;<a name="line.636"></a>
<font color="green">637</font>         *<a name="line.637"></a>
<font color="green">638</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.638"></a>
<font color="green">639</font>         *<a name="line.639"></a>
<font color="green">640</font>         * @param bean Bean to be examined (may be a {@link DynaBean}<a name="line.640"></a>
<font color="green">641</font>         * @param name Property name to be evaluated<a name="line.641"></a>
<font color="green">642</font>         * @return &lt;code&gt;true&lt;/code&gt; if the property is readable,<a name="line.642"></a>
<font color="green">643</font>         * otherwise &lt;code&gt;false&lt;/code&gt;<a name="line.643"></a>
<font color="green">644</font>         *<a name="line.644"></a>
<font color="green">645</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt;<a name="line.645"></a>
<font color="green">646</font>         *  or &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;<a name="line.646"></a>
<font color="green">647</font>         * @see PropertyUtilsBean#isReadable<a name="line.647"></a>
<font color="green">648</font>         * @since BeanUtils 1.6<a name="line.648"></a>
<font color="green">649</font>         */<a name="line.649"></a>
<font color="green">650</font>        public static boolean isReadable(Object bean, String name) {<a name="line.650"></a>
<font color="green">651</font>    <a name="line.651"></a>
<font color="green">652</font>            return PropertyUtilsBean.getInstance().isReadable(bean, name);<a name="line.652"></a>
<font color="green">653</font>        }<a name="line.653"></a>
<font color="green">654</font>    <a name="line.654"></a>
<font color="green">655</font>    <a name="line.655"></a>
<font color="green">656</font>        /**<a name="line.656"></a>
<font color="green">657</font>         * &lt;p&gt;Return &lt;code&gt;true&lt;/code&gt; if the specified property name identifies<a name="line.657"></a>
<font color="green">658</font>         * a writeable property on the specified bean; otherwise, return<a name="line.658"></a>
<font color="green">659</font>         * &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;<a name="line.659"></a>
<font color="green">660</font>         *<a name="line.660"></a>
<font color="green">661</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.661"></a>
<font color="green">662</font>         *<a name="line.662"></a>
<font color="green">663</font>         * @param bean Bean to be examined (may be a {@link DynaBean}<a name="line.663"></a>
<font color="green">664</font>         * @param name Property name to be evaluated<a name="line.664"></a>
<font color="green">665</font>         * @return &lt;code&gt;true&lt;/code&gt; if the property is writeable,<a name="line.665"></a>
<font color="green">666</font>         * otherwise &lt;code&gt;false&lt;/code&gt;<a name="line.666"></a>
<font color="green">667</font>         *<a name="line.667"></a>
<font color="green">668</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt;<a name="line.668"></a>
<font color="green">669</font>         *  or &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;<a name="line.669"></a>
<font color="green">670</font>         * @see PropertyUtilsBean#isWriteable<a name="line.670"></a>
<font color="green">671</font>         * @since BeanUtils 1.6<a name="line.671"></a>
<font color="green">672</font>         */<a name="line.672"></a>
<font color="green">673</font>        public static boolean isWriteable(Object bean, String name) {<a name="line.673"></a>
<font color="green">674</font>    <a name="line.674"></a>
<font color="green">675</font>            return PropertyUtilsBean.getInstance().isWriteable(bean, name);<a name="line.675"></a>
<font color="green">676</font>        }<a name="line.676"></a>
<font color="green">677</font>    <a name="line.677"></a>
<font color="green">678</font>    <a name="line.678"></a>
<font color="green">679</font>        /**<a name="line.679"></a>
<font color="green">680</font>         * &lt;p&gt;Sets the value of the specified indexed property of the specified<a name="line.680"></a>
<font color="green">681</font>         * bean, with no type conversions.&lt;/p&gt;<a name="line.681"></a>
<font color="green">682</font>         *<a name="line.682"></a>
<font color="green">683</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.683"></a>
<font color="green">684</font>         *<a name="line.684"></a>
<font color="green">685</font>         * @param bean Bean whose property is to be modified<a name="line.685"></a>
<font color="green">686</font>         * @param name &lt;code&gt;propertyname[index]&lt;/code&gt; of the property value<a name="line.686"></a>
<font color="green">687</font>         *  to be modified<a name="line.687"></a>
<font color="green">688</font>         * @param value Value to which the specified property element<a name="line.688"></a>
<font color="green">689</font>         *  should be set<a name="line.689"></a>
<font color="green">690</font>         *<a name="line.690"></a>
<font color="green">691</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.691"></a>
<font color="green">692</font>         *  is outside the valid range for the underlying property<a name="line.692"></a>
<font color="green">693</font>         * @exception IllegalAccessException if the caller does not have<a name="line.693"></a>
<font color="green">694</font>         *  access to the property accessor method<a name="line.694"></a>
<font color="green">695</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.695"></a>
<font color="green">696</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.696"></a>
<font color="green">697</font>         * @exception InvocationTargetException if the property accessor method<a name="line.697"></a>
<font color="green">698</font>         *  throws an exception<a name="line.698"></a>
<font color="green">699</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.699"></a>
<font color="green">700</font>         *  propety cannot be found<a name="line.700"></a>
<font color="green">701</font>         * @see PropertyUtilsBean#setIndexedProperty(Object, String, Object)<a name="line.701"></a>
<font color="green">702</font>         */<a name="line.702"></a>
<font color="green">703</font>        public static void setIndexedProperty(Object bean, String name,<a name="line.703"></a>
<font color="green">704</font>                                              Object value)<a name="line.704"></a>
<font color="green">705</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.705"></a>
<font color="green">706</font>                NoSuchMethodException {<a name="line.706"></a>
<font color="green">707</font>    <a name="line.707"></a>
<font color="green">708</font>            PropertyUtilsBean.getInstance().setIndexedProperty(bean, name, value);<a name="line.708"></a>
<font color="green">709</font>    <a name="line.709"></a>
<font color="green">710</font>        }<a name="line.710"></a>
<font color="green">711</font>    <a name="line.711"></a>
<font color="green">712</font>    <a name="line.712"></a>
<font color="green">713</font>        /**<a name="line.713"></a>
<font color="green">714</font>         * &lt;p&gt;Sets the value of the specified indexed property of the specified<a name="line.714"></a>
<font color="green">715</font>         * bean, with no type conversions.&lt;/p&gt;<a name="line.715"></a>
<font color="green">716</font>         *<a name="line.716"></a>
<font color="green">717</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.717"></a>
<font color="green">718</font>         *<a name="line.718"></a>
<font color="green">719</font>         * @param bean Bean whose property is to be set<a name="line.719"></a>
<font color="green">720</font>         * @param name Simple property name of the property value to be set<a name="line.720"></a>
<font color="green">721</font>         * @param index Index of the property value to be set<a name="line.721"></a>
<font color="green">722</font>         * @param value Value to which the indexed property element is to be set<a name="line.722"></a>
<font color="green">723</font>         *<a name="line.723"></a>
<font color="green">724</font>         * @exception IndexOutOfBoundsException if the specified index<a name="line.724"></a>
<font color="green">725</font>         *  is outside the valid range for the underlying property<a name="line.725"></a>
<font color="green">726</font>         * @exception IllegalAccessException if the caller does not have<a name="line.726"></a>
<font color="green">727</font>         *  access to the property accessor method<a name="line.727"></a>
<font color="green">728</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.728"></a>
<font color="green">729</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.729"></a>
<font color="green">730</font>         * @exception InvocationTargetException if the property accessor method<a name="line.730"></a>
<font color="green">731</font>         *  throws an exception<a name="line.731"></a>
<font color="green">732</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.732"></a>
<font color="green">733</font>         *  propety cannot be found<a name="line.733"></a>
<font color="green">734</font>         * @see PropertyUtilsBean#setIndexedProperty(Object, String, Object)<a name="line.734"></a>
<font color="green">735</font>         */<a name="line.735"></a>
<font color="green">736</font>        public static void setIndexedProperty(Object bean, String name,<a name="line.736"></a>
<font color="green">737</font>                                              int index, Object value)<a name="line.737"></a>
<font color="green">738</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.738"></a>
<font color="green">739</font>                NoSuchMethodException {<a name="line.739"></a>
<font color="green">740</font>    <a name="line.740"></a>
<font color="green">741</font>            PropertyUtilsBean.getInstance().setIndexedProperty(bean, name, index, value);<a name="line.741"></a>
<font color="green">742</font>        }<a name="line.742"></a>
<font color="green">743</font>    <a name="line.743"></a>
<font color="green">744</font>    <a name="line.744"></a>
<font color="green">745</font>        /**<a name="line.745"></a>
<font color="green">746</font>         * &lt;p&gt;Sets the value of the specified mapped property of the<a name="line.746"></a>
<font color="green">747</font>         * specified bean, with no type conversions.&lt;/p&gt;<a name="line.747"></a>
<font color="green">748</font>         *<a name="line.748"></a>
<font color="green">749</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.749"></a>
<font color="green">750</font>         *<a name="line.750"></a>
<font color="green">751</font>         * @param bean Bean whose property is to be set<a name="line.751"></a>
<font color="green">752</font>         * @param name &lt;code&gt;propertyname(key)&lt;/code&gt; of the property value<a name="line.752"></a>
<font color="green">753</font>         *  to be set<a name="line.753"></a>
<font color="green">754</font>         * @param value The property value to be set<a name="line.754"></a>
<font color="green">755</font>         *<a name="line.755"></a>
<font color="green">756</font>         * @exception IllegalAccessException if the caller does not have<a name="line.756"></a>
<font color="green">757</font>         *  access to the property accessor method<a name="line.757"></a>
<font color="green">758</font>         * @exception InvocationTargetException if the property accessor method<a name="line.758"></a>
<font color="green">759</font>         *  throws an exception<a name="line.759"></a>
<font color="green">760</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.760"></a>
<font color="green">761</font>         *  propety cannot be found<a name="line.761"></a>
<font color="green">762</font>         * @see PropertyUtilsBean#setMappedProperty(Object, String, Object)<a name="line.762"></a>
<font color="green">763</font>         */<a name="line.763"></a>
<font color="green">764</font>        public static void setMappedProperty(Object bean, String name,<a name="line.764"></a>
<font color="green">765</font>                                             Object value)<a name="line.765"></a>
<font color="green">766</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.766"></a>
<font color="green">767</font>                NoSuchMethodException {<a name="line.767"></a>
<font color="green">768</font>    <a name="line.768"></a>
<font color="green">769</font>            PropertyUtilsBean.getInstance().setMappedProperty(bean, name, value);<a name="line.769"></a>
<font color="green">770</font>        }<a name="line.770"></a>
<font color="green">771</font>    <a name="line.771"></a>
<font color="green">772</font>    <a name="line.772"></a>
<font color="green">773</font>        /**<a name="line.773"></a>
<font color="green">774</font>         * &lt;p&gt;Sets the value of the specified mapped property of the specified<a name="line.774"></a>
<font color="green">775</font>         * bean, with no type conversions.&lt;/p&gt;<a name="line.775"></a>
<font color="green">776</font>         *<a name="line.776"></a>
<font color="green">777</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.777"></a>
<font color="green">778</font>         *<a name="line.778"></a>
<font color="green">779</font>         * @param bean Bean whose property is to be set<a name="line.779"></a>
<font color="green">780</font>         * @param name Mapped property name of the property value to be set<a name="line.780"></a>
<font color="green">781</font>         * @param key Key of the property value to be set<a name="line.781"></a>
<font color="green">782</font>         * @param value The property value to be set<a name="line.782"></a>
<font color="green">783</font>         *<a name="line.783"></a>
<font color="green">784</font>         * @exception IllegalAccessException if the caller does not have<a name="line.784"></a>
<font color="green">785</font>         *  access to the property accessor method<a name="line.785"></a>
<font color="green">786</font>         * @exception InvocationTargetException if the property accessor method<a name="line.786"></a>
<font color="green">787</font>         *  throws an exception<a name="line.787"></a>
<font color="green">788</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.788"></a>
<font color="green">789</font>         *  propety cannot be found<a name="line.789"></a>
<font color="green">790</font>         * @see PropertyUtilsBean#setMappedProperty(Object, String, String, Object)<a name="line.790"></a>
<font color="green">791</font>         */<a name="line.791"></a>
<font color="green">792</font>        public static void setMappedProperty(Object bean, String name,<a name="line.792"></a>
<font color="green">793</font>                                             String key, Object value)<a name="line.793"></a>
<font color="green">794</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.794"></a>
<font color="green">795</font>                NoSuchMethodException {<a name="line.795"></a>
<font color="green">796</font>    <a name="line.796"></a>
<font color="green">797</font>            PropertyUtilsBean.getInstance().setMappedProperty(bean, name, key, value);<a name="line.797"></a>
<font color="green">798</font>        }<a name="line.798"></a>
<font color="green">799</font>    <a name="line.799"></a>
<font color="green">800</font>    <a name="line.800"></a>
<font color="green">801</font>        /**<a name="line.801"></a>
<font color="green">802</font>         * &lt;p&gt;Sets the value of the (possibly nested) property of the specified<a name="line.802"></a>
<font color="green">803</font>         * name, for the specified bean, with no type conversions.&lt;/p&gt;<a name="line.803"></a>
<font color="green">804</font>         *<a name="line.804"></a>
<font color="green">805</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.805"></a>
<font color="green">806</font>         *<a name="line.806"></a>
<font color="green">807</font>         * @param bean Bean whose property is to be modified<a name="line.807"></a>
<font color="green">808</font>         * @param name Possibly nested name of the property to be modified<a name="line.808"></a>
<font color="green">809</font>         * @param value Value to which the property is to be set<a name="line.809"></a>
<font color="green">810</font>         *<a name="line.810"></a>
<font color="green">811</font>         * @exception IllegalAccessException if the caller does not have<a name="line.811"></a>
<font color="green">812</font>         *  access to the property accessor method<a name="line.812"></a>
<font color="green">813</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.813"></a>
<font color="green">814</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.814"></a>
<font color="green">815</font>         * @exception IllegalArgumentException if a nested reference to a<a name="line.815"></a>
<font color="green">816</font>         *  property returns null<a name="line.816"></a>
<font color="green">817</font>         * @exception InvocationTargetException if the property accessor method<a name="line.817"></a>
<font color="green">818</font>         *  throws an exception<a name="line.818"></a>
<font color="green">819</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.819"></a>
<font color="green">820</font>         *  propety cannot be found<a name="line.820"></a>
<font color="green">821</font>         * @see PropertyUtilsBean#setNestedProperty<a name="line.821"></a>
<font color="green">822</font>         */<a name="line.822"></a>
<font color="green">823</font>        public static void setNestedProperty(Object bean,<a name="line.823"></a>
<font color="green">824</font>                                             String name, Object value)<a name="line.824"></a>
<font color="green">825</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.825"></a>
<font color="green">826</font>                NoSuchMethodException {<a name="line.826"></a>
<font color="green">827</font>    <a name="line.827"></a>
<font color="green">828</font>            PropertyUtilsBean.getInstance().setNestedProperty(bean, name, value);<a name="line.828"></a>
<font color="green">829</font>        }<a name="line.829"></a>
<font color="green">830</font>    <a name="line.830"></a>
<font color="green">831</font>    <a name="line.831"></a>
<font color="green">832</font>        /**<a name="line.832"></a>
<font color="green">833</font>         * &lt;p&gt;Set the value of the specified property of the specified bean,<a name="line.833"></a>
<font color="green">834</font>         * no matter which property reference format is used, with no<a name="line.834"></a>
<font color="green">835</font>         * type conversions.&lt;/p&gt;<a name="line.835"></a>
<font color="green">836</font>         *<a name="line.836"></a>
<font color="green">837</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.837"></a>
<font color="green">838</font>         *<a name="line.838"></a>
<font color="green">839</font>         * @param bean Bean whose property is to be modified<a name="line.839"></a>
<font color="green">840</font>         * @param name Possibly indexed and/or nested name of the property<a name="line.840"></a>
<font color="green">841</font>         *  to be modified<a name="line.841"></a>
<font color="green">842</font>         * @param value Value to which this property is to be set<a name="line.842"></a>
<font color="green">843</font>         *<a name="line.843"></a>
<font color="green">844</font>         * @exception IllegalAccessException if the caller does not have<a name="line.844"></a>
<font color="green">845</font>         *  access to the property accessor method<a name="line.845"></a>
<font color="green">846</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.846"></a>
<font color="green">847</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.847"></a>
<font color="green">848</font>         * @exception InvocationTargetException if the property accessor method<a name="line.848"></a>
<font color="green">849</font>         *  throws an exception<a name="line.849"></a>
<font color="green">850</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.850"></a>
<font color="green">851</font>         *  propety cannot be found<a name="line.851"></a>
<font color="green">852</font>         * @see PropertyUtilsBean#setProperty<a name="line.852"></a>
<font color="green">853</font>         */<a name="line.853"></a>
<font color="green">854</font>        public static void setProperty(Object bean, String name, Object value)<a name="line.854"></a>
<font color="green">855</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.855"></a>
<font color="green">856</font>                NoSuchMethodException {<a name="line.856"></a>
<font color="green">857</font>    <a name="line.857"></a>
<font color="green">858</font>            PropertyUtilsBean.getInstance().setProperty(bean, name, value);<a name="line.858"></a>
<font color="green">859</font>    <a name="line.859"></a>
<font color="green">860</font>        }<a name="line.860"></a>
<font color="green">861</font>    <a name="line.861"></a>
<font color="green">862</font>    <a name="line.862"></a>
<font color="green">863</font>        /**<a name="line.863"></a>
<font color="green">864</font>         * &lt;p&gt;Set the value of the specified simple property of the specified bean,<a name="line.864"></a>
<font color="green">865</font>         * with no type conversions.&lt;/p&gt;<a name="line.865"></a>
<font color="green">866</font>         *<a name="line.866"></a>
<font color="green">867</font>         * &lt;p&gt;For more details see &lt;code&gt;PropertyUtilsBean&lt;/code&gt;.&lt;/p&gt;<a name="line.867"></a>
<font color="green">868</font>         *<a name="line.868"></a>
<font color="green">869</font>         * @param bean Bean whose property is to be modified<a name="line.869"></a>
<font color="green">870</font>         * @param name Name of the property to be modified<a name="line.870"></a>
<font color="green">871</font>         * @param value Value to which the property should be set<a name="line.871"></a>
<font color="green">872</font>         *<a name="line.872"></a>
<font color="green">873</font>         * @exception IllegalAccessException if the caller does not have<a name="line.873"></a>
<font color="green">874</font>         *  access to the property accessor method<a name="line.874"></a>
<font color="green">875</font>         * @exception IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or<a name="line.875"></a>
<font color="green">876</font>         *  &lt;code&gt;name&lt;/code&gt; is null<a name="line.876"></a>
<font color="green">877</font>         * @exception IllegalArgumentException if the property name is<a name="line.877"></a>
<font color="green">878</font>         *  nested or indexed<a name="line.878"></a>
<font color="green">879</font>         * @exception InvocationTargetException if the property accessor method<a name="line.879"></a>
<font color="green">880</font>         *  throws an exception<a name="line.880"></a>
<font color="green">881</font>         * @exception NoSuchMethodException if an accessor method for this<a name="line.881"></a>
<font color="green">882</font>         *  propety cannot be found<a name="line.882"></a>
<font color="green">883</font>         * @see PropertyUtilsBean#setSimpleProperty<a name="line.883"></a>
<font color="green">884</font>         */<a name="line.884"></a>
<font color="green">885</font>        public static void setSimpleProperty(Object bean,<a name="line.885"></a>
<font color="green">886</font>                                             String name, Object value)<a name="line.886"></a>
<font color="green">887</font>                throws IllegalAccessException, InvocationTargetException,<a name="line.887"></a>
<font color="green">888</font>                NoSuchMethodException {<a name="line.888"></a>
<font color="green">889</font>    <a name="line.889"></a>
<font color="green">890</font>            PropertyUtilsBean.getInstance().setSimpleProperty(bean, name, value);<a name="line.890"></a>
<font color="green">891</font>        }<a name="line.891"></a>
<font color="green">892</font>    <a name="line.892"></a>
<font color="green">893</font>    <a name="line.893"></a>
<font color="green">894</font>    }<a name="line.894"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/NestedNullException/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/NestedNullException/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:14:01" itemprop="dateModified" datetime="2010-03-24T17:14:01+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>     <a name="line.17"></a>
<font color="green">018</font>    package org.apache.commons.beanutils;<a name="line.18"></a>
<font color="green">019</font>    <a name="line.19"></a>
<font color="green">020</font>    /** <a name="line.20"></a>
<font color="green">021</font>     * Thrown to indicate that the &lt;em&gt;Bean Access Language&lt;/em&gt; cannot execute query<a name="line.21"></a>
<font color="green">022</font>     * against given bean since a nested bean referenced is null.<a name="line.22"></a>
<font color="green">023</font>     *<a name="line.23"></a>
<font color="green">024</font>     * @author Robert Burrell Donkin<a name="line.24"></a>
<font color="green">025</font>     * @since 1.7<a name="line.25"></a>
<font color="green">026</font>     */<a name="line.26"></a>
<font color="green">027</font>    <a name="line.27"></a>
<font color="green">028</font>    public class NestedNullException extends BeanAccessLanguageException {<a name="line.28"></a>
<font color="green">029</font>        <a name="line.29"></a>
<font color="green">030</font>        // --------------------------------------------------------- Constuctors<a name="line.30"></a>
<font color="green">031</font>        <a name="line.31"></a>
<font color="green">032</font>        /** <a name="line.32"></a>
<font color="green">033</font>         * Constructs a &lt;code&gt;NestedNullException&lt;/code&gt; without a detail message.<a name="line.33"></a>
<font color="green">034</font>         */<a name="line.34"></a>
<font color="green">035</font>        public NestedNullException() {<a name="line.35"></a>
<font color="green">036</font>            super();<a name="line.36"></a>
<font color="green">037</font>        }<a name="line.37"></a>
<font color="green">038</font>        <a name="line.38"></a>
<font color="green">039</font>        /**<a name="line.39"></a>
<font color="green">040</font>         * Constructs a &lt;code&gt;NestedNullException&lt;/code&gt; without a detail message.<a name="line.40"></a>
<font color="green">041</font>         * <a name="line.41"></a>
<font color="green">042</font>         * @param message the detail message explaining this exception<a name="line.42"></a>
<font color="green">043</font>         */<a name="line.43"></a>
<font color="green">044</font>        public NestedNullException(String message) {<a name="line.44"></a>
<font color="green">045</font>            super(message);<a name="line.45"></a>
<font color="green">046</font>        }<a name="line.46"></a>
<font color="green">047</font>    }<a name="line.47"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/MutableDynaClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/MutableDynaClass/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:14:01" itemprop="dateModified" datetime="2010-03-24T17:14:01+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>    <a name="line.17"></a>
<font color="green">018</font>    package org.apache.commons.beanutils;<a name="line.18"></a>
<font color="green">019</font>    <a name="line.19"></a>
<font color="green">020</font>    <a name="line.20"></a>
<font color="green">021</font>    <a name="line.21"></a>
<font color="green">022</font>    <a name="line.22"></a>
<font color="green">023</font>    <a name="line.23"></a>
<font color="green">024</font>    /**<a name="line.24"></a>
<font color="green">025</font>     * &lt;p&gt;A specialized extension to &lt;code&gt;DynaClass&lt;/code&gt; that allows properties<a name="line.25"></a>
<font color="green">026</font>     * to be added or removed dynamically.&lt;/p&gt;<a name="line.26"></a>
<font color="green">027</font>     *<a name="line.27"></a>
<font color="green">028</font>     * &lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; - No guarantees that this will be in the final<a name="line.28"></a>
<font color="green">029</font>     * APIs ... it's here primarily to preserve some concepts that were in the<a name="line.29"></a>
<font color="green">030</font>     * original proposal for further discussion.&lt;/p&gt;<a name="line.30"></a>
<font color="green">031</font>     *<a name="line.31"></a>
<font color="green">032</font>     * @author Craig McClanahan<a name="line.32"></a>
<font color="green">033</font>     * @author Michael Smith<a name="line.33"></a>
<font color="green">034</font>     * @author Paulo Gaspar<a name="line.34"></a>
<font color="green">035</font>     * @version $Revision: 555824 $ $Date: 2007-07-13 01:27:15 +0100 (Fri, 13 Jul 2007) $<a name="line.35"></a>
<font color="green">036</font>     */<a name="line.36"></a>
<font color="green">037</font>    <a name="line.37"></a>
<font color="green">038</font>    public interface MutableDynaClass extends DynaClass {<a name="line.38"></a>
<font color="green">039</font>    <a name="line.39"></a>
<font color="green">040</font>    <a name="line.40"></a>
<font color="green">041</font>        /**<a name="line.41"></a>
<font color="green">042</font>         * Add a new dynamic property with no restrictions on data type,<a name="line.42"></a>
<font color="green">043</font>         * readability, or writeability.<a name="line.43"></a>
<font color="green">044</font>         *<a name="line.44"></a>
<font color="green">045</font>         * @param name Name of the new dynamic property<a name="line.45"></a>
<font color="green">046</font>         *<a name="line.46"></a>
<font color="green">047</font>         * @exception IllegalArgumentException if name is null<a name="line.47"></a>
<font color="green">048</font>         * @exception IllegalStateException if this DynaClass is currently<a name="line.48"></a>
<font color="green">049</font>         *  restricted, so no new properties can be added<a name="line.49"></a>
<font color="green">050</font>         */<a name="line.50"></a>
<font color="green">051</font>        public void add(String name);<a name="line.51"></a>
<font color="green">052</font>    <a name="line.52"></a>
<font color="green">053</font>    <a name="line.53"></a>
<font color="green">054</font>        /**<a name="line.54"></a>
<font color="green">055</font>         * Add a new dynamic property with the specified data type, but with<a name="line.55"></a>
<font color="green">056</font>         * no restrictions on readability or writeability.<a name="line.56"></a>
<font color="green">057</font>         *<a name="line.57"></a>
<font color="green">058</font>         * @param name Name of the new dynamic property<a name="line.58"></a>
<font color="green">059</font>         * @param type Data type of the new dynamic property (null for no<a name="line.59"></a>
<font color="green">060</font>         *  restrictions)<a name="line.60"></a>
<font color="green">061</font>         *<a name="line.61"></a>
<font color="green">062</font>         * @exception IllegalArgumentException if name is null<a name="line.62"></a>
<font color="green">063</font>         * @exception IllegalStateException if this DynaClass is currently<a name="line.63"></a>
<font color="green">064</font>         *  restricted, so no new properties can be added<a name="line.64"></a>
<font color="green">065</font>         */<a name="line.65"></a>
<font color="green">066</font>        public void add(String name, Class type);<a name="line.66"></a>
<font color="green">067</font>    <a name="line.67"></a>
<font color="green">068</font>    <a name="line.68"></a>
<font color="green">069</font>        /**<a name="line.69"></a>
<font color="green">070</font>         * Add a new dynamic property with the specified data type, readability,<a name="line.70"></a>
<font color="green">071</font>         * and writeability.<a name="line.71"></a>
<font color="green">072</font>         *<a name="line.72"></a>
<font color="green">073</font>         * @param name Name of the new dynamic property<a name="line.73"></a>
<font color="green">074</font>         * @param type Data type of the new dynamic property (null for no<a name="line.74"></a>
<font color="green">075</font>         *  restrictions)<a name="line.75"></a>
<font color="green">076</font>         * @param readable Set to &lt;code&gt;true&lt;/code&gt; if this property value<a name="line.76"></a>
<font color="green">077</font>         *  should be readable<a name="line.77"></a>
<font color="green">078</font>         * @param writeable Set to &lt;code&gt;true&lt;/code&gt; if this property value<a name="line.78"></a>
<font color="green">079</font>         *  should be writeable<a name="line.79"></a>
<font color="green">080</font>         *<a name="line.80"></a>
<font color="green">081</font>         * @exception IllegalArgumentException if name is null<a name="line.81"></a>
<font color="green">082</font>         * @exception IllegalStateException if this DynaClass is currently<a name="line.82"></a>
<font color="green">083</font>         *  restricted, so no new properties can be added<a name="line.83"></a>
<font color="green">084</font>         */<a name="line.84"></a>
<font color="green">085</font>        public void add(String name, Class type, boolean readable,<a name="line.85"></a>
<font color="green">086</font>                        boolean writeable);<a name="line.86"></a>
<font color="green">087</font>    <a name="line.87"></a>
<font color="green">088</font>    <a name="line.88"></a>
<font color="green">089</font>        /**<a name="line.89"></a>
<font color="green">090</font>         * Is this DynaClass currently restricted, if so, no changes to the<a name="line.90"></a>
<font color="green">091</font>         * existing registration of property names, data types, readability, or<a name="line.91"></a>
<font color="green">092</font>         * writeability are allowed.<a name="line.92"></a>
<font color="green">093</font>         *<a name="line.93"></a>
<font color="green">094</font>         * @return &lt;code&gt;true&lt;/code&gt; if this Mutable {@link DynaClass} is restricted,<a name="line.94"></a>
<font color="green">095</font>         * otherwise &lt;code&gt;false&lt;/code&gt;<a name="line.95"></a>
<font color="green">096</font>         */<a name="line.96"></a>
<font color="green">097</font>        public boolean isRestricted();<a name="line.97"></a>
<font color="green">098</font>    <a name="line.98"></a>
<font color="green">099</font>    <a name="line.99"></a>
<font color="green">100</font>        /**<a name="line.100"></a>
<font color="green">101</font>         * Remove the specified dynamic property, and any associated data type,<a name="line.101"></a>
<font color="green">102</font>         * readability, and writeability, from this dynamic class.<a name="line.102"></a>
<font color="green">103</font>         * &lt;strong&gt;NOTE&lt;/strong&gt; - This does &lt;strong&gt;NOT&lt;/strong&gt; cause any<a name="line.103"></a>
<font color="green">104</font>         * corresponding property values to be removed from DynaBean instances<a name="line.104"></a>
<font color="green">105</font>         * associated with this DynaClass.<a name="line.105"></a>
<font color="green">106</font>         *<a name="line.106"></a>
<font color="green">107</font>         * @param name Name of the dynamic property to remove<a name="line.107"></a>
<font color="green">108</font>         *<a name="line.108"></a>
<font color="green">109</font>         * @exception IllegalArgumentException if name is null<a name="line.109"></a>
<font color="green">110</font>         * @exception IllegalStateException if this DynaClass is currently<a name="line.110"></a>
<font color="green">111</font>         *  restricted, so no properties can be removed<a name="line.111"></a>
<font color="green">112</font>         */<a name="line.112"></a>
<font color="green">113</font>        public void remove(String name);<a name="line.113"></a>
<font color="green">114</font>    <a name="line.114"></a>
<font color="green">115</font>    <a name="line.115"></a>
<font color="green">116</font>        /**<a name="line.116"></a>
<font color="green">117</font>         * Set the restricted state of this DynaClass to the specified value.<a name="line.117"></a>
<font color="green">118</font>         *<a name="line.118"></a>
<font color="green">119</font>         * @param restricted The new restricted state<a name="line.119"></a>
<font color="green">120</font>         */<a name="line.120"></a>
<font color="green">121</font>        public void setRestricted(boolean restricted);<a name="line.121"></a>
<font color="green">122</font>    <a name="line.122"></a>
<font color="green">123</font>    <a name="line.123"></a>
<font color="green">124</font>    }<a name="line.124"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/MethodUtils/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吒儿">
      <meta itemprop="description" content="去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!">
      <meta itemprop="image" content="/images/nezha.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学海无涯，惟勤是岸。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/day07-MVC设计模式/day15/code&资料/资料/beanutils/commons-beanutils-1.8.3-bin/commons-beanutils-1.8.3/apidocs/src-html/org/apache/commons/beanutils/MethodUtils/" class="post-title-link" itemprop="url">未命名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-26 15:56:22" itemprop="dateCreated datePublished" datetime="2019-08-26T15:56:22+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2010-03-24 17:14:01" itemprop="dateModified" datetime="2010-03-24T17:14:01+08:00">2010-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html>
<body bgcolor="white">
<pre>
<font color="green">001</font>    /*<a name="line.1"></a>
<font color="green">002</font>     * Licensed to the Apache Software Foundation (ASF) under one or more<a name="line.2"></a>
<font color="green">003</font>     * contributor license agreements.  See the NOTICE file distributed with<a name="line.3"></a>
<font color="green">004</font>     * this work for additional information regarding copyright ownership.<a name="line.4"></a>
<font color="green">005</font>     * The ASF licenses this file to You under the Apache License, Version 2.0<a name="line.5"></a>
<font color="green">006</font>     * (the "License"); you may not use this file except in compliance with<a name="line.6"></a>
<font color="green">007</font>     * the License.  You may obtain a copy of the License at<a name="line.7"></a>
<font color="green">008</font>     *<a name="line.8"></a>
<font color="green">009</font>     *      http://www.apache.org/licenses/LICENSE-2.0<a name="line.9"></a>
<font color="green">010</font>     *<a name="line.10"></a>
<font color="green">011</font>     * Unless required by applicable law or agreed to in writing, software<a name="line.11"></a>
<font color="green">012</font>     * distributed under the License is distributed on an "AS IS" BASIS,<a name="line.12"></a>
<font color="green">013</font>     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<a name="line.13"></a>
<font color="green">014</font>     * See the License for the specific language governing permissions and<a name="line.14"></a>
<font color="green">015</font>     * limitations under the License.<a name="line.15"></a>
<font color="green">016</font>     */<a name="line.16"></a>
<font color="green">017</font>    <a name="line.17"></a>
<font color="green">018</font>    package org.apache.commons.beanutils;<a name="line.18"></a>
<font color="green">019</font>    <a name="line.19"></a>
<font color="green">020</font>    <a name="line.20"></a>
<font color="green">021</font>    import java.lang.ref.Reference;<a name="line.21"></a>
<font color="green">022</font>    import java.lang.ref.WeakReference;<a name="line.22"></a>
<font color="green">023</font>    import java.lang.reflect.InvocationTargetException;<a name="line.23"></a>
<font color="green">024</font>    import java.lang.reflect.Method;<a name="line.24"></a>
<font color="green">025</font>    import java.lang.reflect.Modifier;<a name="line.25"></a>
<font color="green">026</font>    import java.util.Collections;<a name="line.26"></a>
<font color="green">027</font>    import java.util.Map;<a name="line.27"></a>
<font color="green">028</font>    import java.util.WeakHashMap;<a name="line.28"></a>
<font color="green">029</font>    <a name="line.29"></a>
<font color="green">030</font>    import org.apache.commons.logging.Log;<a name="line.30"></a>
<font color="green">031</font>    import org.apache.commons.logging.LogFactory;<a name="line.31"></a>
<font color="green">032</font>    <a name="line.32"></a>
<font color="green">033</font>    <a name="line.33"></a>
<font color="green">034</font>    /**<a name="line.34"></a>
<font color="green">035</font>     * &lt;p&gt; Utility reflection methods focussed on methods in general rather than properties in particular. &lt;/p&gt;<a name="line.35"></a>
<font color="green">036</font>     *<a name="line.36"></a>
<font color="green">037</font>     * &lt;h3&gt;Known Limitations&lt;/h3&gt;<a name="line.37"></a>
<font color="green">038</font>     * &lt;h4&gt;Accessing Public Methods In A Default Access Superclass&lt;/h4&gt;<a name="line.38"></a>
<font color="green">039</font>     * &lt;p&gt;There is an issue when invoking public methods contained in a default access superclass.<a name="line.39"></a>
<font color="green">040</font>     * Reflection locates these methods fine and correctly assigns them as public.<a name="line.40"></a>
<font color="green">041</font>     * However, an &lt;code&gt;IllegalAccessException&lt;/code&gt; is thrown if the method is invoked.&lt;/p&gt;<a name="line.41"></a>
<font color="green">042</font>     *<a name="line.42"></a>
<font color="green">043</font>     * &lt;p&gt;&lt;code&gt;MethodUtils&lt;/code&gt; contains a workaround for this situation. <a name="line.43"></a>
<font color="green">044</font>     * It will attempt to call &lt;code&gt;setAccessible&lt;/code&gt; on this method.<a name="line.44"></a>
<font color="green">045</font>     * If this call succeeds, then the method can be invoked as normal.<a name="line.45"></a>
<font color="green">046</font>     * This call will only succeed when the application has sufficient security privilages. <a name="line.46"></a>
<font color="green">047</font>     * If this call fails then a warning will be logged and the method may fail.&lt;/p&gt;<a name="line.47"></a>
<font color="green">048</font>     *<a name="line.48"></a>
<font color="green">049</font>     * @author Craig R. McClanahan<a name="line.49"></a>
<font color="green">050</font>     * @author Ralph Schaer<a name="line.50"></a>
<font color="green">051</font>     * @author Chris Audley<a name="line.51"></a>
<font color="green">052</font>     * @author Rey Fran&amp;#231;ois<a name="line.52"></a>
<font color="green">053</font>     * @author Gregor Ra&amp;#253;man<a name="line.53"></a>
<font color="green">054</font>     * @author Jan Sorensen<a name="line.54"></a>
<font color="green">055</font>     * @author Robert Burrell Donkin<a name="line.55"></a>
<font color="green">056</font>     */<a name="line.56"></a>
<font color="green">057</font>    <a name="line.57"></a>
<font color="green">058</font>    public class MethodUtils {<a name="line.58"></a>
<font color="green">059</font>    <a name="line.59"></a>
<font color="green">060</font>        // --------------------------------------------------------- Private Methods<a name="line.60"></a>
<font color="green">061</font>        <a name="line.61"></a>
<font color="green">062</font>        /** <a name="line.62"></a>
<font color="green">063</font>         * Only log warning about accessibility work around once.<a name="line.63"></a>
<font color="green">064</font>         * &lt;p&gt;<a name="line.64"></a>
<font color="green">065</font>         * Note that this is broken when this class is deployed via a shared<a name="line.65"></a>
<font color="green">066</font>         * classloader in a container, as the warning message will be emitted<a name="line.66"></a>
<font color="green">067</font>         * only once, not once per webapp. However making the warning appear<a name="line.67"></a>
<font color="green">068</font>         * once per webapp means having a map keyed by context classloader<a name="line.68"></a>
<font color="green">069</font>         * which introduces nasty memory-leak problems. As this warning is<a name="line.69"></a>
<font color="green">070</font>         * really optional we can ignore this problem; only one of the webapps<a name="line.70"></a>
<font color="green">071</font>         * will get the warning in its logs but that should be good enough.<a name="line.71"></a>
<font color="green">072</font>         */<a name="line.72"></a>
<font color="green">073</font>        private static boolean loggedAccessibleWarning = false;<a name="line.73"></a>
<font color="green">074</font>        <a name="line.74"></a>
<font color="green">075</font>        /** <a name="line.75"></a>
<font color="green">076</font>         * Indicates whether methods should be cached for improved performance.<a name="line.76"></a>
<font color="green">077</font>         * &lt;p&gt;<a name="line.77"></a>
<font color="green">078</font>         * Note that when this class is deployed via a shared classloader in<a name="line.78"></a>
<font color="green">079</font>         * a container, this will affect all webapps. However making this<a name="line.79"></a>
<font color="green">080</font>         * configurable per webapp would mean having a map keyed by context classloader<a name="line.80"></a>
<font color="green">081</font>         * which may introduce memory-leak problems.<a name="line.81"></a>
<font color="green">082</font>         */<a name="line.82"></a>
<font color="green">083</font>        private static boolean CACHE_METHODS = true;<a name="line.83"></a>
<font color="green">084</font>    <a name="line.84"></a>
<font color="green">085</font>        /** An empty class array */<a name="line.85"></a>
<font color="green">086</font>        private static final Class[] EMPTY_CLASS_PARAMETERS = new Class[0];<a name="line.86"></a>
<font color="green">087</font>        /** An empty object array */<a name="line.87"></a>
<font color="green">088</font>        private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];<a name="line.88"></a>
<font color="green">089</font>    <a name="line.89"></a>
<font color="green">090</font>        /**<a name="line.90"></a>
<font color="green">091</font>         * Stores a cache of MethodDescriptor -&gt; Method in a WeakHashMap.<a name="line.91"></a>
<font color="green">092</font>         * &lt;p&gt;<a name="line.92"></a>
<font color="green">093</font>         * The keys into this map only ever exist as temporary variables within<a name="line.93"></a>
<font color="green">094</font>         * methods of this class, and are never exposed to users of this class.<a name="line.94"></a>
<font color="green">095</font>         * This means that the WeakHashMap is used only as a mechanism for <a name="line.95"></a>
<font color="green">096</font>         * limiting the size of the cache, ie a way to tell the garbage collector<a name="line.96"></a>
<font color="green">097</font>         * that the contents of the cache can be completely garbage-collected <a name="line.97"></a>
<font color="green">098</font>         * whenever it needs the memory. Whether this is a good approach to<a name="line.98"></a>
<font color="green">099</font>         * this problem is doubtful; something like the commons-collections<a name="line.99"></a>
<font color="green">100</font>         * LRUMap may be more appropriate (though of course selecting an<a name="line.100"></a>
<font color="green">101</font>         * appropriate size is an issue).<a name="line.101"></a>
<font color="green">102</font>         * &lt;p&gt;<a name="line.102"></a>
<font color="green">103</font>         * This static variable is safe even when this code is deployed via a<a name="line.103"></a>
<font color="green">104</font>         * shared classloader because it is keyed via a MethodDescriptor object<a name="line.104"></a>
<font color="green">105</font>         * which has a Class as one of its members and that member is used in<a name="line.105"></a>
<font color="green">106</font>         * the MethodDescriptor.equals method. So two components that load the same<a name="line.106"></a>
<font color="green">107</font>         * class via different classloaders will generate non-equal MethodDescriptor<a name="line.107"></a>
<font color="green">108</font>         * objects and hence end up with different entries in the map.<a name="line.108"></a>
<font color="green">109</font>         */<a name="line.109"></a>
<font color="green">110</font>        private static final Map cache = Collections.synchronizedMap(new WeakHashMap());<a name="line.110"></a>
<font color="green">111</font>        <a name="line.111"></a>
<font color="green">112</font>        // --------------------------------------------------------- Public Methods<a name="line.112"></a>
<font color="green">113</font>    <a name="line.113"></a>
<font color="green">114</font>        /**<a name="line.114"></a>
<font color="green">115</font>         * Set whether methods should be cached for greater performance or not,<a name="line.115"></a>
<font color="green">116</font>         * default is &lt;code&gt;true&lt;/code&gt;.<a name="line.116"></a>
<font color="green">117</font>         *<a name="line.117"></a>
<font color="green">118</font>         * @param cacheMethods &lt;code&gt;true&lt;/code&gt; if methods should be<a name="line.118"></a>
<font color="green">119</font>         * cached for greater performance, otherwise &lt;code&gt;false&lt;/code&gt;<a name="line.119"></a>
<font color="green">120</font>         * @since 1.8.0<a name="line.120"></a>
<font color="green">121</font>         */<a name="line.121"></a>
<font color="green">122</font>        public static synchronized void setCacheMethods(boolean cacheMethods) {<a name="line.122"></a>
<font color="green">123</font>            CACHE_METHODS = cacheMethods;<a name="line.123"></a>
<font color="green">124</font>            if (!CACHE_METHODS) {<a name="line.124"></a>
<font color="green">125</font>                clearCache();<a name="line.125"></a>
<font color="green">126</font>            }<a name="line.126"></a>
<font color="green">127</font>        }<a name="line.127"></a>
<font color="green">128</font>    <a name="line.128"></a>
<font color="green">129</font>        /**<a name="line.129"></a>
<font color="green">130</font>         * Clear the method cache.<a name="line.130"></a>
<font color="green">131</font>         * @return the number of cached methods cleared<a name="line.131"></a>
<font color="green">132</font>         * @since 1.8.0<a name="line.132"></a>
<font color="green">133</font>         */<a name="line.133"></a>
<font color="green">134</font>        public static synchronized int clearCache() {<a name="line.134"></a>
<font color="green">135</font>            int size = cache.size();<a name="line.135"></a>
<font color="green">136</font>            cache.clear();<a name="line.136"></a>
<font color="green">137</font>            return size;<a name="line.137"></a>
<font color="green">138</font>        }<a name="line.138"></a>
<font color="green">139</font>        <a name="line.139"></a>
<font color="green">140</font>        /**<a name="line.140"></a>
<font color="green">141</font>         * &lt;p&gt;Invoke a named method whose parameter type matches the object type.&lt;/p&gt;<a name="line.141"></a>
<font color="green">142</font>         *<a name="line.142"></a>
<font color="green">143</font>         * &lt;p&gt;The behaviour of this method is less deterministic <a name="line.143"></a>
<font color="green">144</font>         * than &lt;code&gt;invokeExactMethod()&lt;/code&gt;.<a name="line.144"></a>
<font color="green">145</font>         * It loops through all methods with names that match<a name="line.145"></a>
<font color="green">146</font>         * and then executes the first it finds with compatable parameters.&lt;/p&gt;<a name="line.146"></a>
<font color="green">147</font>         *<a name="line.147"></a>
<font color="green">148</font>         * &lt;p&gt;This method supports calls to methods taking primitive parameters <a name="line.148"></a>
<font color="green">149</font>         * via passing in wrapping classes. So, for example, a &lt;code&gt;Boolean&lt;/code&gt; class<a name="line.149"></a>
<font color="green">150</font>         * would match a &lt;code&gt;boolean&lt;/code&gt; primitive.&lt;/p&gt;<a name="line.150"></a>
<font color="green">151</font>         *<a name="line.151"></a>
<font color="green">152</font>         * &lt;p&gt; This is a convenient wrapper for<a name="line.152"></a>
<font color="green">153</font>         * {@link #invokeMethod(Object object,String methodName,Object [] args)}.<a name="line.153"></a>
<font color="green">154</font>         * &lt;/p&gt;<a name="line.154"></a>
<font color="green">155</font>         *<a name="line.155"></a>
<font color="green">156</font>         * @param object invoke method on this object<a name="line.156"></a>
<font color="green">157</font>         * @param methodName get method with this name<a name="line.157"></a>
<font color="green">158</font>         * @param arg use this argument<a name="line.158"></a>
<font color="green">159</font>         * @return The value returned by the invoked method<a name="line.159"></a>
<font color="green">160</font>         *<a name="line.160"></a>
<font color="green">161</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.161"></a>
<font color="green">162</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.162"></a>
<font color="green">163</font>         *  method invoked<a name="line.163"></a>
<font color="green">164</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.164"></a>
<font color="green">165</font>         *  via reflection<a name="line.165"></a>
<font color="green">166</font>         */<a name="line.166"></a>
<font color="green">167</font>        public static Object invokeMethod(<a name="line.167"></a>
<font color="green">168</font>                Object object,<a name="line.168"></a>
<font color="green">169</font>                String methodName,<a name="line.169"></a>
<font color="green">170</font>                Object arg)<a name="line.170"></a>
<font color="green">171</font>                throws<a name="line.171"></a>
<font color="green">172</font>                NoSuchMethodException,<a name="line.172"></a>
<font color="green">173</font>                IllegalAccessException,<a name="line.173"></a>
<font color="green">174</font>                InvocationTargetException {<a name="line.174"></a>
<font color="green">175</font>    <a name="line.175"></a>
<font color="green">176</font>            Object[] args = {arg};<a name="line.176"></a>
<font color="green">177</font>            return invokeMethod(object, methodName, args);<a name="line.177"></a>
<font color="green">178</font>    <a name="line.178"></a>
<font color="green">179</font>        }<a name="line.179"></a>
<font color="green">180</font>    <a name="line.180"></a>
<font color="green">181</font>    <a name="line.181"></a>
<font color="green">182</font>        /**<a name="line.182"></a>
<font color="green">183</font>         * &lt;p&gt;Invoke a named method whose parameter type matches the object type.&lt;/p&gt;<a name="line.183"></a>
<font color="green">184</font>         *<a name="line.184"></a>
<font color="green">185</font>         * &lt;p&gt;The behaviour of this method is less deterministic <a name="line.185"></a>
<font color="green">186</font>         * than {@link #invokeExactMethod(Object object,String methodName,Object [] args)}. <a name="line.186"></a>
<font color="green">187</font>         * It loops through all methods with names that match<a name="line.187"></a>
<font color="green">188</font>         * and then executes the first it finds with compatable parameters.&lt;/p&gt;<a name="line.188"></a>
<font color="green">189</font>         *<a name="line.189"></a>
<font color="green">190</font>         * &lt;p&gt;This method supports calls to methods taking primitive parameters <a name="line.190"></a>
<font color="green">191</font>         * via passing in wrapping classes. So, for example, a &lt;code&gt;Boolean&lt;/code&gt; class<a name="line.191"></a>
<font color="green">192</font>         * would match a &lt;code&gt;boolean&lt;/code&gt; primitive.&lt;/p&gt;<a name="line.192"></a>
<font color="green">193</font>         *<a name="line.193"></a>
<font color="green">194</font>         * &lt;p&gt; This is a convenient wrapper for<a name="line.194"></a>
<font color="green">195</font>         * {@link #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}.<a name="line.195"></a>
<font color="green">196</font>         * &lt;/p&gt;<a name="line.196"></a>
<font color="green">197</font>         *<a name="line.197"></a>
<font color="green">198</font>         * @param object invoke method on this object<a name="line.198"></a>
<font color="green">199</font>         * @param methodName get method with this name<a name="line.199"></a>
<font color="green">200</font>         * @param args use these arguments - treat null as empty array<a name="line.200"></a>
<font color="green">201</font>         * @return The value returned by the invoked method<a name="line.201"></a>
<font color="green">202</font>         *<a name="line.202"></a>
<font color="green">203</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.203"></a>
<font color="green">204</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.204"></a>
<font color="green">205</font>         *  method invoked<a name="line.205"></a>
<font color="green">206</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.206"></a>
<font color="green">207</font>         *  via reflection<a name="line.207"></a>
<font color="green">208</font>         */<a name="line.208"></a>
<font color="green">209</font>        public static Object invokeMethod(<a name="line.209"></a>
<font color="green">210</font>                Object object,<a name="line.210"></a>
<font color="green">211</font>                String methodName,<a name="line.211"></a>
<font color="green">212</font>                Object[] args)<a name="line.212"></a>
<font color="green">213</font>                throws<a name="line.213"></a>
<font color="green">214</font>                NoSuchMethodException,<a name="line.214"></a>
<font color="green">215</font>                IllegalAccessException,<a name="line.215"></a>
<font color="green">216</font>                InvocationTargetException {<a name="line.216"></a>
<font color="green">217</font>            <a name="line.217"></a>
<font color="green">218</font>            if (args == null) {<a name="line.218"></a>
<font color="green">219</font>                args = EMPTY_OBJECT_ARRAY;<a name="line.219"></a>
<font color="green">220</font>            }  <a name="line.220"></a>
<font color="green">221</font>            int arguments = args.length;<a name="line.221"></a>
<font color="green">222</font>            Class[] parameterTypes = new Class[arguments];<a name="line.222"></a>
<font color="green">223</font>            for (int i = 0; i &lt; arguments; i++) {<a name="line.223"></a>
<font color="green">224</font>                parameterTypes[i] = args[i].getClass();<a name="line.224"></a>
<font color="green">225</font>            }<a name="line.225"></a>
<font color="green">226</font>            return invokeMethod(object, methodName, args, parameterTypes);<a name="line.226"></a>
<font color="green">227</font>    <a name="line.227"></a>
<font color="green">228</font>        }<a name="line.228"></a>
<font color="green">229</font>    <a name="line.229"></a>
<font color="green">230</font>    <a name="line.230"></a>
<font color="green">231</font>        /**<a name="line.231"></a>
<font color="green">232</font>         * &lt;p&gt;Invoke a named method whose parameter type matches the object type.&lt;/p&gt;<a name="line.232"></a>
<font color="green">233</font>         *<a name="line.233"></a>
<font color="green">234</font>         * &lt;p&gt;The behaviour of this method is less deterministic <a name="line.234"></a>
<font color="green">235</font>         * than {@link <a name="line.235"></a>
<font color="green">236</font>         * #invokeExactMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}. <a name="line.236"></a>
<font color="green">237</font>         * It loops through all methods with names that match<a name="line.237"></a>
<font color="green">238</font>         * and then executes the first it finds with compatable parameters.&lt;/p&gt;<a name="line.238"></a>
<font color="green">239</font>         *<a name="line.239"></a>
<font color="green">240</font>         * &lt;p&gt;This method supports calls to methods taking primitive parameters <a name="line.240"></a>
<font color="green">241</font>         * via passing in wrapping classes. So, for example, a &lt;code&gt;Boolean&lt;/code&gt; class<a name="line.241"></a>
<font color="green">242</font>         * would match a &lt;code&gt;boolean&lt;/code&gt; primitive.&lt;/p&gt;<a name="line.242"></a>
<font color="green">243</font>         *<a name="line.243"></a>
<font color="green">244</font>         *<a name="line.244"></a>
<font color="green">245</font>         * @param object invoke method on this object<a name="line.245"></a>
<font color="green">246</font>         * @param methodName get method with this name<a name="line.246"></a>
<font color="green">247</font>         * @param args use these arguments - treat null as empty array<a name="line.247"></a>
<font color="green">248</font>         * @param parameterTypes match these parameters - treat null as empty array<a name="line.248"></a>
<font color="green">249</font>         * @return The value returned by the invoked method<a name="line.249"></a>
<font color="green">250</font>         *<a name="line.250"></a>
<font color="green">251</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.251"></a>
<font color="green">252</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.252"></a>
<font color="green">253</font>         *  method invoked<a name="line.253"></a>
<font color="green">254</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.254"></a>
<font color="green">255</font>         *  via reflection<a name="line.255"></a>
<font color="green">256</font>         */<a name="line.256"></a>
<font color="green">257</font>        public static Object invokeMethod(<a name="line.257"></a>
<font color="green">258</font>                Object object,<a name="line.258"></a>
<font color="green">259</font>                String methodName,<a name="line.259"></a>
<font color="green">260</font>                Object[] args,<a name="line.260"></a>
<font color="green">261</font>                Class[] parameterTypes)<a name="line.261"></a>
<font color="green">262</font>                    throws<a name="line.262"></a>
<font color="green">263</font>                        NoSuchMethodException,<a name="line.263"></a>
<font color="green">264</font>                        IllegalAccessException,<a name="line.264"></a>
<font color="green">265</font>                        InvocationTargetException {<a name="line.265"></a>
<font color="green">266</font>                        <a name="line.266"></a>
<font color="green">267</font>            if (parameterTypes == null) {<a name="line.267"></a>
<font color="green">268</font>                parameterTypes = EMPTY_CLASS_PARAMETERS;<a name="line.268"></a>
<font color="green">269</font>            }        <a name="line.269"></a>
<font color="green">270</font>            if (args == null) {<a name="line.270"></a>
<font color="green">271</font>                args = EMPTY_OBJECT_ARRAY;<a name="line.271"></a>
<font color="green">272</font>            }  <a name="line.272"></a>
<font color="green">273</font>    <a name="line.273"></a>
<font color="green">274</font>            Method method = getMatchingAccessibleMethod(<a name="line.274"></a>
<font color="green">275</font>                    object.getClass(),<a name="line.275"></a>
<font color="green">276</font>                    methodName,<a name="line.276"></a>
<font color="green">277</font>                    parameterTypes);<a name="line.277"></a>
<font color="green">278</font>            if (method == null) {<a name="line.278"></a>
<font color="green">279</font>                throw new NoSuchMethodException("No such accessible method: " +<a name="line.279"></a>
<font color="green">280</font>                        methodName + "() on object: " + object.getClass().getName());<a name="line.280"></a>
<font color="green">281</font>            }<a name="line.281"></a>
<font color="green">282</font>            return method.invoke(object, args);<a name="line.282"></a>
<font color="green">283</font>        }<a name="line.283"></a>
<font color="green">284</font>    <a name="line.284"></a>
<font color="green">285</font>    <a name="line.285"></a>
<font color="green">286</font>        /**<a name="line.286"></a>
<font color="green">287</font>         * &lt;p&gt;Invoke a method whose parameter type matches exactly the object<a name="line.287"></a>
<font color="green">288</font>         * type.&lt;/p&gt;<a name="line.288"></a>
<font color="green">289</font>         *<a name="line.289"></a>
<font color="green">290</font>         * &lt;p&gt; This is a convenient wrapper for<a name="line.290"></a>
<font color="green">291</font>         * {@link #invokeExactMethod(Object object,String methodName,Object [] args)}.<a name="line.291"></a>
<font color="green">292</font>         * &lt;/p&gt;<a name="line.292"></a>
<font color="green">293</font>         *<a name="line.293"></a>
<font color="green">294</font>         * @param object invoke method on this object<a name="line.294"></a>
<font color="green">295</font>         * @param methodName get method with this name<a name="line.295"></a>
<font color="green">296</font>         * @param arg use this argument<a name="line.296"></a>
<font color="green">297</font>         * @return The value returned by the invoked method<a name="line.297"></a>
<font color="green">298</font>         *<a name="line.298"></a>
<font color="green">299</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.299"></a>
<font color="green">300</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.300"></a>
<font color="green">301</font>         *  method invoked<a name="line.301"></a>
<font color="green">302</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.302"></a>
<font color="green">303</font>         *  via reflection<a name="line.303"></a>
<font color="green">304</font>         */<a name="line.304"></a>
<font color="green">305</font>        public static Object invokeExactMethod(<a name="line.305"></a>
<font color="green">306</font>                Object object,<a name="line.306"></a>
<font color="green">307</font>                String methodName,<a name="line.307"></a>
<font color="green">308</font>                Object arg)<a name="line.308"></a>
<font color="green">309</font>                throws<a name="line.309"></a>
<font color="green">310</font>                NoSuchMethodException,<a name="line.310"></a>
<font color="green">311</font>                IllegalAccessException,<a name="line.311"></a>
<font color="green">312</font>                InvocationTargetException {<a name="line.312"></a>
<font color="green">313</font>    <a name="line.313"></a>
<font color="green">314</font>            Object[] args = {arg};<a name="line.314"></a>
<font color="green">315</font>            return invokeExactMethod(object, methodName, args);<a name="line.315"></a>
<font color="green">316</font>    <a name="line.316"></a>
<font color="green">317</font>        }<a name="line.317"></a>
<font color="green">318</font>    <a name="line.318"></a>
<font color="green">319</font>    <a name="line.319"></a>
<font color="green">320</font>        /**<a name="line.320"></a>
<font color="green">321</font>         * &lt;p&gt;Invoke a method whose parameter types match exactly the object<a name="line.321"></a>
<font color="green">322</font>         * types.&lt;/p&gt;<a name="line.322"></a>
<font color="green">323</font>         *<a name="line.323"></a>
<font color="green">324</font>         * &lt;p&gt; This uses reflection to invoke the method obtained from a call to<a name="line.324"></a>
<font color="green">325</font>         * &lt;code&gt;getAccessibleMethod()&lt;/code&gt;.&lt;/p&gt;<a name="line.325"></a>
<font color="green">326</font>         *<a name="line.326"></a>
<font color="green">327</font>         * @param object invoke method on this object<a name="line.327"></a>
<font color="green">328</font>         * @param methodName get method with this name<a name="line.328"></a>
<font color="green">329</font>         * @param args use these arguments - treat null as empty array<a name="line.329"></a>
<font color="green">330</font>         * @return The value returned by the invoked method<a name="line.330"></a>
<font color="green">331</font>         *<a name="line.331"></a>
<font color="green">332</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.332"></a>
<font color="green">333</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.333"></a>
<font color="green">334</font>         *  method invoked<a name="line.334"></a>
<font color="green">335</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.335"></a>
<font color="green">336</font>         *  via reflection<a name="line.336"></a>
<font color="green">337</font>         */<a name="line.337"></a>
<font color="green">338</font>        public static Object invokeExactMethod(<a name="line.338"></a>
<font color="green">339</font>                Object object,<a name="line.339"></a>
<font color="green">340</font>                String methodName,<a name="line.340"></a>
<font color="green">341</font>                Object[] args)<a name="line.341"></a>
<font color="green">342</font>                throws<a name="line.342"></a>
<font color="green">343</font>                NoSuchMethodException,<a name="line.343"></a>
<font color="green">344</font>                IllegalAccessException,<a name="line.344"></a>
<font color="green">345</font>                InvocationTargetException {<a name="line.345"></a>
<font color="green">346</font>            if (args == null) {<a name="line.346"></a>
<font color="green">347</font>                args = EMPTY_OBJECT_ARRAY;<a name="line.347"></a>
<font color="green">348</font>            }  <a name="line.348"></a>
<font color="green">349</font>            int arguments = args.length;<a name="line.349"></a>
<font color="green">350</font>            Class[] parameterTypes = new Class[arguments];<a name="line.350"></a>
<font color="green">351</font>            for (int i = 0; i &lt; arguments; i++) {<a name="line.351"></a>
<font color="green">352</font>                parameterTypes[i] = args[i].getClass();<a name="line.352"></a>
<font color="green">353</font>            }<a name="line.353"></a>
<font color="green">354</font>            return invokeExactMethod(object, methodName, args, parameterTypes);<a name="line.354"></a>
<font color="green">355</font>    <a name="line.355"></a>
<font color="green">356</font>        }<a name="line.356"></a>
<font color="green">357</font>    <a name="line.357"></a>
<font color="green">358</font>    <a name="line.358"></a>
<font color="green">359</font>        /**<a name="line.359"></a>
<font color="green">360</font>         * &lt;p&gt;Invoke a method whose parameter types match exactly the parameter<a name="line.360"></a>
<font color="green">361</font>         * types given.&lt;/p&gt;<a name="line.361"></a>
<font color="green">362</font>         *<a name="line.362"></a>
<font color="green">363</font>         * &lt;p&gt;This uses reflection to invoke the method obtained from a call to<a name="line.363"></a>
<font color="green">364</font>         * &lt;code&gt;getAccessibleMethod()&lt;/code&gt;.&lt;/p&gt;<a name="line.364"></a>
<font color="green">365</font>         *<a name="line.365"></a>
<font color="green">366</font>         * @param object invoke method on this object<a name="line.366"></a>
<font color="green">367</font>         * @param methodName get method with this name<a name="line.367"></a>
<font color="green">368</font>         * @param args use these arguments - treat null as empty array<a name="line.368"></a>
<font color="green">369</font>         * @param parameterTypes match these parameters - treat null as empty array<a name="line.369"></a>
<font color="green">370</font>         * @return The value returned by the invoked method<a name="line.370"></a>
<font color="green">371</font>         *<a name="line.371"></a>
<font color="green">372</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.372"></a>
<font color="green">373</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.373"></a>
<font color="green">374</font>         *  method invoked<a name="line.374"></a>
<font color="green">375</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.375"></a>
<font color="green">376</font>         *  via reflection<a name="line.376"></a>
<font color="green">377</font>         */<a name="line.377"></a>
<font color="green">378</font>        public static Object invokeExactMethod(<a name="line.378"></a>
<font color="green">379</font>                Object object,<a name="line.379"></a>
<font color="green">380</font>                String methodName,<a name="line.380"></a>
<font color="green">381</font>                Object[] args,<a name="line.381"></a>
<font color="green">382</font>                Class[] parameterTypes)<a name="line.382"></a>
<font color="green">383</font>                throws<a name="line.383"></a>
<font color="green">384</font>                NoSuchMethodException,<a name="line.384"></a>
<font color="green">385</font>                IllegalAccessException,<a name="line.385"></a>
<font color="green">386</font>                InvocationTargetException {<a name="line.386"></a>
<font color="green">387</font>            <a name="line.387"></a>
<font color="green">388</font>            if (args == null) {<a name="line.388"></a>
<font color="green">389</font>                args = EMPTY_OBJECT_ARRAY;<a name="line.389"></a>
<font color="green">390</font>            }  <a name="line.390"></a>
<font color="green">391</font>                    <a name="line.391"></a>
<font color="green">392</font>            if (parameterTypes == null) {<a name="line.392"></a>
<font color="green">393</font>                parameterTypes = EMPTY_CLASS_PARAMETERS;<a name="line.393"></a>
<font color="green">394</font>            }<a name="line.394"></a>
<font color="green">395</font>    <a name="line.395"></a>
<font color="green">396</font>            Method method = getAccessibleMethod(<a name="line.396"></a>
<font color="green">397</font>                    object.getClass(),<a name="line.397"></a>
<font color="green">398</font>                    methodName,<a name="line.398"></a>
<font color="green">399</font>                    parameterTypes);<a name="line.399"></a>
<font color="green">400</font>            if (method == null) {<a name="line.400"></a>
<font color="green">401</font>                throw new NoSuchMethodException("No such accessible method: " +<a name="line.401"></a>
<font color="green">402</font>                        methodName + "() on object: " + object.getClass().getName());<a name="line.402"></a>
<font color="green">403</font>            }<a name="line.403"></a>
<font color="green">404</font>            return method.invoke(object, args);<a name="line.404"></a>
<font color="green">405</font>    <a name="line.405"></a>
<font color="green">406</font>        }<a name="line.406"></a>
<font color="green">407</font>    <a name="line.407"></a>
<font color="green">408</font>        /**<a name="line.408"></a>
<font color="green">409</font>         * &lt;p&gt;Invoke a static method whose parameter types match exactly the parameter<a name="line.409"></a>
<font color="green">410</font>         * types given.&lt;/p&gt;<a name="line.410"></a>
<font color="green">411</font>         *<a name="line.411"></a>
<font color="green">412</font>         * &lt;p&gt;This uses reflection to invoke the method obtained from a call to<a name="line.412"></a>
<font color="green">413</font>         * {@link #getAccessibleMethod(Class, String, Class[])}.&lt;/p&gt;<a name="line.413"></a>
<font color="green">414</font>         *<a name="line.414"></a>
<font color="green">415</font>         * @param objectClass invoke static method on this class<a name="line.415"></a>
<font color="green">416</font>         * @param methodName get method with this name<a name="line.416"></a>
<font color="green">417</font>         * @param args use these arguments - treat null as empty array<a name="line.417"></a>
<font color="green">418</font>         * @param parameterTypes match these parameters - treat null as empty array<a name="line.418"></a>
<font color="green">419</font>         * @return The value returned by the invoked method<a name="line.419"></a>
<font color="green">420</font>         *<a name="line.420"></a>
<font color="green">421</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.421"></a>
<font color="green">422</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.422"></a>
<font color="green">423</font>         *  method invoked<a name="line.423"></a>
<font color="green">424</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.424"></a>
<font color="green">425</font>         *  via reflection<a name="line.425"></a>
<font color="green">426</font>         * @since 1.8.0<a name="line.426"></a>
<font color="green">427</font>         */<a name="line.427"></a>
<font color="green">428</font>        public static Object invokeExactStaticMethod(<a name="line.428"></a>
<font color="green">429</font>                Class objectClass,<a name="line.429"></a>
<font color="green">430</font>                String methodName,<a name="line.430"></a>
<font color="green">431</font>                Object[] args,<a name="line.431"></a>
<font color="green">432</font>                Class[] parameterTypes)<a name="line.432"></a>
<font color="green">433</font>                throws<a name="line.433"></a>
<font color="green">434</font>                NoSuchMethodException,<a name="line.434"></a>
<font color="green">435</font>                IllegalAccessException,<a name="line.435"></a>
<font color="green">436</font>                InvocationTargetException {<a name="line.436"></a>
<font color="green">437</font>            <a name="line.437"></a>
<font color="green">438</font>            if (args == null) {<a name="line.438"></a>
<font color="green">439</font>                args = EMPTY_OBJECT_ARRAY;<a name="line.439"></a>
<font color="green">440</font>            }  <a name="line.440"></a>
<font color="green">441</font>                    <a name="line.441"></a>
<font color="green">442</font>            if (parameterTypes == null) {<a name="line.442"></a>
<font color="green">443</font>                parameterTypes = EMPTY_CLASS_PARAMETERS;<a name="line.443"></a>
<font color="green">444</font>            }<a name="line.444"></a>
<font color="green">445</font>    <a name="line.445"></a>
<font color="green">446</font>            Method method = getAccessibleMethod(<a name="line.446"></a>
<font color="green">447</font>                    objectClass,<a name="line.447"></a>
<font color="green">448</font>                    methodName,<a name="line.448"></a>
<font color="green">449</font>                    parameterTypes);<a name="line.449"></a>
<font color="green">450</font>            if (method == null) {<a name="line.450"></a>
<font color="green">451</font>                throw new NoSuchMethodException("No such accessible method: " +<a name="line.451"></a>
<font color="green">452</font>                        methodName + "() on class: " + objectClass.getName());<a name="line.452"></a>
<font color="green">453</font>            }<a name="line.453"></a>
<font color="green">454</font>            return method.invoke(null, args);<a name="line.454"></a>
<font color="green">455</font>    <a name="line.455"></a>
<font color="green">456</font>        }<a name="line.456"></a>
<font color="green">457</font>    <a name="line.457"></a>
<font color="green">458</font>        /**<a name="line.458"></a>
<font color="green">459</font>         * &lt;p&gt;Invoke a named static method whose parameter type matches the object type.&lt;/p&gt;<a name="line.459"></a>
<font color="green">460</font>         *<a name="line.460"></a>
<font color="green">461</font>         * &lt;p&gt;The behaviour of this method is less deterministic <a name="line.461"></a>
<font color="green">462</font>         * than {@link #invokeExactMethod(Object, String, Object[], Class[])}. <a name="line.462"></a>
<font color="green">463</font>         * It loops through all methods with names that match<a name="line.463"></a>
<font color="green">464</font>         * and then executes the first it finds with compatable parameters.&lt;/p&gt;<a name="line.464"></a>
<font color="green">465</font>         *<a name="line.465"></a>
<font color="green">466</font>         * &lt;p&gt;This method supports calls to methods taking primitive parameters <a name="line.466"></a>
<font color="green">467</font>         * via passing in wrapping classes. So, for example, a &lt;code&gt;Boolean&lt;/code&gt; class<a name="line.467"></a>
<font color="green">468</font>         * would match a &lt;code&gt;boolean&lt;/code&gt; primitive.&lt;/p&gt;<a name="line.468"></a>
<font color="green">469</font>         *<a name="line.469"></a>
<font color="green">470</font>         * &lt;p&gt; This is a convenient wrapper for<a name="line.470"></a>
<font color="green">471</font>         * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args)}.<a name="line.471"></a>
<font color="green">472</font>         * &lt;/p&gt;<a name="line.472"></a>
<font color="green">473</font>         *<a name="line.473"></a>
<font color="green">474</font>         * @param objectClass invoke static method on this class<a name="line.474"></a>
<font color="green">475</font>         * @param methodName get method with this name<a name="line.475"></a>
<font color="green">476</font>         * @param arg use this argument<a name="line.476"></a>
<font color="green">477</font>         * @return The value returned by the invoked method<a name="line.477"></a>
<font color="green">478</font>         *<a name="line.478"></a>
<font color="green">479</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.479"></a>
<font color="green">480</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.480"></a>
<font color="green">481</font>         *  method invoked<a name="line.481"></a>
<font color="green">482</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.482"></a>
<font color="green">483</font>         *  via reflection<a name="line.483"></a>
<font color="green">484</font>         * @since 1.8.0<a name="line.484"></a>
<font color="green">485</font>         */<a name="line.485"></a>
<font color="green">486</font>        public static Object invokeStaticMethod(<a name="line.486"></a>
<font color="green">487</font>                Class objectClass,<a name="line.487"></a>
<font color="green">488</font>                String methodName,<a name="line.488"></a>
<font color="green">489</font>                Object arg)<a name="line.489"></a>
<font color="green">490</font>                throws<a name="line.490"></a>
<font color="green">491</font>                NoSuchMethodException,<a name="line.491"></a>
<font color="green">492</font>                IllegalAccessException,<a name="line.492"></a>
<font color="green">493</font>                InvocationTargetException {<a name="line.493"></a>
<font color="green">494</font>    <a name="line.494"></a>
<font color="green">495</font>            Object[] args = {arg};<a name="line.495"></a>
<font color="green">496</font>            return invokeStaticMethod (objectClass, methodName, args);<a name="line.496"></a>
<font color="green">497</font>    <a name="line.497"></a>
<font color="green">498</font>        }<a name="line.498"></a>
<font color="green">499</font>    <a name="line.499"></a>
<font color="green">500</font>    <a name="line.500"></a>
<font color="green">501</font>        /**<a name="line.501"></a>
<font color="green">502</font>         * &lt;p&gt;Invoke a named static method whose parameter type matches the object type.&lt;/p&gt;<a name="line.502"></a>
<font color="green">503</font>         *<a name="line.503"></a>
<font color="green">504</font>         * &lt;p&gt;The behaviour of this method is less deterministic <a name="line.504"></a>
<font color="green">505</font>         * than {@link #invokeExactMethod(Object object,String methodName,Object [] args)}. <a name="line.505"></a>
<font color="green">506</font>         * It loops through all methods with names that match<a name="line.506"></a>
<font color="green">507</font>         * and then executes the first it finds with compatable parameters.&lt;/p&gt;<a name="line.507"></a>
<font color="green">508</font>         *<a name="line.508"></a>
<font color="green">509</font>         * &lt;p&gt;This method supports calls to methods taking primitive parameters <a name="line.509"></a>
<font color="green">510</font>         * via passing in wrapping classes. So, for example, a &lt;code&gt;Boolean&lt;/code&gt; class<a name="line.510"></a>
<font color="green">511</font>         * would match a &lt;code&gt;boolean&lt;/code&gt; primitive.&lt;/p&gt;<a name="line.511"></a>
<font color="green">512</font>         *<a name="line.512"></a>
<font color="green">513</font>         * &lt;p&gt; This is a convenient wrapper for<a name="line.513"></a>
<font color="green">514</font>         * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args,Class[] parameterTypes)}.<a name="line.514"></a>
<font color="green">515</font>         * &lt;/p&gt;<a name="line.515"></a>
<font color="green">516</font>         *<a name="line.516"></a>
<font color="green">517</font>         * @param objectClass invoke static method on this class<a name="line.517"></a>
<font color="green">518</font>         * @param methodName get method with this name<a name="line.518"></a>
<font color="green">519</font>         * @param args use these arguments - treat null as empty array<a name="line.519"></a>
<font color="green">520</font>         * @return The value returned by the invoked method<a name="line.520"></a>
<font color="green">521</font>         *<a name="line.521"></a>
<font color="green">522</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.522"></a>
<font color="green">523</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.523"></a>
<font color="green">524</font>         *  method invoked<a name="line.524"></a>
<font color="green">525</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.525"></a>
<font color="green">526</font>         *  via reflection<a name="line.526"></a>
<font color="green">527</font>         * @since 1.8.0<a name="line.527"></a>
<font color="green">528</font>         */<a name="line.528"></a>
<font color="green">529</font>        public static Object invokeStaticMethod(<a name="line.529"></a>
<font color="green">530</font>                Class objectClass,<a name="line.530"></a>
<font color="green">531</font>                String methodName,<a name="line.531"></a>
<font color="green">532</font>                Object[] args)<a name="line.532"></a>
<font color="green">533</font>                throws<a name="line.533"></a>
<font color="green">534</font>                NoSuchMethodException,<a name="line.534"></a>
<font color="green">535</font>                IllegalAccessException,<a name="line.535"></a>
<font color="green">536</font>                InvocationTargetException {<a name="line.536"></a>
<font color="green">537</font>            <a name="line.537"></a>
<font color="green">538</font>            if (args == null) {<a name="line.538"></a>
<font color="green">539</font>                args = EMPTY_OBJECT_ARRAY;<a name="line.539"></a>
<font color="green">540</font>            }  <a name="line.540"></a>
<font color="green">541</font>            int arguments = args.length;<a name="line.541"></a>
<font color="green">542</font>            Class[] parameterTypes = new Class[arguments];<a name="line.542"></a>
<font color="green">543</font>            for (int i = 0; i &lt; arguments; i++) {<a name="line.543"></a>
<font color="green">544</font>                parameterTypes[i] = args[i].getClass();<a name="line.544"></a>
<font color="green">545</font>            }<a name="line.545"></a>
<font color="green">546</font>            return invokeStaticMethod (objectClass, methodName, args, parameterTypes);<a name="line.546"></a>
<font color="green">547</font>    <a name="line.547"></a>
<font color="green">548</font>        }<a name="line.548"></a>
<font color="green">549</font>    <a name="line.549"></a>
<font color="green">550</font>    <a name="line.550"></a>
<font color="green">551</font>        /**<a name="line.551"></a>
<font color="green">552</font>         * &lt;p&gt;Invoke a named static method whose parameter type matches the object type.&lt;/p&gt;<a name="line.552"></a>
<font color="green">553</font>         *<a name="line.553"></a>
<font color="green">554</font>         * &lt;p&gt;The behaviour of this method is less deterministic <a name="line.554"></a>
<font color="green">555</font>         * than {@link <a name="line.555"></a>
<font color="green">556</font>         * #invokeExactStaticMethod(Class objectClass,String methodName,Object [] args,Class[] parameterTypes)}. <a name="line.556"></a>
<font color="green">557</font>         * It loops through all methods with names that match<a name="line.557"></a>
<font color="green">558</font>         * and then executes the first it finds with compatable parameters.&lt;/p&gt;<a name="line.558"></a>
<font color="green">559</font>         *<a name="line.559"></a>
<font color="green">560</font>         * &lt;p&gt;This method supports calls to methods taking primitive parameters <a name="line.560"></a>
<font color="green">561</font>         * via passing in wrapping classes. So, for example, a &lt;code&gt;Boolean&lt;/code&gt; class<a name="line.561"></a>
<font color="green">562</font>         * would match a &lt;code&gt;boolean&lt;/code&gt; primitive.&lt;/p&gt;<a name="line.562"></a>
<font color="green">563</font>         *<a name="line.563"></a>
<font color="green">564</font>         *<a name="line.564"></a>
<font color="green">565</font>         * @param objectClass invoke static method on this class<a name="line.565"></a>
<font color="green">566</font>         * @param methodName get method with this name<a name="line.566"></a>
<font color="green">567</font>         * @param args use these arguments - treat null as empty array<a name="line.567"></a>
<font color="green">568</font>         * @param parameterTypes match these parameters - treat null as empty array<a name="line.568"></a>
<font color="green">569</font>         * @return The value returned by the invoked method<a name="line.569"></a>
<font color="green">570</font>         *<a name="line.570"></a>
<font color="green">571</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.571"></a>
<font color="green">572</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.572"></a>
<font color="green">573</font>         *  method invoked<a name="line.573"></a>
<font color="green">574</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.574"></a>
<font color="green">575</font>         *  via reflection<a name="line.575"></a>
<font color="green">576</font>         * @since 1.8.0<a name="line.576"></a>
<font color="green">577</font>         */<a name="line.577"></a>
<font color="green">578</font>        public static Object invokeStaticMethod(<a name="line.578"></a>
<font color="green">579</font>                Class objectClass,<a name="line.579"></a>
<font color="green">580</font>                String methodName,<a name="line.580"></a>
<font color="green">581</font>                Object[] args,<a name="line.581"></a>
<font color="green">582</font>                Class[] parameterTypes)<a name="line.582"></a>
<font color="green">583</font>                    throws<a name="line.583"></a>
<font color="green">584</font>                        NoSuchMethodException,<a name="line.584"></a>
<font color="green">585</font>                        IllegalAccessException,<a name="line.585"></a>
<font color="green">586</font>                        InvocationTargetException {<a name="line.586"></a>
<font color="green">587</font>                        <a name="line.587"></a>
<font color="green">588</font>            if (parameterTypes == null) {<a name="line.588"></a>
<font color="green">589</font>                parameterTypes = EMPTY_CLASS_PARAMETERS;<a name="line.589"></a>
<font color="green">590</font>            }        <a name="line.590"></a>
<font color="green">591</font>            if (args == null) {<a name="line.591"></a>
<font color="green">592</font>                args = EMPTY_OBJECT_ARRAY;<a name="line.592"></a>
<font color="green">593</font>            }  <a name="line.593"></a>
<font color="green">594</font>    <a name="line.594"></a>
<font color="green">595</font>            Method method = getMatchingAccessibleMethod(<a name="line.595"></a>
<font color="green">596</font>                    objectClass,<a name="line.596"></a>
<font color="green">597</font>                    methodName,<a name="line.597"></a>
<font color="green">598</font>                    parameterTypes);<a name="line.598"></a>
<font color="green">599</font>            if (method == null) {<a name="line.599"></a>
<font color="green">600</font>                throw new NoSuchMethodException("No such accessible method: " +<a name="line.600"></a>
<font color="green">601</font>                        methodName + "() on class: " + objectClass.getName());<a name="line.601"></a>
<font color="green">602</font>            }<a name="line.602"></a>
<font color="green">603</font>            return method.invoke(null, args);<a name="line.603"></a>
<font color="green">604</font>        }<a name="line.604"></a>
<font color="green">605</font>    <a name="line.605"></a>
<font color="green">606</font>    <a name="line.606"></a>
<font color="green">607</font>        /**<a name="line.607"></a>
<font color="green">608</font>         * &lt;p&gt;Invoke a static method whose parameter type matches exactly the object<a name="line.608"></a>
<font color="green">609</font>         * type.&lt;/p&gt;<a name="line.609"></a>
<font color="green">610</font>         *<a name="line.610"></a>
<font color="green">611</font>         * &lt;p&gt; This is a convenient wrapper for<a name="line.611"></a>
<font color="green">612</font>         * {@link #invokeExactStaticMethod(Class objectClass,String methodName,Object [] args)}.<a name="line.612"></a>
<font color="green">613</font>         * &lt;/p&gt;<a name="line.613"></a>
<font color="green">614</font>         *<a name="line.614"></a>
<font color="green">615</font>         * @param objectClass invoke static method on this class<a name="line.615"></a>
<font color="green">616</font>         * @param methodName get method with this name<a name="line.616"></a>
<font color="green">617</font>         * @param arg use this argument<a name="line.617"></a>
<font color="green">618</font>         * @return The value returned by the invoked method<a name="line.618"></a>
<font color="green">619</font>         *<a name="line.619"></a>
<font color="green">620</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.620"></a>
<font color="green">621</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.621"></a>
<font color="green">622</font>         *  method invoked<a name="line.622"></a>
<font color="green">623</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.623"></a>
<font color="green">624</font>         *  via reflection<a name="line.624"></a>
<font color="green">625</font>         * @since 1.8.0<a name="line.625"></a>
<font color="green">626</font>         */<a name="line.626"></a>
<font color="green">627</font>        public static Object invokeExactStaticMethod(<a name="line.627"></a>
<font color="green">628</font>                Class objectClass,<a name="line.628"></a>
<font color="green">629</font>                String methodName,<a name="line.629"></a>
<font color="green">630</font>                Object arg)<a name="line.630"></a>
<font color="green">631</font>                throws<a name="line.631"></a>
<font color="green">632</font>                NoSuchMethodException,<a name="line.632"></a>
<font color="green">633</font>                IllegalAccessException,<a name="line.633"></a>
<font color="green">634</font>                InvocationTargetException {<a name="line.634"></a>
<font color="green">635</font>    <a name="line.635"></a>
<font color="green">636</font>            Object[] args = {arg};<a name="line.636"></a>
<font color="green">637</font>            return invokeExactStaticMethod (objectClass, methodName, args);<a name="line.637"></a>
<font color="green">638</font>    <a name="line.638"></a>
<font color="green">639</font>        }<a name="line.639"></a>
<font color="green">640</font>    <a name="line.640"></a>
<font color="green">641</font>    <a name="line.641"></a>
<font color="green">642</font>        /**<a name="line.642"></a>
<font color="green">643</font>         * &lt;p&gt;Invoke a static method whose parameter types match exactly the object<a name="line.643"></a>
<font color="green">644</font>         * types.&lt;/p&gt;<a name="line.644"></a>
<font color="green">645</font>         *<a name="line.645"></a>
<font color="green">646</font>         * &lt;p&gt; This uses reflection to invoke the method obtained from a call to<a name="line.646"></a>
<font color="green">647</font>         * {@link #getAccessibleMethod(Class, String, Class[])}.&lt;/p&gt;<a name="line.647"></a>
<font color="green">648</font>         *<a name="line.648"></a>
<font color="green">649</font>         * @param objectClass invoke static method on this class<a name="line.649"></a>
<font color="green">650</font>         * @param methodName get method with this name<a name="line.650"></a>
<font color="green">651</font>         * @param args use these arguments - treat null as empty array<a name="line.651"></a>
<font color="green">652</font>         * @return The value returned by the invoked method<a name="line.652"></a>
<font color="green">653</font>         *<a name="line.653"></a>
<font color="green">654</font>         * @throws NoSuchMethodException if there is no such accessible method<a name="line.654"></a>
<font color="green">655</font>         * @throws InvocationTargetException wraps an exception thrown by the<a name="line.655"></a>
<font color="green">656</font>         *  method invoked<a name="line.656"></a>
<font color="green">657</font>         * @throws IllegalAccessException if the requested method is not accessible<a name="line.657"></a>
<font color="green">658</font>         *  via reflection<a name="line.658"></a>
<font color="green">659</font>         * @since 1.8.0<a name="line.659"></a>
<font color="green">660</font>         */<a name="line.660"></a>
<font color="green">661</font>        public static Object invokeExactStaticMethod(<a name="line.661"></a>
<font color="green">662</font>                Class objectClass,<a name="line.662"></a>
<font color="green">663</font>                String methodName,<a name="line.663"></a>
<font color="green">664</font>                Object[] args)<a name="line.664"></a>
<font color="green">665</font>                throws<a name="line.665"></a>
<font color="green">666</font>                NoSuchMethodException,<a name="line.666"></a>
<font color="green">667</font>                IllegalAccessException,<a name="line.667"></a>
<font color="green">668</font>                InvocationTargetException {<a name="line.668"></a>
<font color="green">669</font>            if (args == null) {<a name="line.669"></a>
<font color="green">670</font>                args = EMPTY_OBJECT_ARRAY;<a name="line.670"></a>
<font color="green">671</font>            }  <a name="line.671"></a>
<font color="green">672</font>            int arguments = args.length;<a name="line.672"></a>
<font color="green">673</font>            Class[] parameterTypes = new Class[arguments];<a name="line.673"></a>
<font color="green">674</font>            for (int i = 0; i &lt; arguments; i++) {<a name="line.674"></a>
<font color="green">675</font>                parameterTypes[i] = args[i].getClass();<a name="line.675"></a>
<font color="green">676</font>            }<a name="line.676"></a>
<font color="green">677</font>            return invokeExactStaticMethod(objectClass, methodName, args, parameterTypes);<a name="line.677"></a>
<font color="green">678</font>    <a name="line.678"></a>
<font color="green">679</font>        }<a name="line.679"></a>
<font color="green">680</font>    <a name="line.680"></a>
<font color="green">681</font>    <a name="line.681"></a>
<font color="green">682</font>        /**<a name="line.682"></a>
<font color="green">683</font>         * &lt;p&gt;Return an accessible method (that is, one that can be invoked via<a name="line.683"></a>
<font color="green">684</font>         * reflection) with given name and a single parameter.  If no such method<a name="line.684"></a>
<font color="green">685</font>         * can be found, return &lt;code&gt;null&lt;/code&gt;.<a name="line.685"></a>
<font color="green">686</font>         * Basically, a convenience wrapper that constructs a &lt;code&gt;Class&lt;/code&gt;<a name="line.686"></a>
<font color="green">687</font>         * array for you.&lt;/p&gt;<a name="line.687"></a>
<font color="green">688</font>         *<a name="line.688"></a>
<font color="green">689</font>         * @param clazz get method from this class<a name="line.689"></a>
<font color="green">690</font>         * @param methodName get method with this name<a name="line.690"></a>
<font color="green">691</font>         * @param parameterType taking this type of parameter<a name="line.691"></a>
<font color="green">692</font>         * @return The accessible method<a name="line.692"></a>
<font color="green">693</font>         */<a name="line.693"></a>
<font color="green">694</font>        public static Method getAccessibleMethod(<a name="line.694"></a>
<font color="green">695</font>                Class clazz,<a name="line.695"></a>
<font color="green">696</font>                String methodName,<a name="line.696"></a>
<font color="green">697</font>                Class parameterType) {<a name="line.697"></a>
<font color="green">698</font>    <a name="line.698"></a>
<font color="green">699</font>            Class[] parameterTypes = {parameterType};<a name="line.699"></a>
<font color="green">700</font>            return getAccessibleMethod(clazz, methodName, parameterTypes);<a name="line.700"></a>
<font color="green">701</font>    <a name="line.701"></a>
<font color="green">702</font>        }<a name="line.702"></a>
<font color="green">703</font>    <a name="line.703"></a>
<font color="green">704</font>    <a name="line.704"></a>
<font color="green">705</font>        /**<a name="line.705"></a>
<font color="green">706</font>         * &lt;p&gt;Return an accessible method (that is, one that can be invoked via<a name="line.706"></a>
<font color="green">707</font>         * reflection) with given name and parameters.  If no such method<a name="line.707"></a>
<font color="green">708</font>         * can be found, return &lt;code&gt;null&lt;/code&gt;.<a name="line.708"></a>
<font color="green">709</font>         * This is just a convenient wrapper for<a name="line.709"></a>
<font color="green">710</font>         * {@link #getAccessibleMethod(Method method)}.&lt;/p&gt;<a name="line.710"></a>
<font color="green">711</font>         *<a name="line.711"></a>
<font color="green">712</font>         * @param clazz get method from this class<a name="line.712"></a>
<font color="green">713</font>         * @param methodName get method with this name<a name="line.713"></a>
<font color="green">714</font>         * @param parameterTypes with these parameters types<a name="line.714"></a>
<font color="green">715</font>         * @return The accessible method<a name="line.715"></a>
<font color="green">716</font>         */<a name="line.716"></a>
<font color="green">717</font>        public static Method getAccessibleMethod(<a name="line.717"></a>
<font color="green">718</font>                Class clazz,<a name="line.718"></a>
<font color="green">719</font>                String methodName,<a name="line.719"></a>
<font color="green">720</font>                Class[] parameterTypes) {<a name="line.720"></a>
<font color="green">721</font>    <a name="line.721"></a>
<font color="green">722</font>            try {<a name="line.722"></a>
<font color="green">723</font>                MethodDescriptor md = new MethodDescriptor(clazz, methodName, parameterTypes, true);<a name="line.723"></a>
<font color="green">724</font>                // Check the cache first<a name="line.724"></a>
<font color="green">725</font>                Method method = getCachedMethod(md);<a name="line.725"></a>
<font color="green">726</font>                if (method != null) {<a name="line.726"></a>
<font color="green">727</font>                    return method;<a name="line.727"></a>
<font color="green">728</font>                }<a name="line.728"></a>
<font color="green">729</font>                <a name="line.729"></a>
<font color="green">730</font>                method =  getAccessibleMethod<a name="line.730"></a>
<font color="green">731</font>                        (clazz, clazz.getMethod(methodName, parameterTypes));<a name="line.731"></a>
<font color="green">732</font>                cacheMethod(md, method);<a name="line.732"></a>
<font color="green">733</font>                return method;<a name="line.733"></a>
<font color="green">734</font>            } catch (NoSuchMethodException e) {<a name="line.734"></a>
<font color="green">735</font>                return (null);<a name="line.735"></a>
<font color="green">736</font>            }<a name="line.736"></a>
<font color="green">737</font>    <a name="line.737"></a>
<font color="green">738</font>        }<a name="line.738"></a>
<font color="green">739</font>    <a name="line.739"></a>
<font color="green">740</font>    <a name="line.740"></a>
<font color="green">741</font>        /**<a name="line.741"></a>
<font color="green">742</font>         * &lt;p&gt;Return an accessible method (that is, one that can be invoked via<a name="line.742"></a>
<font color="green">743</font>         * reflection) that implements the specified Method.  If no such method<a name="line.743"></a>
<font color="green">744</font>         * can be found, return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.744"></a>
<font color="green">745</font>         *<a name="line.745"></a>
<font color="green">746</font>         * @param method The method that we wish to call<a name="line.746"></a>
<font color="green">747</font>         * @return The accessible method<a name="line.747"></a>
<font color="green">748</font>         */<a name="line.748"></a>
<font color="green">749</font>        public static Method getAccessibleMethod(Method method) {<a name="line.749"></a>
<font color="green">750</font>    <a name="line.750"></a>
<font color="green">751</font>            // Make sure we have a method to check<a name="line.751"></a>
<font color="green">752</font>            if (method == null) {<a name="line.752"></a>
<font color="green">753</font>                return (null);<a name="line.753"></a>
<font color="green">754</font>            }<a name="line.754"></a>
<font color="green">755</font>    <a name="line.755"></a>
<font color="green">756</font>            return getAccessibleMethod(method.getDeclaringClass(), method);<a name="line.756"></a>
<font color="green">757</font>    <a name="line.757"></a>
<font color="green">758</font>        }<a name="line.758"></a>
<font color="green">759</font>    <a name="line.759"></a>
<font color="green">760</font>    <a name="line.760"></a>
<font color="green">761</font>    <a name="line.761"></a>
<font color="green">762</font>        /**<a name="line.762"></a>
<font color="green">763</font>         * &lt;p&gt;Return an accessible method (that is, one that can be invoked via<a name="line.763"></a>
<font color="green">764</font>         * reflection) that implements the specified Method.  If no such method<a name="line.764"></a>
<font color="green">765</font>         * can be found, return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.765"></a>
<font color="green">766</font>         *<a name="line.766"></a>
<font color="green">767</font>         * @param clazz The class of the object<a name="line.767"></a>
<font color="green">768</font>         * @param method The method that we wish to call<a name="line.768"></a>
<font color="green">769</font>         * @return The accessible method<a name="line.769"></a>
<font color="green">770</font>         * @since 1.8.0<a name="line.770"></a>
<font color="green">771</font>         */<a name="line.771"></a>
<font color="green">772</font>        public static Method getAccessibleMethod(Class clazz, Method method) {<a name="line.772"></a>
<font color="green">773</font>    <a name="line.773"></a>
<font color="green">774</font>            // Make sure we have a method to check<a name="line.774"></a>
<font color="green">775</font>            if (method == null) {<a name="line.775"></a>
<font color="green">776</font>                return (null);<a name="line.776"></a>
<font color="green">777</font>            }<a name="line.777"></a>
<font color="green">778</font>    <a name="line.778"></a>
<font color="green">779</font>            // If the requested method is not public we cannot call it<a name="line.779"></a>
<font color="green">780</font>            if (!Modifier.isPublic(method.getModifiers())) {<a name="line.780"></a>
<font color="green">781</font>                return (null);<a name="line.781"></a>
<font color="green">782</font>            }<a name="line.782"></a>
<font color="green">783</font>    <a name="line.783"></a>
<font color="green">784</font>            boolean sameClass = true;<a name="line.784"></a>
<font color="green">785</font>            if (clazz == null) {<a name="line.785"></a>
<font color="green">786</font>                clazz = method.getDeclaringClass();<a name="line.786"></a>
<font color="green">787</font>            } else {<a name="line.787"></a>
<font color="green">788</font>                sameClass = clazz.equals(method.getDeclaringClass());<a name="line.788"></a>
<font color="green">789</font>                if (!method.getDeclaringClass().isAssignableFrom(clazz)) {<a name="line.789"></a>
<font color="green">790</font>                    throw new IllegalArgumentException(clazz.getName() +<a name="line.790"></a>
<font color="green">791</font>                            " is not assignable from " + method.getDeclaringClass().getName());<a name="line.791"></a>
<font color="green">792</font>                }<a name="line.792"></a>
<font color="green">793</font>            }<a name="line.793"></a>
<font color="green">794</font>    <a name="line.794"></a>
<font color="green">795</font>            // If the class is public, we are done<a name="line.795"></a>
<font color="green">796</font>            if (Modifier.isPublic(clazz.getModifiers())) {<a name="line.796"></a>
<font color="green">797</font>                if (!sameClass &amp;&amp; !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {<a name="line.797"></a>
<font color="green">798</font>                    setMethodAccessible(method); // Default access superclass workaround<a name="line.798"></a>
<font color="green">799</font>                }<a name="line.799"></a>
<font color="green">800</font>                return (method);<a name="line.800"></a>
<font color="green">801</font>            }<a name="line.801"></a>
<font color="green">802</font>    <a name="line.802"></a>
<font color="green">803</font>            String methodName      = method.getName();<a name="line.803"></a>
<font color="green">804</font>            Class[] parameterTypes = method.getParameterTypes();<a name="line.804"></a>
<font color="green">805</font>    <a name="line.805"></a>
<font color="green">806</font>            // Check the implemented interfaces and subinterfaces<a name="line.806"></a>
<font color="green">807</font>            method =<a name="line.807"></a>
<font color="green">808</font>                    getAccessibleMethodFromInterfaceNest(clazz,<a name="line.808"></a>
<font color="green">809</font>                            methodName,<a name="line.809"></a>
<font color="green">810</font>                            parameterTypes);<a name="line.810"></a>
<font color="green">811</font>    <a name="line.811"></a>
<font color="green">812</font>            // Check the superclass chain<a name="line.812"></a>
<font color="green">813</font>            if (method == null) {<a name="line.813"></a>
<font color="green">814</font>                method = getAccessibleMethodFromSuperclass(clazz,<a name="line.814"></a>
<font color="green">815</font>                            methodName,<a name="line.815"></a>
<font color="green">816</font>                            parameterTypes);<a name="line.816"></a>
<font color="green">817</font>            }<a name="line.817"></a>
<font color="green">818</font>    <a name="line.818"></a>
<font color="green">819</font>            return (method);<a name="line.819"></a>
<font color="green">820</font>    <a name="line.820"></a>
<font color="green">821</font>        }<a name="line.821"></a>
<font color="green">822</font>    <a name="line.822"></a>
<font color="green">823</font>    <a name="line.823"></a>
<font color="green">824</font>        // -------------------------------------------------------- Private Methods<a name="line.824"></a>
<font color="green">825</font>    <a name="line.825"></a>
<font color="green">826</font>        /**<a name="line.826"></a>
<font color="green">827</font>         * &lt;p&gt;Return an accessible method (that is, one that can be invoked via<a name="line.827"></a>
<font color="green">828</font>         * reflection) by scanning through the superclasses. If no such method<a name="line.828"></a>
<font color="green">829</font>         * can be found, return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.829"></a>
<font color="green">830</font>         *<a name="line.830"></a>
<font color="green">831</font>         * @param clazz Class to be checked<a name="line.831"></a>
<font color="green">832</font>         * @param methodName Method name of the method we wish to call<a name="line.832"></a>
<font color="green">833</font>         * @param parameterTypes The parameter type signatures<a name="line.833"></a>
<font color="green">834</font>         */<a name="line.834"></a>
<font color="green">835</font>        private static Method getAccessibleMethodFromSuperclass<a name="line.835"></a>
<font color="green">836</font>                (Class clazz, String methodName, Class[] parameterTypes) {<a name="line.836"></a>
<font color="green">837</font>    <a name="line.837"></a>
<font color="green">838</font>            Class parentClazz = clazz.getSuperclass();<a name="line.838"></a>
<font color="green">839</font>            while (parentClazz != null) {<a name="line.839"></a>
<font color="green">840</font>                if (Modifier.isPublic(parentClazz.getModifiers())) {<a name="line.840"></a>
<font color="green">841</font>                    try {<a name="line.841"></a>
<font color="green">842</font>                        return parentClazz.getMethod(methodName, parameterTypes);<a name="line.842"></a>
<font color="green">843</font>                    } catch (NoSuchMethodException e) {<a name="line.843"></a>
<font color="green">844</font>                        return null;<a name="line.844"></a>
<font color="green">845</font>                    }<a name="line.845"></a>
<font color="green">846</font>                }<a name="line.846"></a>
<font color="green">847</font>                parentClazz = parentClazz.getSuperclass();<a name="line.847"></a>
<font color="green">848</font>            }<a name="line.848"></a>
<font color="green">849</font>            return null;<a name="line.849"></a>
<font color="green">850</font>        }<a name="line.850"></a>
<font color="green">851</font>    <a name="line.851"></a>
<font color="green">852</font>        /**<a name="line.852"></a>
<font color="green">853</font>         * &lt;p&gt;Return an accessible method (that is, one that can be invoked via<a name="line.853"></a>
<font color="green">854</font>         * reflection) that implements the specified method, by scanning through<a name="line.854"></a>
<font color="green">855</font>         * all implemented interfaces and subinterfaces.  If no such method<a name="line.855"></a>
<font color="green">856</font>         * can be found, return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;<a name="line.856"></a>
<font color="green">857</font>         *<a name="line.857"></a>
<font color="green">858</font>         * &lt;p&gt; There isn't any good reason why this method must be private.<a name="line.858"></a>
<font color="green">859</font>         * It is because there doesn't seem any reason why other classes should<a name="line.859"></a>
<font color="green">860</font>         * call this rather than the higher level methods.&lt;/p&gt;<a name="line.860"></a>
<font color="green">861</font>         *<a name="line.861"></a>
<font color="green">862</font>         * @param clazz Parent class for the interfaces to be checked<a name="line.862"></a>
<font color="green">863</font>         * @param methodName Method name of the method we wish to call<a name="line.863"></a>
<font color="green">864</font>         * @param parameterTypes The parameter type signatures<a name="line.864"></a>
<font color="green">865</font>         */<a name="line.865"></a>
<font color="green">866</font>        private static Method getAccessibleMethodFromInterfaceNest<a name="line.866"></a>
<font color="green">867</font>                (Class clazz, String methodName, Class[] parameterTypes) {<a name="line.867"></a>
<font color="green">868</font>    <a name="line.868"></a>
<font color="green">869</font>            Method method = null;<a name="line.869"></a>
<font color="green">870</font>    <a name="line.870"></a>
<font color="green">871</font>            // Search up the superclass chain<a name="line.871"></a>
<font color="green">872</font>            for (; clazz != null; clazz = clazz.getSuperclass()) {<a name="line.872"></a>
<font color="green">873</font>    <a name="line.873"></a>
<font color="green">874</font>                // Check the implemented interfaces of the parent class<a name="line.874"></a>
<font color="green">875</font>                Class[] interfaces = clazz.getInterfaces();<a name="line.875"></a>
<font color="green">876</font>                for (int i = 0; i &lt; interfaces.length; i++) {<a name="line.876"></a>
<font color="green">877</font>    <a name="line.877"></a>
<font color="green">878</font>                    // Is this interface public?<a name="line.878"></a>
<font color="green">879</font>                    if (!Modifier.isPublic(interfaces[i].getModifiers())) {<a name="line.879"></a>
<font color="green">880</font>                        continue;<a name="line.880"></a>
<font color="green">881</font>                    }<a name="line.881"></a>
<font color="green">882</font>    <a name="line.882"></a>
<font color="green">883</font>                    // Does the method exist on this interface?<a name="line.883"></a>
<font color="green">884</font>                    try {<a name="line.884"></a>
<font color="green">885</font>                        method = interfaces[i].getDeclaredMethod(methodName,<a name="line.885"></a>
<font color="green">886</font>                                parameterTypes);<a name="line.886"></a>
<font color="green">887</font>                    } catch (NoSuchMethodException e) {<a name="line.887"></a>
<font color="green">888</font>                        /* Swallow, if no method is found after the loop then this<a name="line.888"></a>
<font color="green">889</font>                         * method returns null.<a name="line.889"></a>
<font color="green">890</font>                         */<a name="line.890"></a>
<font color="green">891</font>                    }<a name="line.891"></a>
<font color="green">892</font>                    if (method != null) {<a name="line.892"></a>
<font color="green">893</font>                        return method;<a name="line.893"></a>
<font color="green">894</font>                    }<a name="line.894"></a>
<font color="green">895</font>    <a name="line.895"></a>
<font color="green">896</font>                    // Recursively check our parent interfaces<a name="line.896"></a>
<font color="green">897</font>                    method =<a name="line.897"></a>
<font color="green">898</font>                            getAccessibleMethodFromInterfaceNest(interfaces[i],<a name="line.898"></a>
<font color="green">899</font>                                    methodName,<a name="line.899"></a>
<font color="green">900</font>                                    parameterTypes);<a name="line.900"></a>
<font color="green">901</font>                    if (method != null) {<a name="line.901"></a>
<font color="green">902</font>                        return method;<a name="line.902"></a>
<font color="green">903</font>                    }<a name="line.903"></a>
<font color="green">904</font>    <a name="line.904"></a>
<font color="green">905</font>                }<a name="line.905"></a>
<font color="green">906</font>    <a name="line.906"></a>
<font color="green">907</font>            }<a name="line.907"></a>
<font color="green">908</font>    <a name="line.908"></a>
<font color="green">909</font>            // We did not find anything<a name="line.909"></a>
<font color="green">910</font>            return (null);<a name="line.910"></a>
<font color="green">911</font>    <a name="line.911"></a>
<font color="green">912</font>        }<a name="line.912"></a>
<font color="green">913</font>    <a name="line.913"></a>
<font color="green">914</font>        /**<a name="line.914"></a>
<font color="green">915</font>         * &lt;p&gt;Find an accessible method that matches the given name and has compatible parameters.<a name="line.915"></a>
<font color="green">916</font>         * Compatible parameters mean that every method parameter is assignable from <a name="line.916"></a>
<font color="green">917</font>         * the given parameters.<a name="line.917"></a>
<font color="green">918</font>         * In other words, it finds a method with the given name <a name="line.918"></a>
<font color="green">919</font>         * that will take the parameters given.&lt;p&gt;<a name="line.919"></a>
<font color="green">920</font>         *<a name="line.920"></a>
<font color="green">921</font>         * &lt;p&gt;This method is slightly undeterminstic since it loops <a name="line.921"></a>
<font color="green">922</font>         * through methods names and return the first matching method.&lt;/p&gt;<a name="line.922"></a>
<font color="green">923</font>         * <a name="line.923"></a>
<font color="green">924</font>         * &lt;p&gt;This method is used by <a name="line.924"></a>
<font color="green">925</font>         * {@link <a name="line.925"></a>
<font color="green">926</font>         * #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}.<a name="line.926"></a>
<font color="green">927</font>         *<a name="line.927"></a>
<font color="green">928</font>         * &lt;p&gt;This method can match primitive parameter by passing in wrapper classes.<a name="line.928"></a>
<font color="green">929</font>         * For example, a &lt;code&gt;Boolean&lt;/code&gt; will match a primitive &lt;code&gt;boolean&lt;/code&gt;<a name="line.929"></a>
<font color="green">930</font>         * parameter.<a name="line.930"></a>
<font color="green">931</font>         *<a name="line.931"></a>
<font color="green">932</font>         * @param clazz find method in this class<a name="line.932"></a>
<font color="green">933</font>         * @param methodName find method with this name<a name="line.933"></a>
<font color="green">934</font>         * @param parameterTypes find method with compatible parameters <a name="line.934"></a>
<font color="green">935</font>         * @return The accessible method<a name="line.935"></a>
<font color="green">936</font>         */<a name="line.936"></a>
<font color="green">937</font>        public static Method getMatchingAccessibleMethod(<a name="line.937"></a>
<font color="green">938</font>                                                    Class clazz,<a name="line.938"></a>
<font color="green">939</font>                                                    String methodName,<a name="line.939"></a>
<font color="green">940</font>                                                    Class[] parameterTypes) {<a name="line.940"></a>
<font color="green">941</font>            // trace logging<a name="line.941"></a>
<font color="green">942</font>            Log log = LogFactory.getLog(MethodUtils.class);<a name="line.942"></a>
<font color="green">943</font>            if (log.isTraceEnabled()) {<a name="line.943"></a>
<font color="green">944</font>                log.trace("Matching name=" + methodName + " on " + clazz);<a name="line.944"></a>
<font color="green">945</font>            }<a name="line.945"></a>
<font color="green">946</font>            MethodDescriptor md = new MethodDescriptor(clazz, methodName, parameterTypes, false);<a name="line.946"></a>
<font color="green">947</font>            <a name="line.947"></a>
<font color="green">948</font>            // see if we can find the method directly<a name="line.948"></a>
<font color="green">949</font>            // most of the time this works and it's much faster<a name="line.949"></a>
<font color="green">950</font>            try {<a name="line.950"></a>
<font color="green">951</font>                // Check the cache first<a name="line.951"></a>
<font color="green">952</font>                Method method = getCachedMethod(md);<a name="line.952"></a>
<font color="green">953</font>                if (method != null) {<a name="line.953"></a>
<font color="green">954</font>                    return method;<a name="line.954"></a>
<font color="green">955</font>                }<a name="line.955"></a>
<font color="green">956</font>    <a name="line.956"></a>
<font color="green">957</font>                method = clazz.getMethod(methodName, parameterTypes);<a name="line.957"></a>
<font color="green">958</font>                if (log.isTraceEnabled()) {<a name="line.958"></a>
<font color="green">959</font>                    log.trace("Found straight match: " + method);<a name="line.959"></a>
<font color="green">960</font>                    log.trace("isPublic:" + Modifier.isPublic(method.getModifiers()));<a name="line.960"></a>
<font color="green">961</font>                }<a name="line.961"></a>
<font color="green">962</font>                <a name="line.962"></a>
<font color="green">963</font>                setMethodAccessible(method); // Default access superclass workaround<a name="line.963"></a>
<font color="green">964</font>    <a name="line.964"></a>
<font color="green">965</font>                cacheMethod(md, method);<a name="line.965"></a>
<font color="green">966</font>                return method;<a name="line.966"></a>
<font color="green">967</font>                <a name="line.967"></a>
<font color="green">968</font>            } catch (NoSuchMethodException e) { /* SWALLOW */ }<a name="line.968"></a>
<font color="green">969</font>            <a name="line.969"></a>
<font color="green">970</font>            // search through all methods <a name="line.970"></a>
<font color="green">971</font>            int paramSize = parameterTypes.length;<a name="line.971"></a>
<font color="green">972</font>            Method bestMatch = null;<a name="line.972"></a>
<font color="green">973</font>            Method[] methods = clazz.getMethods();<a name="line.973"></a>
<font color="green">974</font>            float bestMatchCost = Float.MAX_VALUE;<a name="line.974"></a>
<font color="green">975</font>            float myCost = Float.MAX_VALUE;<a name="line.975"></a>
<font color="green">976</font>            for (int i = 0, size = methods.length; i &lt; size ; i++) {<a name="line.976"></a>
<font color="green">977</font>                if (methods[i].getName().equals(methodName)) {<a name="line.977"></a>
<font color="green">978</font>                    // log some trace information<a name="line.978"></a>
<font color="green">979</font>                    if (log.isTraceEnabled()) {<a name="line.979"></a>
<font color="green">980</font>                        log.trace("Found matching name:");<a name="line.980"></a>
<font color="green">981</font>                        log.trace(methods[i]);<a name="line.981"></a>
<font color="green">982</font>                    }                <a name="line.982"></a>
<font color="green">983</font>                    <a name="line.983"></a>
<font color="green">984</font>                    // compare parameters<a name="line.984"></a>
<font color="green">985</font>                    Class[] methodsParams = methods[i].getParameterTypes();<a name="line.985"></a>
<font color="green">986</font>                    int methodParamSize = methodsParams.length;<a name="line.986"></a>
<font color="green">987</font>                    if (methodParamSize == paramSize) {          <a name="line.987"></a>
<font color="green">988</font>                        boolean match = true;<a name="line.988"></a>
<font color="green">989</font>                        for (int n = 0 ; n &lt; methodParamSize; n++) {<a name="line.989"></a>
<font color="green">990</font>                            if (log.isTraceEnabled()) {<a name="line.990"></a>
<font color="green">991</font>                                log.trace("Param=" + parameterTypes[n].getName());<a name="line.991"></a>
<font color="green">992</font>                                log.trace("Method=" + methodsParams[n].getName());<a name="line.992"></a>
<font color="green">993</font>                            }<a name="line.993"></a>
<font color="green">994</font>                            if (!isAssignmentCompatible(methodsParams[n], parameterTypes[n])) {<a name="line.994"></a>
<font color="green">995</font>                                if (log.isTraceEnabled()) {<a name="line.995"></a>
<font color="green">996</font>                                    log.trace(methodsParams[n] + " is not assignable from " <a name="line.996"></a>
<font color="green">997</font>                                                + parameterTypes[n]);<a name="line.997"></a>
<font color="green">998</font>                                }    <a name="line.998"></a>
<font color="green">999</font>                                match = false;<a name="line.999"></a>
<font color="green">1000</font>                                break;<a name="line.1000"></a>
<font color="green">1001</font>                            }<a name="line.1001"></a>
<font color="green">1002</font>                        }<a name="line.1002"></a>
<font color="green">1003</font>                        <a name="line.1003"></a>
<font color="green">1004</font>                        if (match) {<a name="line.1004"></a>
<font color="green">1005</font>                            // get accessible version of method<a name="line.1005"></a>
<font color="green">1006</font>                            Method method = getAccessibleMethod(clazz, methods[i]);<a name="line.1006"></a>
<font color="green">1007</font>                            if (method != null) {<a name="line.1007"></a>
<font color="green">1008</font>                                if (log.isTraceEnabled()) {<a name="line.1008"></a>
<font color="green">1009</font>                                    log.trace(method + " accessible version of " <a name="line.1009"></a>
<font color="green">1010</font>                                                + methods[i]);<a name="line.1010"></a>
<font color="green">1011</font>                                }<a name="line.1011"></a>
<font color="green">1012</font>                                setMethodAccessible(method); // Default access superclass workaround<a name="line.1012"></a>
<font color="green">1013</font>                                myCost = getTotalTransformationCost(parameterTypes,method.getParameterTypes());<a name="line.1013"></a>
<font color="green">1014</font>                                if ( myCost &lt; bestMatchCost ) {<a name="line.1014"></a>
<font color="green">1015</font>                                   bestMatch = method;<a name="line.1015"></a>
<font color="green">1016</font>                                   bestMatchCost = myCost;<a name="line.1016"></a>
<font color="green">1017</font>                                }<a name="line.1017"></a>
<font color="green">1018</font>                            }<a name="line.1018"></a>
<font color="green">1019</font>                            <a name="line.1019"></a>
<font color="green">1020</font>                            log.trace("Couldn't find accessible method.");<a name="line.1020"></a>
<font color="green">1021</font>                        }<a name="line.1021"></a>
<font color="green">1022</font>                    }<a name="line.1022"></a>
<font color="green">1023</font>                }<a name="line.1023"></a>
<font color="green">1024</font>            }<a name="line.1024"></a>
<font color="green">1025</font>            if ( bestMatch != null ){<a name="line.1025"></a>
<font color="green">1026</font>                     cacheMethod(md, bestMatch);<a name="line.1026"></a>
<font color="green">1027</font>            } else {<a name="line.1027"></a>
<font color="green">1028</font>            // didn't find a match<a name="line.1028"></a>
<font color="green">1029</font>                   log.trace("No match found.");<a name="line.1029"></a>
<font color="green">1030</font>            }<a name="line.1030"></a>
<font color="green">1031</font>            <a name="line.1031"></a>
<font color="green">1032</font>            return bestMatch;                                        <a name="line.1032"></a>
<font color="green">1033</font>        }<a name="line.1033"></a>
<font color="green">1034</font>    <a name="line.1034"></a>
<font color="green">1035</font>        /**<a name="line.1035"></a>
<font color="green">1036</font>         * Try to make the method accessible<a name="line.1036"></a>
<font color="green">1037</font>         * @param method The source arguments<a name="line.1037"></a>
<font color="green">1038</font>         */<a name="line.1038"></a>
<font color="green">1039</font>        private static void setMethodAccessible(Method method) {<a name="line.1039"></a>
<font color="green">1040</font>            try {<a name="line.1040"></a>
<font color="green">1041</font>                //<a name="line.1041"></a>
<font color="green">1042</font>                // XXX Default access superclass workaround<a name="line.1042"></a>
<font color="green">1043</font>                //<a name="line.1043"></a>
<font color="green">1044</font>                // When a public class has a default access superclass<a name="line.1044"></a>
<font color="green">1045</font>                // with public methods, these methods are accessible.<a name="line.1045"></a>
<font color="green">1046</font>                // Calling them from compiled code works fine.<a name="line.1046"></a>
<font color="green">1047</font>                //<a name="line.1047"></a>
<font color="green">1048</font>                // Unfortunately, using reflection to invoke these methods<a name="line.1048"></a>
<font color="green">1049</font>                // seems to (wrongly) to prevent access even when the method<a name="line.1049"></a>
<font color="green">1050</font>                // modifer is public.<a name="line.1050"></a>
<font color="green">1051</font>                //<a name="line.1051"></a>
<font color="green">1052</font>                // The following workaround solves the problem but will only<a name="line.1052"></a>
<font color="green">1053</font>                // work from sufficiently privilages code. <a name="line.1053"></a>
<font color="green">1054</font>                //<a name="line.1054"></a>
<font color="green">1055</font>                // Better workarounds would be greatfully accepted.<a name="line.1055"></a>
<font color="green">1056</font>                //<a name="line.1056"></a>
<font color="green">1057</font>                if (!method.isAccessible()) {<a name="line.1057"></a>
<font color="green">1058</font>                    method.setAccessible(true);<a name="line.1058"></a>
<font color="green">1059</font>                }<a name="line.1059"></a>
<font color="green">1060</font>                <a name="line.1060"></a>
<font color="green">1061</font>            } catch (SecurityException se) {<a name="line.1061"></a>
<font color="green">1062</font>                // log but continue just in case the method.invoke works anyway<a name="line.1062"></a>
<font color="green">1063</font>                Log log = LogFactory.getLog(MethodUtils.class);<a name="line.1063"></a>
<font color="green">1064</font>                if (!loggedAccessibleWarning) {<a name="line.1064"></a>
<font color="green">1065</font>                    boolean vulnerableJVM = false;<a name="line.1065"></a>
<font color="green">1066</font>                    try {<a name="line.1066"></a>
<font color="green">1067</font>                        String specVersion = System.getProperty("java.specification.version");<a name="line.1067"></a>
<font color="green">1068</font>                        if (specVersion.charAt(0) == '1' &amp;&amp; <a name="line.1068"></a>
<font color="green">1069</font>                                (specVersion.charAt(2) == '0' ||<a name="line.1069"></a>
<font color="green">1070</font>                                 specVersion.charAt(2) == '1' ||<a name="line.1070"></a>
<font color="green">1071</font>                                 specVersion.charAt(2) == '2' ||<a name="line.1071"></a>
<font color="green">1072</font>                                 specVersion.charAt(2) == '3')) {<a name="line.1072"></a>
<font color="green">1073</font>                                 <a name="line.1073"></a>
<font color="green">1074</font>                            vulnerableJVM = true;<a name="line.1074"></a>
<font color="green">1075</font>                        }<a name="line.1075"></a>
<font color="green">1076</font>                    } catch (SecurityException e) {<a name="line.1076"></a>
<font color="green">1077</font>                        // don't know - so display warning<a name="line.1077"></a>
<font color="green">1078</font>                        vulnerableJVM = true;<a name="line.1078"></a>
<font color="green">1079</font>                    }<a name="line.1079"></a>
<font color="green">1080</font>                    if (vulnerableJVM) {<a name="line.1080"></a>
<font color="green">1081</font>                        log.warn(<a name="line.1081"></a>
<font color="green">1082</font>                            "Current Security Manager restricts use of workarounds for reflection bugs "<a name="line.1082"></a>
<font color="green">1083</font>                            + " in pre-1.4 JVMs.");<a name="line.1083"></a>
<font color="green">1084</font>                    }<a name="line.1084"></a>
<font color="green">1085</font>                    loggedAccessibleWarning = true;<a name="line.1085"></a>
<font color="green">1086</font>                }<a name="line.1086"></a>
<font color="green">1087</font>                log.debug("Cannot setAccessible on method. Therefore cannot use jvm access bug workaround.", se);<a name="line.1087"></a>
<font color="green">1088</font>            }<a name="line.1088"></a>
<font color="green">1089</font>        }<a name="line.1089"></a>
<font color="green">1090</font>    <a name="line.1090"></a>
<font color="green">1091</font>        /**<a name="line.1091"></a>
<font color="green">1092</font>         * Returns the sum of the object transformation cost for each class in the source<a name="line.1092"></a>
<font color="green">1093</font>         * argument list.<a name="line.1093"></a>
<font color="green">1094</font>         * @param srcArgs The source arguments<a name="line.1094"></a>
<font color="green">1095</font>         * @param destArgs The destination arguments<a name="line.1095"></a>
<font color="green">1096</font>         * @return The total transformation cost<a name="line.1096"></a>
<font color="green">1097</font>         */<a name="line.1097"></a>
<font color="green">1098</font>        private static float getTotalTransformationCost(Class[] srcArgs, Class[] destArgs) {<a name="line.1098"></a>
<font color="green">1099</font>    <a name="line.1099"></a>
<font color="green">1100</font>            float totalCost = 0.0f;<a name="line.1100"></a>
<font color="green">1101</font>            for (int i = 0; i &lt; srcArgs.length; i++) {<a name="line.1101"></a>
<font color="green">1102</font>                Class srcClass, destClass;<a name="line.1102"></a>
<font color="green">1103</font>                srcClass = srcArgs[i];<a name="line.1103"></a>
<font color="green">1104</font>                destClass = destArgs[i];<a name="line.1104"></a>
<font color="green">1105</font>                totalCost += getObjectTransformationCost(srcClass, destClass);<a name="line.1105"></a>
<font color="green">1106</font>            }<a name="line.1106"></a>
<font color="green">1107</font>    <a name="line.1107"></a>
<font color="green">1108</font>            return totalCost;<a name="line.1108"></a>
<font color="green">1109</font>        }<a name="line.1109"></a>
<font color="green">1110</font>        <a name="line.1110"></a>
<font color="green">1111</font>        /**<a name="line.1111"></a>
<font color="green">1112</font>         * Gets the number of steps required needed to turn the source class into the <a name="line.1112"></a>
<font color="green">1113</font>         * destination class. This represents the number of steps in the object hierarchy <a name="line.1113"></a>
<font color="green">1114</font>         * graph.<a name="line.1114"></a>
<font color="green">1115</font>         * @param srcClass The source class<a name="line.1115"></a>
<font color="green">1116</font>         * @param destClass The destination class<a name="line.1116"></a>
<font color="green">1117</font>         * @return The cost of transforming an object<a name="line.1117"></a>
<font color="green">1118</font>         */<a name="line.1118"></a>
<font color="green">1119</font>        private static float getObjectTransformationCost(Class srcClass, Class destClass) {<a name="line.1119"></a>
<font color="green">1120</font>            float cost = 0.0f;<a name="line.1120"></a>
<font color="green">1121</font>            while (destClass != null &amp;&amp; !destClass.equals(srcClass)) {<a name="line.1121"></a>
<font color="green">1122</font>                if (destClass.isInterface() &amp;&amp; isAssignmentCompatible(destClass,srcClass)) {<a name="line.1122"></a>
<font color="green">1123</font>                    // slight penalty for interface match. <a name="line.1123"></a>
<font color="green">1124</font>                    // we still want an exact match to override an interface match, but  <a name="line.1124"></a>
<font color="green">1125</font>                    // an interface match should override anything where we have to get a <a name="line.1125"></a>
<font color="green">1126</font>                    // superclass.<a name="line.1126"></a>
<font color="green">1127</font>                    cost += 0.25f;<a name="line.1127"></a>
<font color="green">1128</font>                    break;<a name="line.1128"></a>
<font color="green">1129</font>                }<a name="line.1129"></a>
<font color="green">1130</font>                cost++;<a name="line.1130"></a>
<font color="green">1131</font>                destClass = destClass.getSuperclass();<a name="line.1131"></a>
<font color="green">1132</font>            }<a name="line.1132"></a>
<font color="green">1133</font>    <a name="line.1133"></a>
<font color="green">1134</font>            /*<a name="line.1134"></a>
<font color="green">1135</font>             * If the destination class is null, we've travelled all the way up to <a name="line.1135"></a>
<font color="green">1136</font>             * an Object match. We'll penalize this by adding 1.5 to the cost.<a name="line.1136"></a>
<font color="green">1137</font>             */<a name="line.1137"></a>
<font color="green">1138</font>            if (destClass == null) {<a name="line.1138"></a>
<font color="green">1139</font>                cost += 1.5f;<a name="line.1139"></a>
<font color="green">1140</font>            }<a name="line.1140"></a>
<font color="green">1141</font>    <a name="line.1141"></a>
<font color="green">1142</font>            return cost;<a name="line.1142"></a>
<font color="green">1143</font>        }<a name="line.1143"></a>
<font color="green">1144</font>        <a name="line.1144"></a>
<font color="green">1145</font>        <a name="line.1145"></a>
<font color="green">1146</font>        /**<a name="line.1146"></a>
<font color="green">1147</font>         * &lt;p&gt;Determine whether a type can be used as a parameter in a method invocation.<a name="line.1147"></a>
<font color="green">1148</font>         * This method handles primitive conversions correctly.&lt;/p&gt;<a name="line.1148"></a>
<font color="green">1149</font>         *<a name="line.1149"></a>
<font color="green">1150</font>         * &lt;p&gt;In order words, it will match a &lt;code&gt;Boolean&lt;/code&gt; to a &lt;code&gt;boolean&lt;/code&gt;,<a name="line.1150"></a>
<font color="green">1151</font>         * a &lt;code&gt;Long&lt;/code&gt; to a &lt;code&gt;long&lt;/code&gt;,<a name="line.1151"></a>
<font color="green">1152</font>         * a &lt;code&gt;Float&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;,<a name="line.1152"></a>
<font color="green">1153</font>         * a &lt;code&gt;Integer&lt;/code&gt; to a &lt;code&gt;int&lt;/code&gt;,<a name="line.1153"></a>
<font color="green">1154</font>         * and a &lt;code&gt;Double&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt;.<a name="line.1154"></a>
<font color="green">1155</font>         * Now logic widening matches are allowed.<a name="line.1155"></a>
<font color="green">1156</font>         * For example, a &lt;code&gt;Long&lt;/code&gt; will not match a &lt;code&gt;int&lt;/code&gt;.<a name="line.1156"></a>
<font color="green">1157</font>         *<a name="line.1157"></a>
<font color="green">1158</font>         * @param parameterType the type of parameter accepted by the method<a name="line.1158"></a>
<font color="green">1159</font>         * @param parameterization the type of parameter being tested <a name="line.1159"></a>
<font color="green">1160</font>         *<a name="line.1160"></a>
<font color="green">1161</font>         * @return true if the assignement is compatible.<a name="line.1161"></a>
<font color="green">1162</font>         */<a name="line.1162"></a>
<font color="green">1163</font>        public static final boolean isAssignmentCompatible(Class parameterType, Class parameterization) {<a name="line.1163"></a>
<font color="green">1164</font>            // try plain assignment<a name="line.1164"></a>
<font color="green">1165</font>            if (parameterType.isAssignableFrom(parameterization)) {<a name="line.1165"></a>
<font color="green">1166</font>                return true;<a name="line.1166"></a>
<font color="green">1167</font>            }<a name="line.1167"></a>
<font color="green">1168</font>            <a name="line.1168"></a>
<font color="green">1169</font>            if (parameterType.isPrimitive()) {<a name="line.1169"></a>
<font color="green">1170</font>                // this method does *not* do widening - you must specify exactly<a name="line.1170"></a>
<font color="green">1171</font>                // is this the right behaviour?<a name="line.1171"></a>
<font color="green">1172</font>                Class parameterWrapperClazz = getPrimitiveWrapper(parameterType);<a name="line.1172"></a>
<font color="green">1173</font>                if (parameterWrapperClazz != null) {<a name="line.1173"></a>
<font color="green">1174</font>                    return parameterWrapperClazz.equals(parameterization);<a name="line.1174"></a>
<font color="green">1175</font>                }<a name="line.1175"></a>
<font color="green">1176</font>            }<a name="line.1176"></a>
<font color="green">1177</font>            <a name="line.1177"></a>
<font color="green">1178</font>            return false;<a name="line.1178"></a>
<font color="green">1179</font>        }<a name="line.1179"></a>
<font color="green">1180</font>        <a name="line.1180"></a>
<font color="green">1181</font>        /**<a name="line.1181"></a>
<font color="green">1182</font>         * Gets the wrapper object class for the given primitive type class.<a name="line.1182"></a>
<font color="green">1183</font>         * For example, passing &lt;code&gt;boolean.class&lt;/code&gt; returns &lt;code&gt;Boolean.class&lt;/code&gt;<a name="line.1183"></a>
<font color="green">1184</font>         * @param primitiveType the primitive type class for which a match is to be found<a name="line.1184"></a>
<font color="green">1185</font>         * @return the wrapper type associated with the given primitive <a name="line.1185"></a>
<font color="green">1186</font>         * or null if no match is found<a name="line.1186"></a>
<font color="green">1187</font>         */<a name="line.1187"></a>
<font color="green">1188</font>        public static Class getPrimitiveWrapper(Class primitiveType) {<a name="line.1188"></a>
<font color="green">1189</font>            // does anyone know a better strategy than comparing names?<a name="line.1189"></a>
<font color="green">1190</font>            if (boolean.class.equals(primitiveType)) {<a name="line.1190"></a>
<font color="green">1191</font>                return Boolean.class;<a name="line.1191"></a>
<font color="green">1192</font>            } else if (float.class.equals(primitiveType)) {<a name="line.1192"></a>
<font color="green">1193</font>                return Float.class;<a name="line.1193"></a>
<font color="green">1194</font>            } else if (long.class.equals(primitiveType)) {<a name="line.1194"></a>
<font color="green">1195</font>                return Long.class;<a name="line.1195"></a>
<font color="green">1196</font>            } else if (int.class.equals(primitiveType)) {<a name="line.1196"></a>
<font color="green">1197</font>                return Integer.class;<a name="line.1197"></a>
<font color="green">1198</font>            } else if (short.class.equals(primitiveType)) {<a name="line.1198"></a>
<font color="green">1199</font>                return Short.class;<a name="line.1199"></a>
<font color="green">1200</font>            } else if (byte.class.equals(primitiveType)) {<a name="line.1200"></a>
<font color="green">1201</font>                return Byte.class;<a name="line.1201"></a>
<font color="green">1202</font>            } else if (double.class.equals(primitiveType)) {<a name="line.1202"></a>
<font color="green">1203</font>                return Double.class;<a name="line.1203"></a>
<font color="green">1204</font>            } else if (char.class.equals(primitiveType)) {<a name="line.1204"></a>
<font color="green">1205</font>                return Character.class;<a name="line.1205"></a>
<font color="green">1206</font>            } else {<a name="line.1206"></a>
<font color="green">1207</font>                <a name="line.1207"></a>
<font color="green">1208</font>                return null;<a name="line.1208"></a>
<font color="green">1209</font>            }<a name="line.1209"></a>
<font color="green">1210</font>        }<a name="line.1210"></a>
<font color="green">1211</font>    <a name="line.1211"></a>
<font color="green">1212</font>        /**<a name="line.1212"></a>
<font color="green">1213</font>         * Gets the class for the primitive type corresponding to the primitive wrapper class given.<a name="line.1213"></a>
<font color="green">1214</font>         * For example, an instance of &lt;code&gt;Boolean.class&lt;/code&gt; returns a &lt;code&gt;boolean.class&lt;/code&gt;. <a name="line.1214"></a>
<font color="green">1215</font>         * @param wrapperType the <a name="line.1215"></a>
<font color="green">1216</font>         * @return the primitive type class corresponding to the given wrapper class,<a name="line.1216"></a>
<font color="green">1217</font>         * null if no match is found<a name="line.1217"></a>
<font color="green">1218</font>         */<a name="line.1218"></a>
<font color="green">1219</font>        public static Class getPrimitiveType(Class wrapperType) {<a name="line.1219"></a>
<font color="green">1220</font>            // does anyone know a better strategy than comparing names?<a name="line.1220"></a>
<font color="green">1221</font>            if (Boolean.class.equals(wrapperType)) {<a name="line.1221"></a>
<font color="green">1222</font>                return boolean.class;<a name="line.1222"></a>
<font color="green">1223</font>            } else if (Float.class.equals(wrapperType)) {<a name="line.1223"></a>
<font color="green">1224</font>                return float.class;<a name="line.1224"></a>
<font color="green">1225</font>            } else if (Long.class.equals(wrapperType)) {<a name="line.1225"></a>
<font color="green">1226</font>                return long.class;<a name="line.1226"></a>
<font color="green">1227</font>            } else if (Integer.class.equals(wrapperType)) {<a name="line.1227"></a>
<font color="green">1228</font>                return int.class;<a name="line.1228"></a>
<font color="green">1229</font>            } else if (Short.class.equals(wrapperType)) {<a name="line.1229"></a>
<font color="green">1230</font>                return short.class;<a name="line.1230"></a>
<font color="green">1231</font>            } else if (Byte.class.equals(wrapperType)) {<a name="line.1231"></a>
<font color="green">1232</font>                return byte.class;<a name="line.1232"></a>
<font color="green">1233</font>            } else if (Double.class.equals(wrapperType)) {<a name="line.1233"></a>
<font color="green">1234</font>                return double.class;<a name="line.1234"></a>
<font color="green">1235</font>            } else if (Character.class.equals(wrapperType)) {<a name="line.1235"></a>
<font color="green">1236</font>                return char.class;<a name="line.1236"></a>
<font color="green">1237</font>            } else {<a name="line.1237"></a>
<font color="green">1238</font>                Log log = LogFactory.getLog(MethodUtils.class);<a name="line.1238"></a>
<font color="green">1239</font>                if (log.isDebugEnabled()) {<a name="line.1239"></a>
<font color="green">1240</font>                    log.debug("Not a known primitive wrapper class: " + wrapperType);<a name="line.1240"></a>
<font color="green">1241</font>                }<a name="line.1241"></a>
<font color="green">1242</font>                return null;<a name="line.1242"></a>
<font color="green">1243</font>            }<a name="line.1243"></a>
<font color="green">1244</font>        }<a name="line.1244"></a>
<font color="green">1245</font>        <a name="line.1245"></a>
<font color="green">1246</font>        /**<a name="line.1246"></a>
<font color="green">1247</font>         * Find a non primitive representation for given primitive class.<a name="line.1247"></a>
<font color="green">1248</font>         *<a name="line.1248"></a>
<font color="green">1249</font>         * @param clazz the class to find a representation for, not null<a name="line.1249"></a>
<font color="green">1250</font>         * @return the original class if it not a primitive. Otherwise the wrapper class. Not null<a name="line.1250"></a>
<font color="green">1251</font>         */<a name="line.1251"></a>
<font color="green">1252</font>        public static Class toNonPrimitiveClass(Class clazz) {<a name="line.1252"></a>
<font color="green">1253</font>            if (clazz.isPrimitive()) {<a name="line.1253"></a>
<font color="green">1254</font>                Class primitiveClazz = MethodUtils.getPrimitiveWrapper(clazz);<a name="line.1254"></a>
<font color="green">1255</font>                // the above method returns <a name="line.1255"></a>
<font color="green">1256</font>                if (primitiveClazz != null) {<a name="line.1256"></a>
<font color="green">1257</font>                    return primitiveClazz;<a name="line.1257"></a>
<font color="green">1258</font>                } else {<a name="line.1258"></a>
<font color="green">1259</font>                    return clazz;<a name="line.1259"></a>
<font color="green">1260</font>                }<a name="line.1260"></a>
<font color="green">1261</font>            } else {<a name="line.1261"></a>
<font color="green">1262</font>                return clazz;<a name="line.1262"></a>
<font color="green">1263</font>            }<a name="line.1263"></a>
<font color="green">1264</font>        }<a name="line.1264"></a>
<font color="green">1265</font>        <a name="line.1265"></a>
<font color="green">1266</font>    <a name="line.1266"></a>
<font color="green">1267</font>        /**<a name="line.1267"></a>
<font color="green">1268</font>         * Return the method from the cache, if present.<a name="line.1268"></a>
<font color="green">1269</font>         *<a name="line.1269"></a>
<font color="green">1270</font>         * @param md The method descriptor<a name="line.1270"></a>
<font color="green">1271</font>         * @return The cached method<a name="line.1271"></a>
<font color="green">1272</font>         */<a name="line.1272"></a>
<font color="green">1273</font>        private static Method getCachedMethod(MethodDescriptor md) {<a name="line.1273"></a>
<font color="green">1274</font>            if (CACHE_METHODS) {<a name="line.1274"></a>
<font color="green">1275</font>                Reference methodRef = (Reference)cache.get(md);<a name="line.1275"></a>
<font color="green">1276</font>                if (methodRef != null) {<a name="line.1276"></a>
<font color="green">1277</font>                    return (Method)methodRef.get();<a name="line.1277"></a>
<font color="green">1278</font>                }<a name="line.1278"></a>
<font color="green">1279</font>            }<a name="line.1279"></a>
<font color="green">1280</font>            return null;<a name="line.1280"></a>
<font color="green">1281</font>        }<a name="line.1281"></a>
<font color="green">1282</font>    <a name="line.1282"></a>
<font color="green">1283</font>        /**<a name="line.1283"></a>
<font color="green">1284</font>         * Add a method to the cache.<a name="line.1284"></a>
<font color="green">1285</font>         *<a name="line.1285"></a>
<font color="green">1286</font>         * @param md The method descriptor<a name="line.1286"></a>
<font color="green">1287</font>         * @param method The method to cache<a name="line.1287"></a>
<font color="green">1288</font>         */<a name="line.1288"></a>
<font color="green">1289</font>        private static void cacheMethod(MethodDescriptor md, Method method) {<a name="line.1289"></a>
<font color="green">1290</font>            if (CACHE_METHODS) {<a name="line.1290"></a>
<font color="green">1291</font>                if (method != null) {<a name="line.1291"></a>
<font color="green">1292</font>                    cache.put(md, new WeakReference(method));<a name="line.1292"></a>
<font color="green">1293</font>                }<a name="line.1293"></a>
<font color="green">1294</font>            }<a name="line.1294"></a>
<font color="green">1295</font>        }<a name="line.1295"></a>
<font color="green">1296</font>    <a name="line.1296"></a>
<font color="green">1297</font>        /**<a name="line.1297"></a>
<font color="green">1298</font>         * Represents the key to looking up a Method by reflection.<a name="line.1298"></a>
<font color="green">1299</font>         */<a name="line.1299"></a>
<font color="green">1300</font>        private static class MethodDescriptor {<a name="line.1300"></a>
<font color="green">1301</font>            private Class cls;<a name="line.1301"></a>
<font color="green">1302</font>            private String methodName;<a name="line.1302"></a>
<font color="green">1303</font>            private Class[] paramTypes;<a name="line.1303"></a>
<font color="green">1304</font>            private boolean exact;<a name="line.1304"></a>
<font color="green">1305</font>            private int hashCode;<a name="line.1305"></a>
<font color="green">1306</font>    <a name="line.1306"></a>
<font color="green">1307</font>            /**<a name="line.1307"></a>
<font color="green">1308</font>             * The sole constructor.<a name="line.1308"></a>
<font color="green">1309</font>             *<a name="line.1309"></a>
<font color="green">1310</font>             * @param cls  the class to reflect, must not be null<a name="line.1310"></a>
<font color="green">1311</font>             * @param methodName  the method name to obtain<a name="line.1311"></a>
<font color="green">1312</font>             * @param paramTypes the array of classes representing the paramater types<a name="line.1312"></a>
<font color="green">1313</font>             * @param exact whether the match has to be exact.<a name="line.1313"></a>
<font color="green">1314</font>             */<a name="line.1314"></a>
<font color="green">1315</font>            public MethodDescriptor(Class cls, String methodName, Class[] paramTypes, boolean exact) {<a name="line.1315"></a>
<font color="green">1316</font>                if (cls == null) {<a name="line.1316"></a>
<font color="green">1317</font>                    throw new IllegalArgumentException("Class cannot be null");<a name="line.1317"></a>
<font color="green">1318</font>                }<a name="line.1318"></a>
<font color="green">1319</font>                if (methodName == null) {<a name="line.1319"></a>
<font color="green">1320</font>                    throw new IllegalArgumentException("Method Name cannot be null");<a name="line.1320"></a>
<font color="green">1321</font>                }<a name="line.1321"></a>
<font color="green">1322</font>                if (paramTypes == null) {<a name="line.1322"></a>
<font color="green">1323</font>                    paramTypes = EMPTY_CLASS_PARAMETERS;<a name="line.1323"></a>
<font color="green">1324</font>                }<a name="line.1324"></a>
<font color="green">1325</font>    <a name="line.1325"></a>
<font color="green">1326</font>                this.cls = cls;<a name="line.1326"></a>
<font color="green">1327</font>                this.methodName = methodName;<a name="line.1327"></a>
<font color="green">1328</font>                this.paramTypes = paramTypes;<a name="line.1328"></a>
<font color="green">1329</font>                this.exact= exact;<a name="line.1329"></a>
<font color="green">1330</font>    <a name="line.1330"></a>
<font color="green">1331</font>                this.hashCode = methodName.length();<a name="line.1331"></a>
<font color="green">1332</font>            }<a name="line.1332"></a>
<font color="green">1333</font>            /**<a name="line.1333"></a>
<font color="green">1334</font>             * Checks for equality.<a name="line.1334"></a>
<font color="green">1335</font>             * @param obj object to be tested for equality<a name="line.1335"></a>
<font color="green">1336</font>             * @return true, if the object describes the same Method.<a name="line.1336"></a>
<font color="green">1337</font>             */<a name="line.1337"></a>
<font color="green">1338</font>            public boolean equals(Object obj) {<a name="line.1338"></a>
<font color="green">1339</font>                if (!(obj instanceof MethodDescriptor)) {<a name="line.1339"></a>
<font color="green">1340</font>                    return false;<a name="line.1340"></a>
<font color="green">1341</font>                }<a name="line.1341"></a>
<font color="green">1342</font>                MethodDescriptor md = (MethodDescriptor)obj;<a name="line.1342"></a>
<font color="green">1343</font>    <a name="line.1343"></a>
<font color="green">1344</font>                return (<a name="line.1344"></a>
<font color="green">1345</font>                    exact == md.exact &amp;&amp;<a name="line.1345"></a>
<font color="green">1346</font>                    methodName.equals(md.methodName) &amp;&amp;<a name="line.1346"></a>
<font color="green">1347</font>                    cls.equals(md.cls) &amp;&amp;<a name="line.1347"></a>
<font color="green">1348</font>                    java.util.Arrays.equals(paramTypes, md.paramTypes)<a name="line.1348"></a>
<font color="green">1349</font>                );<a name="line.1349"></a>
<font color="green">1350</font>            }<a name="line.1350"></a>
<font color="green">1351</font>            /**<a name="line.1351"></a>
<font color="green">1352</font>             * Returns the string length of method name. I.e. if the<a name="line.1352"></a>
<font color="green">1353</font>             * hashcodes are different, the objects are different. If the<a name="line.1353"></a>
<font color="green">1354</font>             * hashcodes are the same, need to use the equals method to<a name="line.1354"></a>
<font color="green">1355</font>             * determine equality.<a name="line.1355"></a>
<font color="green">1356</font>             * @return the string length of method name.<a name="line.1356"></a>
<font color="green">1357</font>             */<a name="line.1357"></a>
<font color="green">1358</font>            public int hashCode() {<a name="line.1358"></a>
<font color="green">1359</font>                return hashCode;<a name="line.1359"></a>
<font color="green">1360</font>            }<a name="line.1360"></a>
<font color="green">1361</font>        }<a name="line.1361"></a>
<font color="green">1362</font>    }<a name="line.1362"></a>




























































</pre>
</body>
</html>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/54/">54</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          文章目录
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/nezha.jpg"
      alt="吒儿">
  <p class="site-author-name" itemprop="name">吒儿</p>
  <div class="site-description" itemprop="description">去他个鸟命!我命由我,不由天!是魔是仙,我自己决定!</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">539</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吒儿</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
